// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const deleteAPIStandard = `-- name: DeleteAPIStandard :exec
DELETE
FROM api_standards
WHERE "api_standard_handle" = $1
`

func (q *Queries) DeleteAPIStandard(ctx context.Context, apiStandardHandle string) error {
	_, err := q.db.Exec(ctx, deleteAPIStandard, apiStandardHandle)
	return err
}

const deleteAllRecords = `-- name: DeleteAllRecords :exec
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
          AND table_name NOT IN ('key_methods', 'vdb_roles')
    LOOP
        EXECUTE format('DELETE FROM %I;', r.table_name);
    END LOOP;
END $$
`

func (q *Queries) DeleteAllRecords(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllRecords)
	return err
}

const deleteDocEmbeddings = `-- name: DeleteDocEmbeddings :exec
DELETE FROM embeddings e
USING projects p
WHERE e."owner" = $1
  AND e."project_id" = p."project_id"
  AND p."project_handle" = $2
  AND e."text_id" = $3
`

type DeleteDocEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

func (q *Queries) DeleteDocEmbeddings(ctx context.Context, arg DeleteDocEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, deleteDocEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	return err
}

const deleteEmbeddingsByID = `-- name: DeleteEmbeddingsByID :exec
DELETE
FROM embeddings
WHERE "embeddings_id" = $1
`

func (q *Queries) DeleteEmbeddingsByID(ctx context.Context, embeddingsID int32) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByID, embeddingsID)
	return err
}

const deleteEmbeddingsByProject = `-- name: DeleteEmbeddingsByProject :exec
DELETE
FROM embeddings
USING embeddings AS e
JOIN projects AS p
ON e."project_id" = p."project_id"
WHERE embeddings."owner" = $1
AND embeddings."project_id" = e."project_id"
AND p."project_handle" = $2
`

type DeleteEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteEmbeddingsByProject(ctx context.Context, arg DeleteEmbeddingsByProjectParams) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteLLM = `-- name: DeleteLLM :exec
DELETE
FROM llm_services
WHERE "owner" = $1
AND "llm_service_handle" = $2
`

type DeleteLLMParams struct {
	Owner            string `db:"owner" json:"owner"`
	LLMServiceHandle string `db:"llm_service_handle" json:"llm_service_handle"`
}

func (q *Queries) DeleteLLM(ctx context.Context, arg DeleteLLMParams) error {
	_, err := q.db.Exec(ctx, deleteLLM, arg.Owner, arg.LLMServiceHandle)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
`

type DeleteProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE "user_handle" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userHandle string) error {
	_, err := q.db.Exec(ctx, deleteUser, userHandle)
	return err
}

const getAPIStandards = `-- name: GetAPIStandards :many
SELECT api_standard_handle, description, key_method, key_field, created_at, updated_at
FROM api_standards
ORDER BY "api_standard_handle" ASC LIMIT $1 OFFSET $2
`

type GetAPIStandardsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAPIStandards(ctx context.Context, arg GetAPIStandardsParams) ([]APIStandard, error) {
	rows, err := q.db.Query(ctx, getAPIStandards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []APIStandard
	for rows.Next() {
		var i APIStandard
		if err := rows.Scan(
			&i.APIStandardHandle,
			&i.Description,
			&i.KeyMethod,
			&i.KeyField,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmbeddingsByProject = `-- name: GetEmbeddingsByProject :many
SELECT embeddings.embeddings_id, embeddings.text_id, embeddings.owner, embeddings.project_id, embeddings.llm_service_id, embeddings.text, embeddings.vector, embeddings.vector_dim, embeddings.metadata, embeddings.created_at, embeddings.updated_at, projects."project_handle", llm_services."llm_service_handle"
FROM embeddings
JOIN llm_services
ON llm_services."llm_service_id" = embeddings."llm_service_id"
JOIN projects
ON projects."project_id" = embeddings."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
ORDER BY embeddings."text_id" ASC LIMIT $3 OFFSET $4
`

type GetEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetEmbeddingsByProjectRow struct {
	EmbeddingsID     int32                  `db:"embeddings_id" json:"embeddings_id"`
	TextID           pgtype.Text            `db:"text_id" json:"text_id"`
	Owner            string                 `db:"owner" json:"owner"`
	ProjectID        int32                  `db:"project_id" json:"project_id"`
	LLMServiceID     int32                  `db:"llm_service_id" json:"llm_service_id"`
	Text             pgtype.Text            `db:"text" json:"text"`
	Vector           pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim        int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata         []byte                 `db:"metadata" json:"metadata"`
	CreatedAt        pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle    string                 `db:"project_handle" json:"project_handle"`
	LLMServiceHandle string                 `db:"llm_service_handle" json:"llm_service_handle"`
}

func (q *Queries) GetEmbeddingsByProject(ctx context.Context, arg GetEmbeddingsByProjectParams) ([]GetEmbeddingsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getEmbeddingsByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmbeddingsByProjectRow
	for rows.Next() {
		var i GetEmbeddingsByProjectRow
		if err := rows.Scan(
			&i.EmbeddingsID,
			&i.TextID,
			&i.Owner,
			&i.ProjectID,
			&i.LLMServiceID,
			&i.Text,
			&i.Vector,
			&i.VectorDim,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectHandle,
			&i.LLMServiceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeyByUser = `-- name: GetKeyByUser :one
SELECT "vdb_api_key"
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

// SELECT encode("vdb_api_key", 'hex') AS "vdb_api_key" FROM users
func (q *Queries) GetKeyByUser(ctx context.Context, userHandle string) (string, error) {
	row := q.db.QueryRow(ctx, getKeyByUser, userHandle)
	var vdb_api_key string
	err := row.Scan(&vdb_api_key)
	return vdb_api_key, err
}

const getKeysByLinkedUsers = `-- name: GetKeysByLinkedUsers :many
SELECT users."user_handle", users_projects."role", users."vdb_api_key"
FROM users
JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects
ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1
AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetKeysByLinkedUsersParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetKeysByLinkedUsersRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
	VdbAPIKey  string `db:"vdb_api_key" json:"vdb_api_key"`
}

// SELECT users."user_handle", users_projects."role", encode(users."vdb_api_key", 'hex') AS "vdb_api_key"
func (q *Queries) GetKeysByLinkedUsers(ctx context.Context, arg GetKeysByLinkedUsersParams) ([]GetKeysByLinkedUsersRow, error) {
	rows, err := q.db.Query(ctx, getKeysByLinkedUsers,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeysByLinkedUsersRow
	for rows.Next() {
		var i GetKeysByLinkedUsersRow
		if err := rows.Scan(&i.UserHandle, &i.Role, &i.VdbAPIKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByProject = `-- name: GetLLMsByProject :many
SELECT llm_services.llm_service_id, llm_services.llm_service_handle, llm_services.owner, llm_services.endpoint, llm_services.description, llm_services.api_key, llm_services.api_standard, llm_services.model, llm_services.dimensions, llm_services.created_at, llm_services.updated_at
FROM llm_services
JOIN (
  projects_llm_services JOIN projects
  ON projects_llm_services."project_id" = projects."project_id"
)
ON llm_services."llm_service_id" = projects_llm_services."llm_service_id"
WHERE projects."owner" = $1
  AND projects."project_handle" = $2
ORDER BY llm_services."llm_service_handle" ASC LIMIT $3 OFFSET $4
`

type GetLLMsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMsByProject(ctx context.Context, arg GetLLMsByProjectParams) ([]LlmService, error) {
	rows, err := q.db.Query(ctx, getLLMsByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmService
	for rows.Next() {
		var i LlmService
		if err := rows.Scan(
			&i.LLMServiceID,
			&i.LLMServiceHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIKey,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByUser = `-- name: GetLLMsByUser :many
SELECT llm_services.llm_service_id, llm_services.llm_service_handle, llm_services.owner, llm_services.endpoint, llm_services.description, llm_services.api_key, llm_services.api_standard, llm_services.model, llm_services.dimensions, llm_services.created_at, llm_services.updated_at, users_llm_services."role"
FROM llm_services
JOIN users_llm_services
ON llm_services."llm_service_id" = users_llm_services."llm_service_id"
WHERE users_llm_services."user_handle" = $1
ORDER BY llm_services."llm_service_handle" ASC LIMIT $2 OFFSET $3
`

type GetLLMsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetLLMsByUserRow struct {
	LLMServiceID     int32            `db:"llm_service_id" json:"llm_service_id"`
	LLMServiceHandle string           `db:"llm_service_handle" json:"llm_service_handle"`
	Owner            string           `db:"owner" json:"owner"`
	Endpoint         string           `db:"endpoint" json:"endpoint"`
	Description      pgtype.Text      `db:"description" json:"description"`
	APIKey           pgtype.Text      `db:"api_key" json:"api_key"`
	APIStandard      string           `db:"api_standard" json:"api_standard"`
	Model            string           `db:"model" json:"model"`
	Dimensions       int32            `db:"dimensions" json:"dimensions"`
	CreatedAt        pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Role             string           `db:"role" json:"role"`
}

func (q *Queries) GetLLMsByUser(ctx context.Context, arg GetLLMsByUserParams) ([]GetLLMsByUserRow, error) {
	rows, err := q.db.Query(ctx, getLLMsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLLMsByUserRow
	for rows.Next() {
		var i GetLLMsByUserRow
		if err := rows.Scan(
			&i.LLMServiceID,
			&i.LLMServiceHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIKey,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfEmbeddingsByProject = `-- name: GetNumberOfEmbeddingsByProject :one
SELECT COUNT(*)
FROM embeddings
JOIN projects
ON embeddings."project_id" = projects."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
`

type GetNumberOfEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) GetNumberOfEmbeddingsByProject(ctx context.Context, arg GetNumberOfEmbeddingsByProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfEmbeddingsByProject, arg.Owner, arg.ProjectHandle)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT projects.project_id, projects.project_handle, projects.owner, projects.description, projects.metadata_scheme, projects.created_at, projects.updated_at, users_projects."role"
FROM projects
JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
ORDER BY projects."project_handle" ASC LIMIT $2 OFFSET $3
`

type GetProjectsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetProjectsByUserRow struct {
	ProjectID      int32            `db:"project_id" json:"project_id"`
	ProjectHandle  string           `db:"project_handle" json:"project_handle"`
	Owner          string           `db:"owner" json:"owner"`
	Description    pgtype.Text      `db:"description" json:"description"`
	MetadataScheme pgtype.Text      `db:"metadata_scheme" json:"metadata_scheme"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Role           string           `db:"role" json:"role"`
}

func (q *Queries) GetProjectsByUser(ctx context.Context, arg GetProjectsByUserParams) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectHandle,
			&i.Owner,
			&i.Description,
			&i.MetadataScheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByID = `-- name: GetSimilarsByID :many
SELECT e2."text_id"
FROM embeddings e1
CROSS JOIN embeddings e2
JOIN projects
ON e1."project_id" = projects."project_id"
WHERE e2."embeddings_id" != e1."embeddings_id"
  AND e1."text_id" = $1
  AND e1."owner" = $2
  AND projects."project_handle" = $3
  AND 1 - (e1.vector <=> e2.vector) >= $4::double precision
ORDER BY e1.vector <=> e2.vector
LIMIT $5 OFFSET $6
`

type GetSimilarsByIDParams struct {
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	Column4       float64     `db:"column_4" json:"column_4"`
	Limit         int32       `db:"limit" json:"limit"`
	Offset        int32       `db:"offset" json:"offset"`
}

// 1 - (e1.vector <=> e2.vector) AS cosine_similarity
func (q *Queries) GetSimilarsByID(ctx context.Context, arg GetSimilarsByIDParams) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getSimilarsByID,
		arg.TextID,
		arg.Owner,
		arg.ProjectHandle,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var text_id pgtype.Text
		if err := rows.Scan(&text_id); err != nil {
			return nil, err
		}
		items = append(items, text_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByVector = `-- name: GetSimilarsByVector :many
SELECT embeddings."embeddings_id", embeddings."text_id", llm_services."owner", llm_services."llm_service_handle"
FROM embeddings
JOIN llm_services
ON embeddings."llm_service_id" = llm_services."llm_service_id"
ORDER BY "vector" <=> $1
LIMIT $2 OFFSET $3
`

type GetSimilarsByVectorParams struct {
	Vector pgvector_go.HalfVector `db:"vector" json:"vector"`
	Limit  int32                  `db:"limit" json:"limit"`
	Offset int32                  `db:"offset" json:"offset"`
}

type GetSimilarsByVectorRow struct {
	EmbeddingsID     int32       `db:"embeddings_id" json:"embeddings_id"`
	TextID           pgtype.Text `db:"text_id" json:"text_id"`
	Owner            string      `db:"owner" json:"owner"`
	LLMServiceHandle string      `db:"llm_service_handle" json:"llm_service_handle"`
}

func (q *Queries) GetSimilarsByVector(ctx context.Context, arg GetSimilarsByVectorParams) ([]GetSimilarsByVectorRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByVector, arg.Vector, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByVectorRow
	for rows.Next() {
		var i GetSimilarsByVectorRow
		if err := rows.Scan(
			&i.EmbeddingsID,
			&i.TextID,
			&i.Owner,
			&i.LLMServiceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT "user_handle"
FROM users
ORDER BY "user_handle" ASC LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_handle string
		if err := rows.Scan(&user_handle); err != nil {
			return nil, err
		}
		items = append(items, user_handle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByProject = `-- name: GetUsersByProject :many
SELECT users."user_handle", users_projects."role"
FROM users JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1 AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetUsersByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetUsersByProjectRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) GetUsersByProject(ctx context.Context, arg GetUsersByProjectParams) ([]GetUsersByProjectRow, error) {
	rows, err := q.db.Query(ctx, getUsersByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByProjectRow
	for rows.Next() {
		var i GetUsersByProjectRow
		if err := rows.Scan(&i.UserHandle, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkProjectToLLM = `-- name: LinkProjectToLLM :exec
INSERT
INTO projects_llm_services (
  "project_id", "llm_service_id", "created_at", "updated_at"
) VALUES (
  $1, $2, NOW(), NOW()
)
ON CONFLICT ("project_id", "llm_service_id") DO NOTHING
RETURNING project_id, llm_service_id, created_at, updated_at
`

type LinkProjectToLLMParams struct {
	ProjectID    int32 `db:"project_id" json:"project_id"`
	LLMServiceID int32 `db:"llm_service_id" json:"llm_service_id"`
}

func (q *Queries) LinkProjectToLLM(ctx context.Context, arg LinkProjectToLLMParams) error {
	_, err := q.db.Exec(ctx, linkProjectToLLM, arg.ProjectID, arg.LLMServiceID)
	return err
}

const linkProjectToUser = `-- name: LinkProjectToUser :one
INSERT
INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "project_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, project_id, role, created_at, updated_at
`

type LinkProjectToUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	ProjectID  int32  `db:"project_id" json:"project_id"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) LinkProjectToUser(ctx context.Context, arg LinkProjectToUserParams) (UsersProject, error) {
	row := q.db.QueryRow(ctx, linkProjectToUser, arg.UserHandle, arg.ProjectID, arg.Role)
	var i UsersProject
	err := row.Scan(
		&i.UserHandle,
		&i.ProjectID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkUserToLLM = `-- name: LinkUserToLLM :exec
INSERT
INTO users_llm_services (
  "user_handle", "llm_service_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "llm_service_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, llm_service_id, role, created_at, updated_at
`

type LinkUserToLLMParams struct {
	UserHandle   string `db:"user_handle" json:"user_handle"`
	LLMServiceID int32  `db:"llm_service_id" json:"llm_service_id"`
	Role         string `db:"role" json:"role"`
}

func (q *Queries) LinkUserToLLM(ctx context.Context, arg LinkUserToLLMParams) error {
	_, err := q.db.Exec(ctx, linkUserToLLM, arg.UserHandle, arg.LLMServiceID, arg.Role)
	return err
}

const resetAllSerials = `-- name: ResetAllSerials :exec
DO $$
DECLARE
    seq_name text;
BEGIN
    FOR seq_name IN
      SELECT sequence_name
      FROM information_schema.sequences
      WHERE sequence_schema = 'public' AND sequence_name LIKE '%_seq'
    LOOP
        EXECUTE format('ALTER SEQUENCE public.%I RESTART WITH 1', seq_name);
    END LOOP;
END $$
`

func (q *Queries) ResetAllSerials(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllSerials)
	return err
}

const retrieveAPIStandard = `-- name: RetrieveAPIStandard :one
SELECT api_standard_handle, description, key_method, key_field, created_at, updated_at
FROM api_standards
WHERE "api_standard_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveAPIStandard(ctx context.Context, apiStandardHandle string) (APIStandard, error) {
	row := q.db.QueryRow(ctx, retrieveAPIStandard, apiStandardHandle)
	var i APIStandard
	err := row.Scan(
		&i.APIStandardHandle,
		&i.Description,
		&i.KeyMethod,
		&i.KeyField,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveEmbeddings = `-- name: RetrieveEmbeddings :one
SELECT embeddings.embeddings_id, embeddings.text_id, embeddings.owner, embeddings.project_id, embeddings.llm_service_id, embeddings.text, embeddings.vector, embeddings.vector_dim, embeddings.metadata, embeddings.created_at, embeddings.updated_at, projects."project_handle", llm_services."llm_service_handle"
FROM embeddings
JOIN llm_services
ON embeddings."llm_service_id" = llm_services."llm_service_id"
JOIN projects
ON embeddings."project_id" = projects."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
AND embeddings."text_id" = $3
LIMIT 1
`

type RetrieveEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

type RetrieveEmbeddingsRow struct {
	EmbeddingsID     int32                  `db:"embeddings_id" json:"embeddings_id"`
	TextID           pgtype.Text            `db:"text_id" json:"text_id"`
	Owner            string                 `db:"owner" json:"owner"`
	ProjectID        int32                  `db:"project_id" json:"project_id"`
	LLMServiceID     int32                  `db:"llm_service_id" json:"llm_service_id"`
	Text             pgtype.Text            `db:"text" json:"text"`
	Vector           pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim        int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata         []byte                 `db:"metadata" json:"metadata"`
	CreatedAt        pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle    string                 `db:"project_handle" json:"project_handle"`
	LLMServiceHandle string                 `db:"llm_service_handle" json:"llm_service_handle"`
}

func (q *Queries) RetrieveEmbeddings(ctx context.Context, arg RetrieveEmbeddingsParams) (RetrieveEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, retrieveEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	var i RetrieveEmbeddingsRow
	err := row.Scan(
		&i.EmbeddingsID,
		&i.TextID,
		&i.Owner,
		&i.ProjectID,
		&i.LLMServiceID,
		&i.Text,
		&i.Vector,
		&i.VectorDim,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectHandle,
		&i.LLMServiceHandle,
	)
	return i, err
}

const retrieveLLM = `-- name: RetrieveLLM :one
SELECT llm_service_id, llm_service_handle, owner, endpoint, description, api_key, api_standard, model, dimensions, created_at, updated_at
FROM llm_services
WHERE "owner" = $1
AND "llm_service_handle" = $2
LIMIT 1
`

type RetrieveLLMParams struct {
	Owner            string `db:"owner" json:"owner"`
	LLMServiceHandle string `db:"llm_service_handle" json:"llm_service_handle"`
}

func (q *Queries) RetrieveLLM(ctx context.Context, arg RetrieveLLMParams) (LlmService, error) {
	row := q.db.QueryRow(ctx, retrieveLLM, arg.Owner, arg.LLMServiceHandle)
	var i LlmService
	err := row.Scan(
		&i.LLMServiceID,
		&i.LLMServiceHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIKey,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveProject = `-- name: RetrieveProject :one
SELECT project_id, project_handle, owner, description, metadata_scheme, created_at, updated_at
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
LIMIT 1
`

type RetrieveProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) RetrieveProject(ctx context.Context, arg RetrieveProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, retrieveProject, arg.Owner, arg.ProjectHandle)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ProjectHandle,
		&i.Owner,
		&i.Description,
		&i.MetadataScheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT user_handle, name, email, vdb_api_key, created_at, updated_at
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveUser(ctx context.Context, userHandle string) (User, error) {
	row := q.db.QueryRow(ctx, retrieveUser, userHandle)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbAPIKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAPIStandard = `-- name: UpsertAPIStandard :one
INSERT
INTO api_standards (
  "api_standard_handle", "description", "key_method", "key_field", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("api_standard_handle") DO UPDATE SET
  "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "updated_at" = NOW()
RETURNING "api_standard_handle"
`

type UpsertAPIStandardParams struct {
	APIStandardHandle string      `db:"api_standard_handle" json:"api_standard_handle"`
	Description       pgtype.Text `db:"description" json:"description"`
	KeyMethod         string      `db:"key_method" json:"key_method"`
	KeyField          pgtype.Text `db:"key_field" json:"key_field"`
}

func (q *Queries) UpsertAPIStandard(ctx context.Context, arg UpsertAPIStandardParams) (string, error) {
	row := q.db.QueryRow(ctx, upsertAPIStandard,
		arg.APIStandardHandle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
	)
	var api_standard_handle string
	err := row.Scan(&api_standard_handle)
	return api_standard_handle, err
}

const upsertEmbeddings = `-- name: UpsertEmbeddings :one
INSERT
INTO embeddings (
  "text_id", "owner", "project_id", "llm_service_id", "text", "vector", "vector_dim", "metadata", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
)
ON CONFLICT ("text_id", "owner", "project_id", "llm_service_id") DO UPDATE SET
  "text" = $5,
  "vector" = $6,
  "vector_dim" = $7,
  "metadata" = $8,
  "updated_at" = NOW()
RETURNING "embeddings_id", "text_id", "owner", "project_id", "llm_service_id"
`

type UpsertEmbeddingsParams struct {
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Owner        string                 `db:"owner" json:"owner"`
	ProjectID    int32                  `db:"project_id" json:"project_id"`
	LLMServiceID int32                  `db:"llm_service_id" json:"llm_service_id"`
	Text         pgtype.Text            `db:"text" json:"text"`
	Vector       pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim    int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata     []byte                 `db:"metadata" json:"metadata"`
}

type UpsertEmbeddingsRow struct {
	EmbeddingsID int32       `db:"embeddings_id" json:"embeddings_id"`
	TextID       pgtype.Text `db:"text_id" json:"text_id"`
	Owner        string      `db:"owner" json:"owner"`
	ProjectID    int32       `db:"project_id" json:"project_id"`
	LLMServiceID int32       `db:"llm_service_id" json:"llm_service_id"`
}

func (q *Queries) UpsertEmbeddings(ctx context.Context, arg UpsertEmbeddingsParams) (UpsertEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, upsertEmbeddings,
		arg.TextID,
		arg.Owner,
		arg.ProjectID,
		arg.LLMServiceID,
		arg.Text,
		arg.Vector,
		arg.VectorDim,
		arg.Metadata,
	)
	var i UpsertEmbeddingsRow
	err := row.Scan(
		&i.EmbeddingsID,
		&i.TextID,
		&i.Owner,
		&i.ProjectID,
		&i.LLMServiceID,
	)
	return i, err
}

const upsertLLM = `-- name: UpsertLLM :one
INSERT
INTO llm_services (
  "owner", "llm_service_handle", "endpoint", "description", "api_key", "api_standard", "model", "dimensions", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
)
ON CONFLICT ("owner", "llm_service_handle") DO UPDATE SET
  "endpoint" = $3,
  "description" = $4,
  "api_key" = $5,
  "api_standard" = $6,
  "model" = $7,
  "dimensions" = $8,
  "updated_at" = NOW()
RETURNING "owner", "llm_service_handle", "llm_service_id"
`

type UpsertLLMParams struct {
	Owner            string      `db:"owner" json:"owner"`
	LLMServiceHandle string      `db:"llm_service_handle" json:"llm_service_handle"`
	Endpoint         string      `db:"endpoint" json:"endpoint"`
	Description      pgtype.Text `db:"description" json:"description"`
	APIKey           pgtype.Text `db:"api_key" json:"api_key"`
	APIStandard      string      `db:"api_standard" json:"api_standard"`
	Model            string      `db:"model" json:"model"`
	Dimensions       int32       `db:"dimensions" json:"dimensions"`
}

type UpsertLLMRow struct {
	Owner            string `db:"owner" json:"owner"`
	LLMServiceHandle string `db:"llm_service_handle" json:"llm_service_handle"`
	LLMServiceID     int32  `db:"llm_service_id" json:"llm_service_id"`
}

func (q *Queries) UpsertLLM(ctx context.Context, arg UpsertLLMParams) (UpsertLLMRow, error) {
	row := q.db.QueryRow(ctx, upsertLLM,
		arg.Owner,
		arg.LLMServiceHandle,
		arg.Endpoint,
		arg.Description,
		arg.APIKey,
		arg.APIStandard,
		arg.Model,
		arg.Dimensions,
	)
	var i UpsertLLMRow
	err := row.Scan(&i.Owner, &i.LLMServiceHandle, &i.LLMServiceID)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
INSERT
INTO projects (
  "project_handle", "owner", "description", "metadata_scheme", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("owner", "project_handle") DO UPDATE SET
  "description" = $3,
  "metadata_scheme" = $4,
  "updated_at" = NOW()
RETURNING "project_id", "owner", "project_handle"
`

type UpsertProjectParams struct {
	ProjectHandle  string      `db:"project_handle" json:"project_handle"`
	Owner          string      `db:"owner" json:"owner"`
	Description    pgtype.Text `db:"description" json:"description"`
	MetadataScheme pgtype.Text `db:"metadata_scheme" json:"metadata_scheme"`
}

type UpsertProjectRow struct {
	ProjectID     int32  `db:"project_id" json:"project_id"`
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (UpsertProjectRow, error) {
	row := q.db.QueryRow(ctx, upsertProject,
		arg.ProjectHandle,
		arg.Owner,
		arg.Description,
		arg.MetadataScheme,
	)
	var i UpsertProjectRow
	err := row.Scan(&i.ProjectID, &i.Owner, &i.ProjectHandle)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT
INTO users (
  "user_handle", "name", "email", "vdb_api_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("user_handle") DO UPDATE SET
  "name" = $2,
  "email" = $3,
  "vdb_api_key" = $4,
  "updated_at" = NOW()
RETURNING user_handle, name, email, vdb_api_key, created_at, updated_at
`

type UpsertUserParams struct {
	UserHandle string      `db:"user_handle" json:"user_handle"`
	Name       pgtype.Text `db:"name" json:"name"`
	Email      string      `db:"email" json:"email"`
	VdbAPIKey  string      `db:"vdb_api_key" json:"vdb_api_key"`
}

// Generate go code with: sqlc generate
//
//	$1, $2, $3, (decode(sqlc.arg(vdb_api_key)::bytea, 'hex')), NOW(), NOW()
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.UserHandle,
		arg.Name,
		arg.Email,
		arg.VdbAPIKey,
	)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbAPIKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
