// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const deleteAPI = `-- name: DeleteAPI :exec
DELETE FROM api_standards
WHERE "handle" = $1
`

func (q *Queries) DeleteAPI(ctx context.Context, handle string) error {
	_, err := q.db.Exec(ctx, deleteAPI, handle)
	return err
}

const deleteEmbeddings = `-- name: DeleteEmbeddings :exec
DELETE FROM embeddings
WHERE "id" = $1
`

func (q *Queries) DeleteEmbeddings(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEmbeddings, id)
	return err
}

const deleteLLM = `-- name: DeleteLLM :exec
DELETE FROM llmservices
WHERE "owner" = $1
  AND "handle" = $2
`

type DeleteLLMParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

func (q *Queries) DeleteLLM(ctx context.Context, arg DeleteLLMParams) error {
	_, err := q.db.Exec(ctx, deleteLLM, arg.Owner, arg.Handle)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE "owner" = $1
  AND "handle" = $2
`

type DeleteProjectParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.Owner, arg.Handle)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE "handle" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, handle string) error {
	_, err := q.db.Exec(ctx, deleteUser, handle)
	return err
}

const getAPIs = `-- name: GetAPIs :many
SELECT handle, description, key_method, key_field, vector_size, created_at, updated_at FROM api_standards
`

func (q *Queries) GetAPIs(ctx context.Context) ([]ApiStandard, error) {
	rows, err := q.db.Query(ctx, getAPIs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiStandard
	for rows.Next() {
		var i ApiStandard
		if err := rows.Scan(
			&i.Handle,
			&i.Description,
			&i.KeyMethod,
			&i.KeyField,
			&i.VectorSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmbeddingsByProject = `-- name: GetEmbeddingsByProject :many
SELECT embeddings.id, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice, embeddings.text, embeddings.metadata, embeddings.created_at, embeddings.updated_at, llmservices."owner", llmservices."handle"
FROM embeddings JOIN llmservices
ON embeddings."llmservice" = llmservices."llmservice_id"
JOIN projects_llmservices
ON embeddings."llmservice" = projects_llmservices."llmservice"
JOIN projects
ON projects_llmservices."project" = projects."project_id"
WHERE projects."owner" = $1
  AND projects."handle" = $2
`

type GetEmbeddingsByProjectParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

type GetEmbeddingsByProjectRow struct {
	ID           int32            `json:"id"`
	TextID       pgtype.Text      `json:"text_id"`
	Embedding    interface{}      `json:"embedding"`
	EmbeddingDim int32            `json:"embedding_dim"`
	Llmservice   int32            `json:"llmservice"`
	Text         pgtype.Text      `json:"text"`
	Metadata     []byte           `json:"metadata"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Owner        string           `json:"owner"`
	Handle       string           `json:"handle"`
}

func (q *Queries) GetEmbeddingsByProject(ctx context.Context, arg GetEmbeddingsByProjectParams) ([]GetEmbeddingsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getEmbeddingsByProject, arg.Owner, arg.Handle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmbeddingsByProjectRow
	for rows.Next() {
		var i GetEmbeddingsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.TextID,
			&i.Embedding,
			&i.EmbeddingDim,
			&i.Llmservice,
			&i.Text,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Owner,
			&i.Handle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByProject = `-- name: GetLLMsByProject :many
SELECT llmservices.llmservice_id, llmservices.handle, llmservices.owner, llmservices.description, llmservices.endpoint, llmservices.api_key, llmservices.api_standard, llmservices.created_at, llmservices.updated_at FROM llmservices
JOIN (
  projects_llmservices JOIN projects
  ON projects_llmservices."project" = projects."project_id"
)
ON llmservices."llmservice_id" = projects_llmservices."llmservice"
WHERE projects."owner" = $1
  AND projects."handle" = $2
`

type GetLLMsByProjectParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

func (q *Queries) GetLLMsByProject(ctx context.Context, arg GetLLMsByProjectParams) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByProject, arg.Owner, arg.Handle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LlmserviceID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByUser = `-- name: GetLLMsByUser :many
SELECT llmservices.llmservice_id, llmservices.handle, llmservices.owner, llmservices.description, llmservices.endpoint, llmservices.api_key, llmservices.api_standard, llmservices.created_at, llmservices.updated_at FROM llmservices
JOIN (
  projects_llmservices JOIN users_projects
  ON projects_llmservices."project" = users_projects."project_id"
)
ON llmservices."llmservice_id" = projects_llmservices."llmservice"
WHERE users_projects."user_handle" = $1
`

func (q *Queries) GetLLMsByUser(ctx context.Context, userHandle string) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByUser, userHandle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LlmserviceID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUser = `-- name: GetProjectsByUser :many

SELECT projects.project_id, projects.handle, projects.owner, projects.description, projects.created_at, projects.updated_at, users_projects."role"
FROM projects JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
`

type GetProjectsByUserRow struct {
	ProjectID   int32            `json:"project_id"`
	Handle      string           `json:"handle"`
	Owner       string           `json:"owner"`
	Description pgtype.Text      `json:"description"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
	UpdatedAt   pgtype.Timestamp `json:"updated_at"`
	Role        Role             `json:"role"`
}

// TODO: name: TransferProject :one
func (q *Queries) GetProjectsByUser(ctx context.Context, userHandle string) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, userHandle)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByVector = `-- name: GetSimilarsByVector :many
SELECT embeddings."id", embeddings."text_id", llmservices."owner", llmservices."handle"
FROM embeddings JOIN llmservices
ON embeddings."llmservice" = llmservices."llmservice_id"
ORDER BY "embedding" <#> $1 LIMIT 5
`

type GetSimilarsByVectorRow struct {
	ID     int32       `json:"id"`
	TextID pgtype.Text `json:"text_id"`
	Owner  string      `json:"owner"`
	Handle string      `json:"handle"`
}

func (q *Queries) GetSimilarsByVector(ctx context.Context, embedding interface{}) ([]GetSimilarsByVectorRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByVector, embedding)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByVectorRow
	for rows.Next() {
		var i GetSimilarsByVectorRow
		if err := rows.Scan(
			&i.ID,
			&i.TextID,
			&i.Owner,
			&i.Handle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT "handle" FROM users
`

func (q *Queries) GetUsers(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var handle string
		if err := rows.Scan(&handle); err != nil {
			return nil, err
		}
		items = append(items, handle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkProjectToLLM = `-- name: LinkProjectToLLM :exec
INSERT INTO projects_llmservices (
  "project", "llmservice", "created_at", "updated_at"
) VALUES (
  $1, $2, NOW(), NOW()
)
`

type LinkProjectToLLMParams struct {
	Project    int32 `json:"project"`
	Llmservice int32 `json:"llmservice"`
}

func (q *Queries) LinkProjectToLLM(ctx context.Context, arg LinkProjectToLLMParams) error {
	_, err := q.db.Exec(ctx, linkProjectToLLM, arg.Project, arg.Llmservice)
	return err
}

const linkProjectToUser = `-- name: LinkProjectToUser :one
INSERT INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
RETURNING user_handle, project_id, role, created_at, updated_at
`

type LinkProjectToUserParams struct {
	UserHandle string `json:"user_handle"`
	ProjectID  int32  `json:"project_id"`
	Role       Role   `json:"role"`
}

func (q *Queries) LinkProjectToUser(ctx context.Context, arg LinkProjectToUserParams) (UsersProject, error) {
	row := q.db.QueryRow(ctx, linkProjectToUser, arg.UserHandle, arg.ProjectID, arg.Role)
	var i UsersProject
	err := row.Scan(
		&i.UserHandle,
		&i.ProjectID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkUserToLLM = `-- name: LinkUserToLLM :exec
INSERT INTO users_llmservices (
  "user", "llmservice", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
`

type LinkUserToLLMParams struct {
	User       string `json:"user"`
	Llmservice int32  `json:"llmservice"`
	Role       Role   `json:"role"`
}

func (q *Queries) LinkUserToLLM(ctx context.Context, arg LinkUserToLLMParams) error {
	_, err := q.db.Exec(ctx, linkUserToLLM, arg.User, arg.Llmservice, arg.Role)
	return err
}

const retrieveAPI = `-- name: RetrieveAPI :one
SELECT handle, description, key_method, key_field, vector_size, created_at, updated_at FROM api_standards
WHERE "handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveAPI(ctx context.Context, handle string) (ApiStandard, error) {
	row := q.db.QueryRow(ctx, retrieveAPI, handle)
	var i ApiStandard
	err := row.Scan(
		&i.Handle,
		&i.Description,
		&i.KeyMethod,
		&i.KeyField,
		&i.VectorSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveEmbeddings = `-- name: RetrieveEmbeddings :one
SELECT embeddings.id, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice, embeddings.text, embeddings.metadata, embeddings.created_at, embeddings.updated_at, llmservices."owner", llmservices."handle"
FROM embeddings JOIN llmservices
ON embeddings."llmservice" = llmservices."llmservice_id"
WHERE "id" = $1 LIMIT 1
`

type RetrieveEmbeddingsRow struct {
	ID           int32            `json:"id"`
	TextID       pgtype.Text      `json:"text_id"`
	Embedding    interface{}      `json:"embedding"`
	EmbeddingDim int32            `json:"embedding_dim"`
	Llmservice   int32            `json:"llmservice"`
	Text         pgtype.Text      `json:"text"`
	Metadata     []byte           `json:"metadata"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
	UpdatedAt    pgtype.Timestamp `json:"updated_at"`
	Owner        string           `json:"owner"`
	Handle       string           `json:"handle"`
}

func (q *Queries) RetrieveEmbeddings(ctx context.Context, id int32) (RetrieveEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, retrieveEmbeddings, id)
	var i RetrieveEmbeddingsRow
	err := row.Scan(
		&i.ID,
		&i.TextID,
		&i.Embedding,
		&i.EmbeddingDim,
		&i.Llmservice,
		&i.Text,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Owner,
		&i.Handle,
	)
	return i, err
}

const retrieveLLM = `-- name: RetrieveLLM :one
SELECT llmservice_id, handle, owner, description, endpoint, api_key, api_standard, created_at, updated_at FROM llmservices
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1
`

type RetrieveLLMParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

func (q *Queries) RetrieveLLM(ctx context.Context, arg RetrieveLLMParams) (Llmservice, error) {
	row := q.db.QueryRow(ctx, retrieveLLM, arg.Owner, arg.Handle)
	var i Llmservice
	err := row.Scan(
		&i.LlmserviceID,
		&i.Handle,
		&i.Owner,
		&i.Description,
		&i.Endpoint,
		&i.ApiKey,
		&i.ApiStandard,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveProject = `-- name: RetrieveProject :one
SELECT project_id, handle, owner, description, created_at, updated_at FROM projects
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1
`

type RetrieveProjectParams struct {
	Owner  string `json:"owner"`
	Handle string `json:"handle"`
}

func (q *Queries) RetrieveProject(ctx context.Context, arg RetrieveProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, retrieveProject, arg.Owner, arg.Handle)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Handle,
		&i.Owner,
		&i.Description,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT handle, name, email, vdb_api_key, created_at, updated_at FROM users
WHERE "handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveUser(ctx context.Context, handle string) (User, error) {
	row := q.db.QueryRow(ctx, retrieveUser, handle)
	var i User
	err := row.Scan(
		&i.Handle,
		&i.Name,
		&i.Email,
		&i.VdbApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updateAPI = `-- name: UpdateAPI :one
UPDATE api_standards
  SET "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "vector_size" = $5,
  "created_at" = $6,
  "updated_at" = NOW()
WHERE "handle" = $1
RETURNING "handle"
`

type UpdateAPIParams struct {
	Handle      string           `json:"handle"`
	Description pgtype.Text      `json:"description"`
	KeyMethod   KeyMethod        `json:"key_method"`
	KeyField    pgtype.Text      `json:"key_field"`
	VectorSize  int32            `json:"vector_size"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) UpdateAPI(ctx context.Context, arg UpdateAPIParams) (string, error) {
	row := q.db.QueryRow(ctx, updateAPI,
		arg.Handle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
		arg.VectorSize,
		arg.CreatedAt,
	)
	var handle string
	err := row.Scan(&handle)
	return handle, err
}

const updateEmbeddings = `-- name: UpdateEmbeddings :one
UPDATE embeddings
  SET "text_id" = $2,
  "embedding" = $3,
  "embedding_dim" = $4,
  "llmservice" = $5,
  "text" = $6,
  "metadata" = $7,
  "created_at" = $8,
  "updated_at" = NOW()
WHERE "id" = $1
RETURNING "id"
`

type UpdateEmbeddingsParams struct {
	ID           int32            `json:"id"`
	TextID       pgtype.Text      `json:"text_id"`
	Embedding    interface{}      `json:"embedding"`
	EmbeddingDim int32            `json:"embedding_dim"`
	Llmservice   int32            `json:"llmservice"`
	Text         pgtype.Text      `json:"text"`
	Metadata     []byte           `json:"metadata"`
	CreatedAt    pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) UpdateEmbeddings(ctx context.Context, arg UpdateEmbeddingsParams) (int32, error) {
	row := q.db.QueryRow(ctx, updateEmbeddings,
		arg.ID,
		arg.TextID,
		arg.Embedding,
		arg.EmbeddingDim,
		arg.Llmservice,
		arg.Text,
		arg.Metadata,
		arg.CreatedAt,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const updateLLM = `-- name: UpdateLLM :one
UPDATE llmservices
  SET "handle" = $2,
  "description" = $3,
  "endpoint" = $4,
  "api_key" = $5,
  "api_standard" = $6,
  "created_at" = $7,
  "updated_at" = NOW()
WHERE "owner" = $1
  AND "handle" = $2
RETURNING "llmservice_id", "handle", "owner"
`

type UpdateLLMParams struct {
	Owner       string           `json:"owner"`
	Handle      string           `json:"handle"`
	Description pgtype.Text      `json:"description"`
	Endpoint    string           `json:"endpoint"`
	ApiKey      pgtype.Text      `json:"api_key"`
	ApiStandard string           `json:"api_standard"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

type UpdateLLMRow struct {
	LlmserviceID int32  `json:"llmservice_id"`
	Handle       string `json:"handle"`
	Owner        string `json:"owner"`
}

func (q *Queries) UpdateLLM(ctx context.Context, arg UpdateLLMParams) (UpdateLLMRow, error) {
	row := q.db.QueryRow(ctx, updateLLM,
		arg.Owner,
		arg.Handle,
		arg.Description,
		arg.Endpoint,
		arg.ApiKey,
		arg.ApiStandard,
		arg.CreatedAt,
	)
	var i UpdateLLMRow
	err := row.Scan(&i.LlmserviceID, &i.Handle, &i.Owner)
	return i, err
}

const updateProject = `-- name: UpdateProject :one
UPDATE projects
SET "description" = $3,
    "created_at" = $4,
    "updated_at" = NOW()
WHERE "owner" = $1
  AND "handle" = $2
RETURNING "project_id", "handle", "owner"
`

type UpdateProjectParams struct {
	Owner       string           `json:"owner"`
	Handle      string           `json:"handle"`
	Description pgtype.Text      `json:"description"`
	CreatedAt   pgtype.Timestamp `json:"created_at"`
}

type UpdateProjectRow struct {
	ProjectID int32  `json:"project_id"`
	Handle    string `json:"handle"`
	Owner     string `json:"owner"`
}

func (q *Queries) UpdateProject(ctx context.Context, arg UpdateProjectParams) (UpdateProjectRow, error) {
	row := q.db.QueryRow(ctx, updateProject,
		arg.Owner,
		arg.Handle,
		arg.Description,
		arg.CreatedAt,
	)
	var i UpdateProjectRow
	err := row.Scan(&i.ProjectID, &i.Handle, &i.Owner)
	return i, err
}

const updateUser = `-- name: UpdateUser :one
UPDATE users
  SET "name" = $2,
  "email" = $3,
  "vdb_api_key" = $4,
  "created_at" = $5,
  "updated_at" = NOW()
WHERE "handle" = $1
RETURNING handle, name, email, vdb_api_key, created_at, updated_at
`

type UpdateUserParams struct {
	Handle    string           `json:"handle"`
	Name      pgtype.Text      `json:"name"`
	Email     string           `json:"email"`
	VdbApiKey string           `json:"vdb_api_key"`
	CreatedAt pgtype.Timestamp `json:"created_at"`
}

func (q *Queries) UpdateUser(ctx context.Context, arg UpdateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, updateUser,
		arg.Handle,
		arg.Name,
		arg.Email,
		arg.VdbApiKey,
		arg.CreatedAt,
	)
	var i User
	err := row.Scan(
		&i.Handle,
		&i.Name,
		&i.Email,
		&i.VdbApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const uploadAPI = `-- name: UploadAPI :one
INSERT INTO api_standards (
  "handle", "description", "key_method", "key_field", "vector_size", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, NOW(), NOW()
)
RETURNING "handle"
`

type UploadAPIParams struct {
	Handle      string      `json:"handle"`
	Description pgtype.Text `json:"description"`
	KeyMethod   KeyMethod   `json:"key_method"`
	KeyField    pgtype.Text `json:"key_field"`
	VectorSize  int32       `json:"vector_size"`
}

func (q *Queries) UploadAPI(ctx context.Context, arg UploadAPIParams) (string, error) {
	row := q.db.QueryRow(ctx, uploadAPI,
		arg.Handle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
		arg.VectorSize,
	)
	var handle string
	err := row.Scan(&handle)
	return handle, err
}

const uploadEmbeddings = `-- name: UploadEmbeddings :one
INSERT INTO embeddings (
  "text_id", "embedding", "embedding_dim", "llmservice", "text", "metadata", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
RETURNING "id"
`

type UploadEmbeddingsParams struct {
	TextID       pgtype.Text `json:"text_id"`
	Embedding    interface{} `json:"embedding"`
	EmbeddingDim int32       `json:"embedding_dim"`
	Llmservice   int32       `json:"llmservice"`
	Text         pgtype.Text `json:"text"`
	Metadata     []byte      `json:"metadata"`
}

func (q *Queries) UploadEmbeddings(ctx context.Context, arg UploadEmbeddingsParams) (int32, error) {
	row := q.db.QueryRow(ctx, uploadEmbeddings,
		arg.TextID,
		arg.Embedding,
		arg.EmbeddingDim,
		arg.Llmservice,
		arg.Text,
		arg.Metadata,
	)
	var id int32
	err := row.Scan(&id)
	return id, err
}

const uploadLLM = `-- name: UploadLLM :exec
INSERT INTO llmservices (
  "llmservice_id", "handle", "owner", "description", "endpoint", "api_key", "api_standard", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, NOW(), NOW()
)
RETURNING "llmservice_id", "handle", "owner"
`

type UploadLLMParams struct {
	LlmserviceID int32       `json:"llmservice_id"`
	Handle       string      `json:"handle"`
	Owner        string      `json:"owner"`
	Description  pgtype.Text `json:"description"`
	Endpoint     string      `json:"endpoint"`
	ApiKey       pgtype.Text `json:"api_key"`
	ApiStandard  string      `json:"api_standard"`
}

func (q *Queries) UploadLLM(ctx context.Context, arg UploadLLMParams) error {
	_, err := q.db.Exec(ctx, uploadLLM,
		arg.LlmserviceID,
		arg.Handle,
		arg.Owner,
		arg.Description,
		arg.Endpoint,
		arg.ApiKey,
		arg.ApiStandard,
	)
	return err
}

const uploadProject = `-- name: UploadProject :one
INSERT INTO projects (
  "handle", "owner", "description", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
RETURNING "project_id", "handle", "owner"
`

type UploadProjectParams struct {
	Handle      string      `json:"handle"`
	Owner       string      `json:"owner"`
	Description pgtype.Text `json:"description"`
}

type UploadProjectRow struct {
	ProjectID int32  `json:"project_id"`
	Handle    string `json:"handle"`
	Owner     string `json:"owner"`
}

func (q *Queries) UploadProject(ctx context.Context, arg UploadProjectParams) (UploadProjectRow, error) {
	row := q.db.QueryRow(ctx, uploadProject, arg.Handle, arg.Owner, arg.Description)
	var i UploadProjectRow
	err := row.Scan(&i.ProjectID, &i.Handle, &i.Owner)
	return i, err
}

const uploadUser = `-- name: UploadUser :one
INSERT INTO users (
  "handle", "name", "email", "vdb_api_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
RETURNING handle, name, email, vdb_api_key, created_at, updated_at
`

type UploadUserParams struct {
	Handle    string      `json:"handle"`
	Name      pgtype.Text `json:"name"`
	Email     string      `json:"email"`
	VdbApiKey string      `json:"vdb_api_key"`
}

func (q *Queries) UploadUser(ctx context.Context, arg UploadUserParams) (User, error) {
	row := q.db.QueryRow(ctx, uploadUser,
		arg.Handle,
		arg.Name,
		arg.Email,
		arg.VdbApiKey,
	)
	var i User
	err := row.Scan(
		&i.Handle,
		&i.Name,
		&i.Email,
		&i.VdbApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
