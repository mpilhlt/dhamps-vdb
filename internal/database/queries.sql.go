// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const createLLMInstanceFromDefinition = `-- name: CreateLLMInstanceFromDefinition :one
INSERT
INTO llm_service_instances (
  "owner", "instance_handle", "definition_id", "endpoint", "description", "api_key", "api_key_encrypted", "api_standard", "model", "dimensions", "created_at", "updated_at"
)
SELECT 
  $1 as "owner",
  $2 as "instance_handle", 
  def."definition_id",
  COALESCE($3, def."endpoint") as "endpoint",
  COALESCE($4, def."description") as "description",
  $5 as "api_key",
  $6 as "api_key_encrypted",
  COALESCE($7, def."api_standard") as "api_standard",
  COALESCE($8, def."model") as "model",
  COALESCE($9::INTEGER, def."dimensions") as "dimensions",
  NOW() as "created_at",
  NOW() as "updated_at"
FROM llm_service_definitions def
WHERE def."owner" = $10 AND def."definition_handle" = $11
ON CONFLICT ("owner", "instance_handle") DO UPDATE SET
  "definition_id" = EXCLUDED."definition_id",
  "endpoint" = EXCLUDED."endpoint",
  "description" = EXCLUDED."description",
  "api_key" = EXCLUDED."api_key",
  "api_key_encrypted" = EXCLUDED."api_key_encrypted",
  "api_standard" = EXCLUDED."api_standard",
  "model" = EXCLUDED."model",
  "dimensions" = EXCLUDED."dimensions",
  "updated_at" = NOW()
RETURNING "owner", "instance_handle", "instance_id"
`

type CreateLLMInstanceFromDefinitionParams struct {
	Owner            string      `db:"owner" json:"owner"`
	InstanceHandle   string      `db:"instance_handle" json:"instance_handle"`
	Endpoint         string      `db:"endpoint" json:"endpoint"`
	Description      pgtype.Text `db:"description" json:"description"`
	APIKey           pgtype.Text `db:"api_key" json:"api_key"`
	ApiKeyEncrypted  []byte      `db:"api_key_encrypted" json:"api_key_encrypted"`
	APIStandard      string      `db:"api_standard" json:"api_standard"`
	Model            string      `db:"model" json:"model"`
	Column9          int32       `db:"column_9" json:"column_9"`
	Owner_2          string      `db:"owner_2" json:"owner_2"`
	DefinitionHandle string      `db:"definition_handle" json:"definition_handle"`
}

type CreateLLMInstanceFromDefinitionRow struct {
	Owner          string `db:"owner" json:"owner"`
	InstanceHandle string `db:"instance_handle" json:"instance_handle"`
	InstanceID     int32  `db:"instance_id" json:"instance_id"`
}

// Create an instance based on a definition (copies definition fields, allows user to specify API key)
func (q *Queries) CreateLLMInstanceFromDefinition(ctx context.Context, arg CreateLLMInstanceFromDefinitionParams) (CreateLLMInstanceFromDefinitionRow, error) {
	row := q.db.QueryRow(ctx, createLLMInstanceFromDefinition,
		arg.Owner,
		arg.InstanceHandle,
		arg.Endpoint,
		arg.Description,
		arg.APIKey,
		arg.ApiKeyEncrypted,
		arg.APIStandard,
		arg.Model,
		arg.Column9,
		arg.Owner_2,
		arg.DefinitionHandle,
	)
	var i CreateLLMInstanceFromDefinitionRow
	err := row.Scan(&i.Owner, &i.InstanceHandle, &i.InstanceID)
	return i, err
}

const deleteAPIStandard = `-- name: DeleteAPIStandard :exec
DELETE
FROM api_standards
WHERE "api_standard_handle" = $1
`

func (q *Queries) DeleteAPIStandard(ctx context.Context, apiStandardHandle string) error {
	_, err := q.db.Exec(ctx, deleteAPIStandard, apiStandardHandle)
	return err
}

const deleteAllRecords = `-- name: DeleteAllRecords :exec
DO $$
DECLARE
    r RECORD;
BEGIN
    FOR r IN
        SELECT table_name 
        FROM information_schema.tables 
        WHERE table_schema = 'public'
          AND table_name NOT IN ('key_methods', 'vdb_roles')
    LOOP
        EXECUTE format('DELETE FROM %I;', r.table_name);
    END LOOP;
END $$
`

func (q *Queries) DeleteAllRecords(ctx context.Context) error {
	_, err := q.db.Exec(ctx, deleteAllRecords)
	return err
}

const deleteDocEmbeddings = `-- name: DeleteDocEmbeddings :exec
DELETE FROM embeddings e
USING projects p
WHERE e."owner" = $1
  AND e."project_id" = p."project_id"
  AND p."project_handle" = $2
  AND e."text_id" = $3
`

type DeleteDocEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

func (q *Queries) DeleteDocEmbeddings(ctx context.Context, arg DeleteDocEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, deleteDocEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	return err
}

const deleteEmbeddingsByID = `-- name: DeleteEmbeddingsByID :exec
DELETE
FROM embeddings
WHERE "embeddings_id" = $1
`

func (q *Queries) DeleteEmbeddingsByID(ctx context.Context, embeddingsID int32) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByID, embeddingsID)
	return err
}

const deleteEmbeddingsByProject = `-- name: DeleteEmbeddingsByProject :exec
DELETE
FROM embeddings
USING embeddings AS e
JOIN projects AS p
ON e."project_id" = p."project_id"
WHERE embeddings."owner" = $1
AND embeddings."project_id" = e."project_id"
AND p."project_handle" = $2
`

type DeleteEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteEmbeddingsByProject(ctx context.Context, arg DeleteEmbeddingsByProjectParams) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteLLMDefinition = `-- name: DeleteLLMDefinition :exec
DELETE
FROM llm_service_definitions
WHERE "owner" = $1
AND "definition_handle" = $2
`

type DeleteLLMDefinitionParams struct {
	Owner            string `db:"owner" json:"owner"`
	DefinitionHandle string `db:"definition_handle" json:"definition_handle"`
}

func (q *Queries) DeleteLLMDefinition(ctx context.Context, arg DeleteLLMDefinitionParams) error {
	_, err := q.db.Exec(ctx, deleteLLMDefinition, arg.Owner, arg.DefinitionHandle)
	return err
}

const deleteLLMInstance = `-- name: DeleteLLMInstance :exec
DELETE
FROM llm_service_instances
WHERE "owner" = $1
AND "instance_handle" = $2
`

type DeleteLLMInstanceParams struct {
	Owner          string `db:"owner" json:"owner"`
	InstanceHandle string `db:"instance_handle" json:"instance_handle"`
}

func (q *Queries) DeleteLLMInstance(ctx context.Context, arg DeleteLLMInstanceParams) error {
	_, err := q.db.Exec(ctx, deleteLLMInstance, arg.Owner, arg.InstanceHandle)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
`

type DeleteProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE "user_handle" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userHandle string) error {
	_, err := q.db.Exec(ctx, deleteUser, userHandle)
	return err
}

const getAPIStandards = `-- name: GetAPIStandards :many
SELECT api_standard_handle, description, key_method, key_field, created_at, updated_at
FROM api_standards
ORDER BY "api_standard_handle" ASC LIMIT $1 OFFSET $2
`

type GetAPIStandardsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAPIStandards(ctx context.Context, arg GetAPIStandardsParams) ([]APIStandard, error) {
	rows, err := q.db.Query(ctx, getAPIStandards, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []APIStandard
	for rows.Next() {
		var i APIStandard
		if err := rows.Scan(
			&i.APIStandardHandle,
			&i.Description,
			&i.KeyMethod,
			&i.KeyField,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllAccessibleLLMInstances = `-- name: GetAllAccessibleLLMInstances :many
SELECT 
  llm_service_instances.instance_id, llm_service_instances.instance_handle, llm_service_instances.owner, llm_service_instances.endpoint, llm_service_instances.description, llm_service_instances.api_key, llm_service_instances.api_standard, llm_service_instances.model, llm_service_instances.dimensions, llm_service_instances.created_at, llm_service_instances.updated_at, llm_service_instances.definition_id, llm_service_instances.api_key_encrypted,
  CASE 
    WHEN llm_service_instances."owner" = $1 THEN 'owner'
    ELSE llm_service_instances_shared_with."role"
  END as "role",
  llm_service_instances."owner" = $1 as "is_owner"
FROM llm_service_instances
LEFT JOIN llm_service_instances_shared_with
  ON llm_service_instances."instance_id" = llm_service_instances_shared_with."instance_id"
WHERE llm_service_instances."owner" = $1
   OR llm_service_instances_shared_with."user_handle" = $1
ORDER BY llm_service_instances."owner" ASC, llm_service_instances."instance_handle" ASC 
LIMIT $2 OFFSET $3
`

type GetAllAccessibleLLMInstancesParams struct {
	Owner  string `db:"owner" json:"owner"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type GetAllAccessibleLLMInstancesRow struct {
	InstanceID      int32            `db:"instance_id" json:"instance_id"`
	InstanceHandle  string           `db:"instance_handle" json:"instance_handle"`
	Owner           string           `db:"owner" json:"owner"`
	Endpoint        string           `db:"endpoint" json:"endpoint"`
	Description     pgtype.Text      `db:"description" json:"description"`
	APIKey          pgtype.Text      `db:"api_key" json:"api_key"`
	APIStandard     string           `db:"api_standard" json:"api_standard"`
	Model           string           `db:"model" json:"model"`
	Dimensions      int32            `db:"dimensions" json:"dimensions"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DefinitionID    pgtype.Int4      `db:"definition_id" json:"definition_id"`
	ApiKeyEncrypted []byte           `db:"api_key_encrypted" json:"api_key_encrypted"`
	Role            interface{}      `db:"role" json:"role"`
	IsOwner         bool             `db:"is_owner" json:"is_owner"`
}

// Get all instances accessible to a user (owned + shared)
// Returns instances with metadata indicating ownership
func (q *Queries) GetAllAccessibleLLMInstances(ctx context.Context, arg GetAllAccessibleLLMInstancesParams) ([]GetAllAccessibleLLMInstancesRow, error) {
	rows, err := q.db.Query(ctx, getAllAccessibleLLMInstances, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllAccessibleLLMInstancesRow
	for rows.Next() {
		var i GetAllAccessibleLLMInstancesRow
		if err := rows.Scan(
			&i.InstanceID,
			&i.InstanceHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIKey,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefinitionID,
			&i.ApiKeyEncrypted,
			&i.Role,
			&i.IsOwner,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllLLMDefinitions = `-- name: GetAllLLMDefinitions :many
SELECT definition_id, definition_handle, owner, endpoint, description, api_standard, model, dimensions, created_at, updated_at
FROM llm_service_definitions
ORDER BY "owner" ASC, "definition_handle" ASC LIMIT $1 OFFSET $2
`

type GetAllLLMDefinitionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAllLLMDefinitions(ctx context.Context, arg GetAllLLMDefinitionsParams) ([]LlmServiceDefinition, error) {
	rows, err := q.db.Query(ctx, getAllLLMDefinitions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmServiceDefinition
	for rows.Next() {
		var i LlmServiceDefinition
		if err := rows.Scan(
			&i.DefinitionID,
			&i.DefinitionHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllProjects = `-- name: GetAllProjects :many
SELECT project_id, project_handle, owner, description, metadata_scheme, created_at, updated_at, public_read, llm_service_instance_id
FROM projects
ORDER BY "owner" ASC, "project_handle" ASC
`

func (q *Queries) GetAllProjects(ctx context.Context) ([]Project, error) {
	rows, err := q.db.Query(ctx, getAllProjects)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Project
	for rows.Next() {
		var i Project
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectHandle,
			&i.Owner,
			&i.Description,
			&i.MetadataScheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicRead,
			&i.LlmServiceInstanceID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmbeddingsByProject = `-- name: GetEmbeddingsByProject :many
SELECT embeddings.embeddings_id, embeddings.text_id, embeddings.owner, embeddings.project_id, embeddings.llm_service_instance_id, embeddings.text, embeddings.vector, embeddings.vector_dim, embeddings.metadata, embeddings.created_at, embeddings.updated_at, projects."project_handle", llm_service_instances."instance_handle"
FROM embeddings
JOIN llm_service_instances
ON llm_service_instances."instance_id" = embeddings."llm_service_instance_id"
JOIN projects
ON projects."project_id" = embeddings."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
ORDER BY embeddings."text_id" ASC LIMIT $3 OFFSET $4
`

type GetEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetEmbeddingsByProjectRow struct {
	EmbeddingsID         int32                  `db:"embeddings_id" json:"embeddings_id"`
	TextID               pgtype.Text            `db:"text_id" json:"text_id"`
	Owner                string                 `db:"owner" json:"owner"`
	ProjectID            int32                  `db:"project_id" json:"project_id"`
	LlmServiceInstanceID int32                  `db:"llm_service_instance_id" json:"llm_service_instance_id"`
	Text                 pgtype.Text            `db:"text" json:"text"`
	Vector               pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim            int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata             []byte                 `db:"metadata" json:"metadata"`
	CreatedAt            pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle        string                 `db:"project_handle" json:"project_handle"`
	InstanceHandle       string                 `db:"instance_handle" json:"instance_handle"`
}

func (q *Queries) GetEmbeddingsByProject(ctx context.Context, arg GetEmbeddingsByProjectParams) ([]GetEmbeddingsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getEmbeddingsByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmbeddingsByProjectRow
	for rows.Next() {
		var i GetEmbeddingsByProjectRow
		if err := rows.Scan(
			&i.EmbeddingsID,
			&i.TextID,
			&i.Owner,
			&i.ProjectID,
			&i.LlmServiceInstanceID,
			&i.Text,
			&i.Vector,
			&i.VectorDim,
			&i.Metadata,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectHandle,
			&i.InstanceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeyByUser = `-- name: GetKeyByUser :one
SELECT "vdb_api_key"
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

// SELECT encode("vdb_api_key", 'hex') AS "vdb_api_key" FROM users
func (q *Queries) GetKeyByUser(ctx context.Context, userHandle string) (string, error) {
	row := q.db.QueryRow(ctx, getKeyByUser, userHandle)
	var vdb_api_key string
	err := row.Scan(&vdb_api_key)
	return vdb_api_key, err
}

const getKeysByLinkedUsers = `-- name: GetKeysByLinkedUsers :many
SELECT users."user_handle", users_projects."role", users."vdb_api_key"
FROM users
JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects
ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1
AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetKeysByLinkedUsersParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetKeysByLinkedUsersRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
	VdbAPIKey  string `db:"vdb_api_key" json:"vdb_api_key"`
}

// SELECT users."user_handle", users_projects."role", encode(users."vdb_api_key", 'hex') AS "vdb_api_key"
func (q *Queries) GetKeysByLinkedUsers(ctx context.Context, arg GetKeysByLinkedUsersParams) ([]GetKeysByLinkedUsersRow, error) {
	rows, err := q.db.Query(ctx, getKeysByLinkedUsers,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeysByLinkedUsersRow
	for rows.Next() {
		var i GetKeysByLinkedUsersRow
		if err := rows.Scan(&i.UserHandle, &i.Role, &i.VdbAPIKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMDefinitionsByUser = `-- name: GetLLMDefinitionsByUser :many
SELECT definition_id, definition_handle, owner, endpoint, description, api_standard, model, dimensions, created_at, updated_at
FROM llm_service_definitions
WHERE "owner" = $1
ORDER BY "definition_handle" ASC LIMIT $2 OFFSET $3
`

type GetLLMDefinitionsByUserParams struct {
	Owner  string `db:"owner" json:"owner"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMDefinitionsByUser(ctx context.Context, arg GetLLMDefinitionsByUserParams) ([]LlmServiceDefinition, error) {
	rows, err := q.db.Query(ctx, getLLMDefinitionsByUser, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmServiceDefinition
	for rows.Next() {
		var i LlmServiceDefinition
		if err := rows.Scan(
			&i.DefinitionID,
			&i.DefinitionHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMInstanceByProject = `-- name: GetLLMInstanceByProject :one
SELECT llm_service_instances.instance_id, llm_service_instances.instance_handle, llm_service_instances.owner, llm_service_instances.endpoint, llm_service_instances.description, llm_service_instances.api_key, llm_service_instances.api_standard, llm_service_instances.model, llm_service_instances.dimensions, llm_service_instances.created_at, llm_service_instances.updated_at, llm_service_instances.definition_id, llm_service_instances.api_key_encrypted
FROM llm_service_instances
JOIN projects
ON projects."llm_service_instance_id" = llm_service_instances."instance_id"
WHERE projects."owner" = $1
  AND projects."project_handle" = $2
LIMIT 1
`

type GetLLMInstanceByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) GetLLMInstanceByProject(ctx context.Context, arg GetLLMInstanceByProjectParams) (LlmServiceInstance, error) {
	row := q.db.QueryRow(ctx, getLLMInstanceByProject, arg.Owner, arg.ProjectHandle)
	var i LlmServiceInstance
	err := row.Scan(
		&i.InstanceID,
		&i.InstanceHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIKey,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionID,
		&i.ApiKeyEncrypted,
	)
	return i, err
}

const getLLMInstancesByUser = `-- name: GetLLMInstancesByUser :many
SELECT llm_service_instances.instance_id, llm_service_instances.instance_handle, llm_service_instances.owner, llm_service_instances.endpoint, llm_service_instances.description, llm_service_instances.api_key, llm_service_instances.api_standard, llm_service_instances.model, llm_service_instances.dimensions, llm_service_instances.created_at, llm_service_instances.updated_at, llm_service_instances.definition_id, llm_service_instances.api_key_encrypted, 'owner' as "role"
FROM llm_service_instances
WHERE llm_service_instances."owner" = $1
ORDER BY llm_service_instances."instance_handle" ASC LIMIT $2 OFFSET $3
`

type GetLLMInstancesByUserParams struct {
	Owner  string `db:"owner" json:"owner"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type GetLLMInstancesByUserRow struct {
	InstanceID      int32            `db:"instance_id" json:"instance_id"`
	InstanceHandle  string           `db:"instance_handle" json:"instance_handle"`
	Owner           string           `db:"owner" json:"owner"`
	Endpoint        string           `db:"endpoint" json:"endpoint"`
	Description     pgtype.Text      `db:"description" json:"description"`
	APIKey          pgtype.Text      `db:"api_key" json:"api_key"`
	APIStandard     string           `db:"api_standard" json:"api_standard"`
	Model           string           `db:"model" json:"model"`
	Dimensions      int32            `db:"dimensions" json:"dimensions"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DefinitionID    pgtype.Int4      `db:"definition_id" json:"definition_id"`
	ApiKeyEncrypted []byte           `db:"api_key_encrypted" json:"api_key_encrypted"`
	Role            string           `db:"role" json:"role"`
}

// Get all instances owned by a user
func (q *Queries) GetLLMInstancesByUser(ctx context.Context, arg GetLLMInstancesByUserParams) ([]GetLLMInstancesByUserRow, error) {
	rows, err := q.db.Query(ctx, getLLMInstancesByUser, arg.Owner, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLLMInstancesByUserRow
	for rows.Next() {
		var i GetLLMInstancesByUserRow
		if err := rows.Scan(
			&i.InstanceID,
			&i.InstanceHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIKey,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefinitionID,
			&i.ApiKeyEncrypted,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getNumberOfEmbeddingsByProject = `-- name: GetNumberOfEmbeddingsByProject :one
SELECT COUNT(*)
FROM embeddings
JOIN projects
ON embeddings."project_id" = projects."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
`

type GetNumberOfEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) GetNumberOfEmbeddingsByProject(ctx context.Context, arg GetNumberOfEmbeddingsByProjectParams) (int64, error) {
	row := q.db.QueryRow(ctx, getNumberOfEmbeddingsByProject, arg.Owner, arg.ProjectHandle)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT projects.project_id, projects.project_handle, projects.owner, projects.description, projects.metadata_scheme, projects.created_at, projects.updated_at, projects.public_read, projects.llm_service_instance_id, users_projects."role"
FROM projects
JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
ORDER BY projects."project_handle" ASC LIMIT $2 OFFSET $3
`

type GetProjectsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetProjectsByUserRow struct {
	ProjectID            int32            `db:"project_id" json:"project_id"`
	ProjectHandle        string           `db:"project_handle" json:"project_handle"`
	Owner                string           `db:"owner" json:"owner"`
	Description          pgtype.Text      `db:"description" json:"description"`
	MetadataScheme       pgtype.Text      `db:"metadata_scheme" json:"metadata_scheme"`
	CreatedAt            pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	PublicRead           pgtype.Bool      `db:"public_read" json:"public_read"`
	LlmServiceInstanceID pgtype.Int4      `db:"llm_service_instance_id" json:"llm_service_instance_id"`
	Role                 string           `db:"role" json:"role"`
}

func (q *Queries) GetProjectsByUser(ctx context.Context, arg GetProjectsByUserParams) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectHandle,
			&i.Owner,
			&i.Description,
			&i.MetadataScheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.PublicRead,
			&i.LlmServiceInstanceID,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedLLMInstances = `-- name: GetSharedLLMInstances :many
SELECT llm_service_instances.instance_id, llm_service_instances.instance_handle, llm_service_instances.owner, llm_service_instances.endpoint, llm_service_instances.description, llm_service_instances.api_key, llm_service_instances.api_standard, llm_service_instances.model, llm_service_instances.dimensions, llm_service_instances.created_at, llm_service_instances.updated_at, llm_service_instances.definition_id, llm_service_instances.api_key_encrypted, llm_service_instances_shared_with."role"
FROM llm_service_instances
JOIN llm_service_instances_shared_with
ON llm_service_instances."instance_id" = llm_service_instances_shared_with."instance_id"
WHERE llm_service_instances_shared_with."user_handle" = $1
ORDER BY llm_service_instances_shared_with."role" ASC, llm_service_instances."owner" ASC, llm_service_instances."instance_handle" ASC 
LIMIT $2 OFFSET $3
`

type GetSharedLLMInstancesParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetSharedLLMInstancesRow struct {
	InstanceID      int32            `db:"instance_id" json:"instance_id"`
	InstanceHandle  string           `db:"instance_handle" json:"instance_handle"`
	Owner           string           `db:"owner" json:"owner"`
	Endpoint        string           `db:"endpoint" json:"endpoint"`
	Description     pgtype.Text      `db:"description" json:"description"`
	APIKey          pgtype.Text      `db:"api_key" json:"api_key"`
	APIStandard     string           `db:"api_standard" json:"api_standard"`
	Model           string           `db:"model" json:"model"`
	Dimensions      int32            `db:"dimensions" json:"dimensions"`
	CreatedAt       pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt       pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	DefinitionID    pgtype.Int4      `db:"definition_id" json:"definition_id"`
	ApiKeyEncrypted []byte           `db:"api_key_encrypted" json:"api_key_encrypted"`
	Role            string           `db:"role" json:"role"`
}

func (q *Queries) GetSharedLLMInstances(ctx context.Context, arg GetSharedLLMInstancesParams) ([]GetSharedLLMInstancesRow, error) {
	rows, err := q.db.Query(ctx, getSharedLLMInstances, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedLLMInstancesRow
	for rows.Next() {
		var i GetSharedLLMInstancesRow
		if err := rows.Scan(
			&i.InstanceID,
			&i.InstanceHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIKey,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DefinitionID,
			&i.ApiKeyEncrypted,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSharedUsersForInstance = `-- name: GetSharedUsersForInstance :many
SELECT "user_handle", "role"
FROM llm_service_instances_shared_with
WHERE "instance_id" = $1
ORDER BY "user_handle" ASC
`

type GetSharedUsersForInstanceRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) GetSharedUsersForInstance(ctx context.Context, instanceID int32) ([]GetSharedUsersForInstanceRow, error) {
	rows, err := q.db.Query(ctx, getSharedUsersForInstance, instanceID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSharedUsersForInstanceRow
	for rows.Next() {
		var i GetSharedUsersForInstanceRow
		if err := rows.Scan(&i.UserHandle, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByID = `-- name: GetSimilarsByID :many
SELECT e2."text_id"
FROM embeddings e1
CROSS JOIN embeddings e2
JOIN projects
ON e1."project_id" = projects."project_id"
WHERE e2."embeddings_id" != e1."embeddings_id"
  AND e1."text_id" = $1
  AND e1."owner" = $2
  AND projects."project_handle" = $3
  AND e1."vector_dim" = e2."vector_dim"
  AND e1."project_id" = e2."project_id"
  AND 1 - (e1.vector <=> e2.vector) >= $4::double precision
ORDER BY e1.vector <=> e2.vector
LIMIT $5 OFFSET $6
`

type GetSimilarsByIDParams struct {
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	Column4       float64     `db:"column_4" json:"column_4"`
	Limit         int32       `db:"limit" json:"limit"`
	Offset        int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetSimilarsByID(ctx context.Context, arg GetSimilarsByIDParams) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getSimilarsByID,
		arg.TextID,
		arg.Owner,
		arg.ProjectHandle,
		arg.Column4,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var text_id pgtype.Text
		if err := rows.Scan(&text_id); err != nil {
			return nil, err
		}
		items = append(items, text_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByIDWithFilter = `-- name: GetSimilarsByIDWithFilter :many
SELECT e2."text_id"
FROM embeddings e1
CROSS JOIN embeddings e2
JOIN projects
ON e1."project_id" = projects."project_id"
WHERE e2."embeddings_id" != e1."embeddings_id"
  AND e1."text_id" = $1
  AND e1."owner" = $2
  AND projects."project_handle" = $3
  AND e1."vector_dim" = e2."vector_dim"
  AND e1."project_id" = e2."project_id"
  AND 1 - (e1.vector <=> e2.vector) >= $4::double precision
  AND (e2."metadata" ->> $5::text IS NULL OR trim(e2."metadata" ->> $5::text) <> trim($6::text))
ORDER BY e1.vector <=> e2.vector
LIMIT $7 OFFSET $8
`

type GetSimilarsByIDWithFilterParams struct {
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	Column4       float64     `db:"column_4" json:"column_4"`
	Column5       string      `db:"column_5" json:"column_5"`
	Column6       string      `db:"column_6" json:"column_6"`
	Limit         int32       `db:"limit" json:"limit"`
	Offset        int32       `db:"offset" json:"offset"`
}

func (q *Queries) GetSimilarsByIDWithFilter(ctx context.Context, arg GetSimilarsByIDWithFilterParams) ([]pgtype.Text, error) {
	rows, err := q.db.Query(ctx, getSimilarsByIDWithFilter,
		arg.TextID,
		arg.Owner,
		arg.ProjectHandle,
		arg.Column4,
		arg.Column5,
		arg.Column6,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []pgtype.Text
	for rows.Next() {
		var text_id pgtype.Text
		if err := rows.Scan(&text_id); err != nil {
			return nil, err
		}
		items = append(items, text_id)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByVector = `-- name: GetSimilarsByVector :many
SELECT embeddings."embeddings_id", embeddings."text_id", llm_service_instances."owner", llm_service_instances."instance_handle"
FROM embeddings
JOIN llm_service_instances
ON embeddings."llm_service_instance_id" = llm_service_instances."instance_id"
ORDER BY "vector" <=> $1
LIMIT $2 OFFSET $3
`

type GetSimilarsByVectorParams struct {
	Vector pgvector_go.HalfVector `db:"vector" json:"vector"`
	Limit  int32                  `db:"limit" json:"limit"`
	Offset int32                  `db:"offset" json:"offset"`
}

type GetSimilarsByVectorRow struct {
	EmbeddingsID   int32       `db:"embeddings_id" json:"embeddings_id"`
	TextID         pgtype.Text `db:"text_id" json:"text_id"`
	Owner          string      `db:"owner" json:"owner"`
	InstanceHandle string      `db:"instance_handle" json:"instance_handle"`
}

func (q *Queries) GetSimilarsByVector(ctx context.Context, arg GetSimilarsByVectorParams) ([]GetSimilarsByVectorRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByVector, arg.Vector, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByVectorRow
	for rows.Next() {
		var i GetSimilarsByVectorRow
		if err := rows.Scan(
			&i.EmbeddingsID,
			&i.TextID,
			&i.Owner,
			&i.InstanceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSystemLLMDefinitions = `-- name: GetSystemLLMDefinitions :many
SELECT definition_id, definition_handle, owner, endpoint, description, api_standard, model, dimensions, created_at, updated_at
FROM llm_service_definitions
WHERE "owner" = '_system'
ORDER BY "definition_handle" ASC LIMIT $1 OFFSET $2
`

type GetSystemLLMDefinitionsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetSystemLLMDefinitions(ctx context.Context, arg GetSystemLLMDefinitionsParams) ([]LlmServiceDefinition, error) {
	rows, err := q.db.Query(ctx, getSystemLLMDefinitions, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LlmServiceDefinition
	for rows.Next() {
		var i LlmServiceDefinition
		if err := rows.Scan(
			&i.DefinitionID,
			&i.DefinitionHandle,
			&i.Owner,
			&i.Endpoint,
			&i.Description,
			&i.APIStandard,
			&i.Model,
			&i.Dimensions,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT "user_handle"
FROM users
ORDER BY "user_handle" ASC LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_handle string
		if err := rows.Scan(&user_handle); err != nil {
			return nil, err
		}
		items = append(items, user_handle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByProject = `-- name: GetUsersByProject :many
SELECT users."user_handle", users_projects."role"
FROM users JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1 AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetUsersByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetUsersByProjectRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) GetUsersByProject(ctx context.Context, arg GetUsersByProjectParams) ([]GetUsersByProjectRow, error) {
	rows, err := q.db.Query(ctx, getUsersByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByProjectRow
	for rows.Next() {
		var i GetUsersByProjectRow
		if err := rows.Scan(&i.UserHandle, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const isProjectPubliclyReadable = `-- name: IsProjectPubliclyReadable :one
SELECT "public_read"
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
LIMIT 1
`

type IsProjectPubliclyReadableParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) IsProjectPubliclyReadable(ctx context.Context, arg IsProjectPubliclyReadableParams) (pgtype.Bool, error) {
	row := q.db.QueryRow(ctx, isProjectPubliclyReadable, arg.Owner, arg.ProjectHandle)
	var public_read pgtype.Bool
	err := row.Scan(&public_read)
	return public_read, err
}

const linkProjectToUser = `-- name: LinkProjectToUser :one
INSERT
INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "project_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, project_id, role, created_at, updated_at
`

type LinkProjectToUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	ProjectID  int32  `db:"project_id" json:"project_id"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) LinkProjectToUser(ctx context.Context, arg LinkProjectToUserParams) (UsersProject, error) {
	row := q.db.QueryRow(ctx, linkProjectToUser, arg.UserHandle, arg.ProjectID, arg.Role)
	var i UsersProject
	err := row.Scan(
		&i.UserHandle,
		&i.ProjectID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const resetAllSerials = `-- name: ResetAllSerials :exec
DO $$
DECLARE
    seq_name text;
BEGIN
    FOR seq_name IN
      SELECT sequence_name
      FROM information_schema.sequences
      WHERE sequence_schema = 'public' AND sequence_name LIKE '%_seq'
    LOOP
        EXECUTE format('ALTER SEQUENCE public.%I RESTART WITH 1', seq_name);
    END LOOP;
END $$
`

func (q *Queries) ResetAllSerials(ctx context.Context) error {
	_, err := q.db.Exec(ctx, resetAllSerials)
	return err
}

const retrieveAPIStandard = `-- name: RetrieveAPIStandard :one
SELECT api_standard_handle, description, key_method, key_field, created_at, updated_at
FROM api_standards
WHERE "api_standard_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveAPIStandard(ctx context.Context, apiStandardHandle string) (APIStandard, error) {
	row := q.db.QueryRow(ctx, retrieveAPIStandard, apiStandardHandle)
	var i APIStandard
	err := row.Scan(
		&i.APIStandardHandle,
		&i.Description,
		&i.KeyMethod,
		&i.KeyField,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveEmbeddings = `-- name: RetrieveEmbeddings :one
SELECT embeddings.embeddings_id, embeddings.text_id, embeddings.owner, embeddings.project_id, embeddings.llm_service_instance_id, embeddings.text, embeddings.vector, embeddings.vector_dim, embeddings.metadata, embeddings.created_at, embeddings.updated_at, projects."project_handle", llm_service_instances."instance_handle"
FROM embeddings
JOIN llm_service_instances
ON embeddings."llm_service_instance_id" = llm_service_instances."instance_id"
JOIN projects
ON embeddings."project_id" = projects."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
AND embeddings."text_id" = $3
LIMIT 1
`

type RetrieveEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

type RetrieveEmbeddingsRow struct {
	EmbeddingsID         int32                  `db:"embeddings_id" json:"embeddings_id"`
	TextID               pgtype.Text            `db:"text_id" json:"text_id"`
	Owner                string                 `db:"owner" json:"owner"`
	ProjectID            int32                  `db:"project_id" json:"project_id"`
	LlmServiceInstanceID int32                  `db:"llm_service_instance_id" json:"llm_service_instance_id"`
	Text                 pgtype.Text            `db:"text" json:"text"`
	Vector               pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim            int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata             []byte                 `db:"metadata" json:"metadata"`
	CreatedAt            pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt            pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle        string                 `db:"project_handle" json:"project_handle"`
	InstanceHandle       string                 `db:"instance_handle" json:"instance_handle"`
}

func (q *Queries) RetrieveEmbeddings(ctx context.Context, arg RetrieveEmbeddingsParams) (RetrieveEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, retrieveEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	var i RetrieveEmbeddingsRow
	err := row.Scan(
		&i.EmbeddingsID,
		&i.TextID,
		&i.Owner,
		&i.ProjectID,
		&i.LlmServiceInstanceID,
		&i.Text,
		&i.Vector,
		&i.VectorDim,
		&i.Metadata,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectHandle,
		&i.InstanceHandle,
	)
	return i, err
}

const retrieveLLMDefinition = `-- name: RetrieveLLMDefinition :one
SELECT definition_id, definition_handle, owner, endpoint, description, api_standard, model, dimensions, created_at, updated_at
FROM llm_service_definitions
WHERE "owner" = $1
AND "definition_handle" = $2
LIMIT 1
`

type RetrieveLLMDefinitionParams struct {
	Owner            string `db:"owner" json:"owner"`
	DefinitionHandle string `db:"definition_handle" json:"definition_handle"`
}

func (q *Queries) RetrieveLLMDefinition(ctx context.Context, arg RetrieveLLMDefinitionParams) (LlmServiceDefinition, error) {
	row := q.db.QueryRow(ctx, retrieveLLMDefinition, arg.Owner, arg.DefinitionHandle)
	var i LlmServiceDefinition
	err := row.Scan(
		&i.DefinitionID,
		&i.DefinitionHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveLLMInstance = `-- name: RetrieveLLMInstance :one
SELECT instance_id, instance_handle, owner, endpoint, description, api_key, api_standard, model, dimensions, created_at, updated_at, definition_id, api_key_encrypted
FROM llm_service_instances
WHERE "owner" = $1
AND "instance_handle" = $2
LIMIT 1
`

type RetrieveLLMInstanceParams struct {
	Owner          string `db:"owner" json:"owner"`
	InstanceHandle string `db:"instance_handle" json:"instance_handle"`
}

func (q *Queries) RetrieveLLMInstance(ctx context.Context, arg RetrieveLLMInstanceParams) (LlmServiceInstance, error) {
	row := q.db.QueryRow(ctx, retrieveLLMInstance, arg.Owner, arg.InstanceHandle)
	var i LlmServiceInstance
	err := row.Scan(
		&i.InstanceID,
		&i.InstanceHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIKey,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionID,
		&i.ApiKeyEncrypted,
	)
	return i, err
}

const retrieveLLMInstanceByID = `-- name: RetrieveLLMInstanceByID :one
SELECT instance_id, instance_handle, owner, endpoint, description, api_key, api_standard, model, dimensions, created_at, updated_at, definition_id, api_key_encrypted
FROM llm_service_instances
WHERE "instance_id" = $1
LIMIT 1
`

func (q *Queries) RetrieveLLMInstanceByID(ctx context.Context, instanceID int32) (LlmServiceInstance, error) {
	row := q.db.QueryRow(ctx, retrieveLLMInstanceByID, instanceID)
	var i LlmServiceInstance
	err := row.Scan(
		&i.InstanceID,
		&i.InstanceHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIKey,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionID,
		&i.ApiKeyEncrypted,
	)
	return i, err
}

const retrieveLLMInstanceByOwnerHandle = `-- name: RetrieveLLMInstanceByOwnerHandle :one
SELECT instance_id, instance_handle, owner, endpoint, description, api_key, api_standard, model, dimensions, created_at, updated_at, definition_id, api_key_encrypted
FROM llm_service_instances
WHERE ("owner" = $1 AND "instance_handle" = $2)
LIMIT 1
`

type RetrieveLLMInstanceByOwnerHandleParams struct {
	Owner          string `db:"owner" json:"owner"`
	InstanceHandle string `db:"instance_handle" json:"instance_handle"`
}

// Get instance by owner/handle format for shared instances
func (q *Queries) RetrieveLLMInstanceByOwnerHandle(ctx context.Context, arg RetrieveLLMInstanceByOwnerHandleParams) (LlmServiceInstance, error) {
	row := q.db.QueryRow(ctx, retrieveLLMInstanceByOwnerHandle, arg.Owner, arg.InstanceHandle)
	var i LlmServiceInstance
	err := row.Scan(
		&i.InstanceID,
		&i.InstanceHandle,
		&i.Owner,
		&i.Endpoint,
		&i.Description,
		&i.APIKey,
		&i.APIStandard,
		&i.Model,
		&i.Dimensions,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DefinitionID,
		&i.ApiKeyEncrypted,
	)
	return i, err
}

const retrieveProject = `-- name: RetrieveProject :one
SELECT project_id, project_handle, owner, description, metadata_scheme, created_at, updated_at, public_read, llm_service_instance_id
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
LIMIT 1
`

type RetrieveProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) RetrieveProject(ctx context.Context, arg RetrieveProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, retrieveProject, arg.Owner, arg.ProjectHandle)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ProjectHandle,
		&i.Owner,
		&i.Description,
		&i.MetadataScheme,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.PublicRead,
		&i.LlmServiceInstanceID,
	)
	return i, err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT user_handle, name, email, vdb_api_key, created_at, updated_at
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveUser(ctx context.Context, userHandle string) (User, error) {
	row := q.db.QueryRow(ctx, retrieveUser, userHandle)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbAPIKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const shareLLMInstance = `-- name: ShareLLMInstance :exec
INSERT
INTO llm_service_instances_shared_with (
  "user_handle", "instance_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "instance_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
`

type ShareLLMInstanceParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	InstanceID int32  `db:"instance_id" json:"instance_id"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) ShareLLMInstance(ctx context.Context, arg ShareLLMInstanceParams) error {
	_, err := q.db.Exec(ctx, shareLLMInstance, arg.UserHandle, arg.InstanceID, arg.Role)
	return err
}

const unshareLLMInstance = `-- name: UnshareLLMInstance :exec
DELETE
FROM llm_service_instances_shared_with
WHERE "user_handle" = $1
AND "instance_id" = $2
`

type UnshareLLMInstanceParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	InstanceID int32  `db:"instance_id" json:"instance_id"`
}

func (q *Queries) UnshareLLMInstance(ctx context.Context, arg UnshareLLMInstanceParams) error {
	_, err := q.db.Exec(ctx, unshareLLMInstance, arg.UserHandle, arg.InstanceID)
	return err
}

const upsertAPIStandard = `-- name: UpsertAPIStandard :one
INSERT
INTO api_standards (
  "api_standard_handle", "description", "key_method", "key_field", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("api_standard_handle") DO UPDATE SET
  "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "updated_at" = NOW()
RETURNING "api_standard_handle"
`

type UpsertAPIStandardParams struct {
	APIStandardHandle string      `db:"api_standard_handle" json:"api_standard_handle"`
	Description       pgtype.Text `db:"description" json:"description"`
	KeyMethod         string      `db:"key_method" json:"key_method"`
	KeyField          pgtype.Text `db:"key_field" json:"key_field"`
}

func (q *Queries) UpsertAPIStandard(ctx context.Context, arg UpsertAPIStandardParams) (string, error) {
	row := q.db.QueryRow(ctx, upsertAPIStandard,
		arg.APIStandardHandle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
	)
	var api_standard_handle string
	err := row.Scan(&api_standard_handle)
	return api_standard_handle, err
}

const upsertEmbeddings = `-- name: UpsertEmbeddings :one
INSERT
INTO embeddings (
  "text_id", "owner", "project_id", "llm_service_instance_id", "text", "vector", "vector_dim", "metadata", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, NOW(), NOW()
)
ON CONFLICT ("text_id", "owner", "project_id", "llm_service_instance_id") DO UPDATE SET
  "text" = $5,
  "vector" = $6,
  "vector_dim" = $7,
  "metadata" = $8,
  "updated_at" = NOW()
RETURNING "embeddings_id", "text_id", "owner", "project_id", "llm_service_instance_id"
`

type UpsertEmbeddingsParams struct {
	TextID               pgtype.Text            `db:"text_id" json:"text_id"`
	Owner                string                 `db:"owner" json:"owner"`
	ProjectID            int32                  `db:"project_id" json:"project_id"`
	LlmServiceInstanceID int32                  `db:"llm_service_instance_id" json:"llm_service_instance_id"`
	Text                 pgtype.Text            `db:"text" json:"text"`
	Vector               pgvector_go.HalfVector `db:"vector" json:"vector"`
	VectorDim            int32                  `db:"vector_dim" json:"vector_dim"`
	Metadata             []byte                 `db:"metadata" json:"metadata"`
}

type UpsertEmbeddingsRow struct {
	EmbeddingsID         int32       `db:"embeddings_id" json:"embeddings_id"`
	TextID               pgtype.Text `db:"text_id" json:"text_id"`
	Owner                string      `db:"owner" json:"owner"`
	ProjectID            int32       `db:"project_id" json:"project_id"`
	LlmServiceInstanceID int32       `db:"llm_service_instance_id" json:"llm_service_instance_id"`
}

func (q *Queries) UpsertEmbeddings(ctx context.Context, arg UpsertEmbeddingsParams) (UpsertEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, upsertEmbeddings,
		arg.TextID,
		arg.Owner,
		arg.ProjectID,
		arg.LlmServiceInstanceID,
		arg.Text,
		arg.Vector,
		arg.VectorDim,
		arg.Metadata,
	)
	var i UpsertEmbeddingsRow
	err := row.Scan(
		&i.EmbeddingsID,
		&i.TextID,
		&i.Owner,
		&i.ProjectID,
		&i.LlmServiceInstanceID,
	)
	return i, err
}

const upsertLLMDefinition = `-- name: UpsertLLMDefinition :one

INSERT
INTO llm_service_definitions (
  "owner", "definition_handle", "endpoint", "description", "api_standard", "model", "dimensions", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, NOW(), NOW()
)
ON CONFLICT ("owner", "definition_handle") DO UPDATE SET
  "endpoint" = $3,
  "description" = $4,
  "api_standard" = $5,
  "model" = $6,
  "dimensions" = $7,
  "updated_at" = NOW()
RETURNING "owner", "definition_handle", "definition_id"
`

type UpsertLLMDefinitionParams struct {
	Owner            string      `db:"owner" json:"owner"`
	DefinitionHandle string      `db:"definition_handle" json:"definition_handle"`
	Endpoint         string      `db:"endpoint" json:"endpoint"`
	Description      pgtype.Text `db:"description" json:"description"`
	APIStandard      string      `db:"api_standard" json:"api_standard"`
	Model            string      `db:"model" json:"model"`
	Dimensions       int32       `db:"dimensions" json:"dimensions"`
}

type UpsertLLMDefinitionRow struct {
	Owner            string `db:"owner" json:"owner"`
	DefinitionHandle string `db:"definition_handle" json:"definition_handle"`
	DefinitionID     int32  `db:"definition_id" json:"definition_id"`
}

// LLM Service Definitions (templates that can be shared)
func (q *Queries) UpsertLLMDefinition(ctx context.Context, arg UpsertLLMDefinitionParams) (UpsertLLMDefinitionRow, error) {
	row := q.db.QueryRow(ctx, upsertLLMDefinition,
		arg.Owner,
		arg.DefinitionHandle,
		arg.Endpoint,
		arg.Description,
		arg.APIStandard,
		arg.Model,
		arg.Dimensions,
	)
	var i UpsertLLMDefinitionRow
	err := row.Scan(&i.Owner, &i.DefinitionHandle, &i.DefinitionID)
	return i, err
}

const upsertLLMInstance = `-- name: UpsertLLMInstance :one

INSERT
INTO llm_service_instances (
  "owner", "instance_handle", "definition_id", "endpoint", "description", "api_key", "api_key_encrypted", "api_standard", "model", "dimensions", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, NOW(), NOW()
)
ON CONFLICT ("owner", "instance_handle") DO UPDATE SET
  "definition_id" = $3,
  "endpoint" = $4,
  "description" = $5,
  "api_key" = $6,
  "api_key_encrypted" = $7,
  "api_standard" = $8,
  "model" = $9,
  "dimensions" = $10,
  "updated_at" = NOW()
RETURNING "owner", "instance_handle", "instance_id"
`

type UpsertLLMInstanceParams struct {
	Owner           string      `db:"owner" json:"owner"`
	InstanceHandle  string      `db:"instance_handle" json:"instance_handle"`
	DefinitionID    pgtype.Int4 `db:"definition_id" json:"definition_id"`
	Endpoint        string      `db:"endpoint" json:"endpoint"`
	Description     pgtype.Text `db:"description" json:"description"`
	APIKey          pgtype.Text `db:"api_key" json:"api_key"`
	ApiKeyEncrypted []byte      `db:"api_key_encrypted" json:"api_key_encrypted"`
	APIStandard     string      `db:"api_standard" json:"api_standard"`
	Model           string      `db:"model" json:"model"`
	Dimensions      int32       `db:"dimensions" json:"dimensions"`
}

type UpsertLLMInstanceRow struct {
	Owner          string `db:"owner" json:"owner"`
	InstanceHandle string `db:"instance_handle" json:"instance_handle"`
	InstanceID     int32  `db:"instance_id" json:"instance_id"`
}

// LLM Service Instances (user-specific instances with optional API keys)
func (q *Queries) UpsertLLMInstance(ctx context.Context, arg UpsertLLMInstanceParams) (UpsertLLMInstanceRow, error) {
	row := q.db.QueryRow(ctx, upsertLLMInstance,
		arg.Owner,
		arg.InstanceHandle,
		arg.DefinitionID,
		arg.Endpoint,
		arg.Description,
		arg.APIKey,
		arg.ApiKeyEncrypted,
		arg.APIStandard,
		arg.Model,
		arg.Dimensions,
	)
	var i UpsertLLMInstanceRow
	err := row.Scan(&i.Owner, &i.InstanceHandle, &i.InstanceID)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
INSERT
INTO projects (
  "project_handle", "owner", "description", "metadata_scheme", "public_read", "llm_service_instance_id", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
ON CONFLICT ("owner", "project_handle") DO UPDATE SET
  "description" = $3,
  "metadata_scheme" = $4,
  "public_read" = $5,
  "llm_service_instance_id" = $6,
  "updated_at" = NOW()
RETURNING "project_id", "owner", "project_handle"
`

type UpsertProjectParams struct {
	ProjectHandle        string      `db:"project_handle" json:"project_handle"`
	Owner                string      `db:"owner" json:"owner"`
	Description          pgtype.Text `db:"description" json:"description"`
	MetadataScheme       pgtype.Text `db:"metadata_scheme" json:"metadata_scheme"`
	PublicRead           pgtype.Bool `db:"public_read" json:"public_read"`
	LlmServiceInstanceID pgtype.Int4 `db:"llm_service_instance_id" json:"llm_service_instance_id"`
}

type UpsertProjectRow struct {
	ProjectID     int32  `db:"project_id" json:"project_id"`
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (UpsertProjectRow, error) {
	row := q.db.QueryRow(ctx, upsertProject,
		arg.ProjectHandle,
		arg.Owner,
		arg.Description,
		arg.MetadataScheme,
		arg.PublicRead,
		arg.LlmServiceInstanceID,
	)
	var i UpsertProjectRow
	err := row.Scan(&i.ProjectID, &i.Owner, &i.ProjectHandle)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT
INTO users (
  "user_handle", "name", "email", "vdb_api_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("user_handle") DO UPDATE SET
  "name" = $2,
  "email" = $3,
  "vdb_api_key" = $4,
  "updated_at" = NOW()
RETURNING user_handle, name, email, vdb_api_key, created_at, updated_at
`

type UpsertUserParams struct {
	UserHandle string      `db:"user_handle" json:"user_handle"`
	Name       pgtype.Text `db:"name" json:"name"`
	Email      string      `db:"email" json:"email"`
	VdbAPIKey  string      `db:"vdb_api_key" json:"vdb_api_key"`
}

// Generate go code with: sqlc generate
//
//	$1, $2, $3, (decode(sqlc.arg(vdb_api_key)::bytea, 'hex')), NOW(), NOW()
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.UserHandle,
		arg.Name,
		arg.Email,
		arg.VdbAPIKey,
	)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbAPIKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
