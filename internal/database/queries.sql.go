// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const deleteAPI = `-- name: DeleteAPI :exec
DELETE
FROM api_standards
WHERE "api_standard_handle" = $1
`

func (q *Queries) DeleteAPI(ctx context.Context, apiStandardHandle string) error {
	_, err := q.db.Exec(ctx, deleteAPI, apiStandardHandle)
	return err
}

const deleteDocEmbeddings = `-- name: DeleteDocEmbeddings :exec

DELETE
FROM embeddings
USING embeddings as e
JOIN projects as p
ON e."project_id" = p."project_id"
WHERE embeddings."owner" = $1
AND embeddings."project_id" = e."project_id"
AND p."project_handle" = $2
AND embeddings."text_id" = $3
`

type DeleteDocEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

// DELETE FROM tv_episodes
// USING tv_episodes AS ed
// LEFT OUTER JOIN data AS nd ON
//
//	ed.file_name = nd.file_name AND
//	ed.path = nd.path
//
// WHERE
//
//	tv_episodes.id = ed.id AND
//	ed.cd_name = 'MediaLibraryDrive' AND nd.cd_name IS NULL;
func (q *Queries) DeleteDocEmbeddings(ctx context.Context, arg DeleteDocEmbeddingsParams) error {
	_, err := q.db.Exec(ctx, deleteDocEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	return err
}

const deleteEmbeddingsByID = `-- name: DeleteEmbeddingsByID :exec
DELETE
FROM embeddings
WHERE "id" = $1
`

func (q *Queries) DeleteEmbeddingsByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByID, id)
	return err
}

const deleteEmbeddingsByProject = `-- name: DeleteEmbeddingsByProject :exec
DELETE
FROM embeddings
USING embeddings AS e
JOIN projects AS p
ON e."project_id" = p."project_id"
WHERE embeddings."owner" = $1
AND embeddings."project_id" = e."project_id"
AND p."project_handle" = $2
`

type DeleteEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteEmbeddingsByProject(ctx context.Context, arg DeleteEmbeddingsByProjectParams) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteLLM = `-- name: DeleteLLM :exec
DELETE
FROM llmservices
WHERE "owner" = $1
AND "llmservice_handle" = $2
`

type DeleteLLMParams struct {
	Owner            string `db:"owner" json:"owner"`
	LLMServiceHandle string `db:"llmservice_handle" json:"llmservice_handle"`
}

func (q *Queries) DeleteLLM(ctx context.Context, arg DeleteLLMParams) error {
	_, err := q.db.Exec(ctx, deleteLLM, arg.Owner, arg.LLMServiceHandle)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
`

type DeleteProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.Owner, arg.ProjectHandle)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE
FROM users
WHERE "user_handle" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, userHandle string) error {
	_, err := q.db.Exec(ctx, deleteUser, userHandle)
	return err
}

const getAPIs = `-- name: GetAPIs :many
SELECT api_standard_handle, description, key_method, key_field, vector_size, created_at, updated_at
FROM api_standards
ORDER BY "api_standard_handle" ASC LIMIT $1 OFFSET $2
`

type GetAPIsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAPIs(ctx context.Context, arg GetAPIsParams) ([]ApiStandard, error) {
	rows, err := q.db.Query(ctx, getAPIs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiStandard
	for rows.Next() {
		var i ApiStandard
		if err := rows.Scan(
			&i.ApiStandardHandle,
			&i.Description,
			&i.KeyMethod,
			&i.KeyField,
			&i.VectorSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmbeddingsByProject = `-- name: GetEmbeddingsByProject :many
SELECT embeddings.id, embeddings.owner, embeddings.project_id, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice_id, embeddings.text, embeddings.created_at, embeddings.updated_at, projects."project_handle", llmservices."llmservice_handle"
FROM embeddings
JOIN llmservices
ON llmservices."llmservice_id" = embeddings."llmservice_id"
JOIN projects
ON projects."project_id" = embeddings."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
ORDER BY embeddings."text_id" ASC LIMIT $3 OFFSET $4
`

type GetEmbeddingsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetEmbeddingsByProjectRow struct {
	ID               int32                  `db:"id" json:"id"`
	Owner            string                 `db:"owner" json:"owner"`
	ProjectID        int32                  `db:"project_id" json:"project_id"`
	TextID           pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding        pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim     int32                  `db:"embedding_dim" json:"embedding_dim"`
	LLMServiceID     int32                  `db:"llmservice_id" json:"llmservice_id"`
	Text             pgtype.Text            `db:"text" json:"text"`
	CreatedAt        pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle    string                 `db:"project_handle" json:"project_handle"`
	LLMServiceHandle string                 `db:"llmservice_handle" json:"llmservice_handle"`
}

func (q *Queries) GetEmbeddingsByProject(ctx context.Context, arg GetEmbeddingsByProjectParams) ([]GetEmbeddingsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getEmbeddingsByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmbeddingsByProjectRow
	for rows.Next() {
		var i GetEmbeddingsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.ProjectID,
			&i.TextID,
			&i.Embedding,
			&i.EmbeddingDim,
			&i.LLMServiceID,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ProjectHandle,
			&i.LLMServiceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getKeyByUser = `-- name: GetKeyByUser :one
SELECT "vdb_api_key"
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

// SELECT encode("vdb_api_key", 'hex') AS "vdb_api_key" FROM users
func (q *Queries) GetKeyByUser(ctx context.Context, userHandle string) (string, error) {
	row := q.db.QueryRow(ctx, getKeyByUser, userHandle)
	var vdb_api_key string
	err := row.Scan(&vdb_api_key)
	return vdb_api_key, err
}

const getKeysByLinkedUsers = `-- name: GetKeysByLinkedUsers :many
SELECT users."user_handle", users_projects."role", users."vdb_api_key"
FROM users
JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects
ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1
AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetKeysByLinkedUsersParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetKeysByLinkedUsersRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
	VdbApiKey  string `db:"vdb_api_key" json:"vdb_api_key"`
}

// SELECT users."user_handle", users_projects."role", encode(users."vdb_api_key", 'hex') AS "vdb_api_key"
func (q *Queries) GetKeysByLinkedUsers(ctx context.Context, arg GetKeysByLinkedUsersParams) ([]GetKeysByLinkedUsersRow, error) {
	rows, err := q.db.Query(ctx, getKeysByLinkedUsers,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetKeysByLinkedUsersRow
	for rows.Next() {
		var i GetKeysByLinkedUsersRow
		if err := rows.Scan(&i.UserHandle, &i.Role, &i.VdbApiKey); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByProject = `-- name: GetLLMsByProject :many
SELECT llmservices.llmservice_id, llmservices.llmservice_handle, llmservices.owner, llmservices.description, llmservices.endpoint, llmservices.api_key, llmservices.api_standard, llmservices.created_at, llmservices.updated_at
FROM llmservices
JOIN (
  projects_llmservices JOIN projects
  ON projects_llmservices."project_id" = projects."project_id"
)
ON llmservices."llmservice_id" = projects_llmservices."llmservice_id"
WHERE projects."owner" = $1
  AND projects."project_handle" = $2
ORDER BY llmservices."llmservice_handle" ASC LIMIT $3 OFFSET $4
`

type GetLLMsByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMsByProject(ctx context.Context, arg GetLLMsByProjectParams) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LLMServiceID,
			&i.LLMServiceHandle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByUser = `-- name: GetLLMsByUser :many
SELECT llmservices.llmservice_id, llmservices.llmservice_handle, llmservices.owner, llmservices.description, llmservices.endpoint, llmservices.api_key, llmservices.api_standard, llmservices.created_at, llmservices.updated_at
FROM llmservices
JOIN (
  projects_llmservices JOIN users_projects
  ON projects_llmservices."project_id" = users_projects."project_id"
)
ON llmservices."llmservice_id" = projects_llmservices."llmservice_id"
WHERE users_projects."user_handle" = $1
ORDER BY llmservices."llmservice_handle" ASC LIMIT $2 OFFSET $3
`

type GetLLMsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMsByUser(ctx context.Context, arg GetLLMsByUserParams) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LLMServiceID,
			&i.LLMServiceHandle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT projects.project_id, projects.project_handle, projects.owner, projects.description, projects.metadata_scheme, projects.created_at, projects.updated_at, users_projects."role"
FROM projects
JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
ORDER BY projects."project_handle" ASC LIMIT $2 OFFSET $3
`

type GetProjectsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetProjectsByUserRow struct {
	ProjectID      int32            `db:"project_id" json:"project_id"`
	ProjectHandle  string           `db:"project_handle" json:"project_handle"`
	Owner          string           `db:"owner" json:"owner"`
	Description    pgtype.Text      `db:"description" json:"description"`
	MetadataScheme pgtype.Text      `db:"metadata_scheme" json:"metadata_scheme"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Role           string           `db:"role" json:"role"`
}

func (q *Queries) GetProjectsByUser(ctx context.Context, arg GetProjectsByUserParams) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.ProjectHandle,
			&i.Owner,
			&i.Description,
			&i.MetadataScheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByID = `-- name: GetSimilarsByID :many
SELECT e2."id", e2."text_id", 1 - (e1.embedding <=> e2.embedding) AS cosine_similarity
FROM embeddings e1
CROSS JOIN embeddings e2
WHERE e1."text_id" = $1
  AND e2."id" != e1."id"
ORDER BY e1.embedding <=> e2.embedding
LIMIT $2 OFFSET $3
`

type GetSimilarsByIDParams struct {
	TextID pgtype.Text `db:"text_id" json:"text_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

type GetSimilarsByIDRow struct {
	ID               int32       `db:"id" json:"id"`
	TextID           pgtype.Text `db:"text_id" json:"text_id"`
	CosineSimilarity int32       `db:"cosine_similarity" json:"cosine_similarity"`
}

func (q *Queries) GetSimilarsByID(ctx context.Context, arg GetSimilarsByIDParams) ([]GetSimilarsByIDRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByID, arg.TextID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByIDRow
	for rows.Next() {
		var i GetSimilarsByIDRow
		if err := rows.Scan(&i.ID, &i.TextID, &i.CosineSimilarity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByVector = `-- name: GetSimilarsByVector :many
SELECT embeddings."id", embeddings."text_id", llmservices."owner", llmservices."llmservice_handle"
FROM embeddings
JOIN llmservices
ON embeddings."llmservice_id" = llmservices."llmservice_id"
ORDER BY "embedding" <=> $1
LIMIT $2 OFFSET $3
`

type GetSimilarsByVectorParams struct {
	Embedding pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	Limit     int32                  `db:"limit" json:"limit"`
	Offset    int32                  `db:"offset" json:"offset"`
}

type GetSimilarsByVectorRow struct {
	ID               int32       `db:"id" json:"id"`
	TextID           pgtype.Text `db:"text_id" json:"text_id"`
	Owner            string      `db:"owner" json:"owner"`
	LLMServiceHandle string      `db:"llmservice_handle" json:"llmservice_handle"`
}

func (q *Queries) GetSimilarsByVector(ctx context.Context, arg GetSimilarsByVectorParams) ([]GetSimilarsByVectorRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByVector, arg.Embedding, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByVectorRow
	for rows.Next() {
		var i GetSimilarsByVectorRow
		if err := rows.Scan(
			&i.ID,
			&i.TextID,
			&i.Owner,
			&i.LLMServiceHandle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT "user_handle"
FROM users
ORDER BY "user_handle" ASC LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var user_handle string
		if err := rows.Scan(&user_handle); err != nil {
			return nil, err
		}
		items = append(items, user_handle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByProject = `-- name: GetUsersByProject :many
SELECT users."user_handle", users_projects."role"
FROM users JOIN users_projects
ON users."user_handle" = users_projects."user_handle"
JOIN projects ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1 AND projects."project_handle" = $2
ORDER BY users."user_handle" ASC LIMIT $3 OFFSET $4
`

type GetUsersByProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
	Limit         int32  `db:"limit" json:"limit"`
	Offset        int32  `db:"offset" json:"offset"`
}

type GetUsersByProjectRow struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) GetUsersByProject(ctx context.Context, arg GetUsersByProjectParams) ([]GetUsersByProjectRow, error) {
	rows, err := q.db.Query(ctx, getUsersByProject,
		arg.Owner,
		arg.ProjectHandle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByProjectRow
	for rows.Next() {
		var i GetUsersByProjectRow
		if err := rows.Scan(&i.UserHandle, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkProjectToLLM = `-- name: LinkProjectToLLM :exec
INSERT
INTO projects_llmservices (
  "project_id", "llmservice_id", "created_at", "updated_at"
) VALUES (
  $1, $2, NOW(), NOW()
)
ON CONFLICT ("project_id", "llmservice_id") DO NOTHING
RETURNING project_id, llmservice_id, created_at, updated_at
`

type LinkProjectToLLMParams struct {
	ProjectID    int32 `db:"project_id" json:"project_id"`
	LLMServiceID int32 `db:"llmservice_id" json:"llmservice_id"`
}

func (q *Queries) LinkProjectToLLM(ctx context.Context, arg LinkProjectToLLMParams) error {
	_, err := q.db.Exec(ctx, linkProjectToLLM, arg.ProjectID, arg.LLMServiceID)
	return err
}

const linkProjectToUser = `-- name: LinkProjectToUser :one
INSERT
INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "project_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, project_id, role, created_at, updated_at
`

type LinkProjectToUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	ProjectID  int32  `db:"project_id" json:"project_id"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) LinkProjectToUser(ctx context.Context, arg LinkProjectToUserParams) (UsersProject, error) {
	row := q.db.QueryRow(ctx, linkProjectToUser, arg.UserHandle, arg.ProjectID, arg.Role)
	var i UsersProject
	err := row.Scan(
		&i.UserHandle,
		&i.ProjectID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkUserToLLM = `-- name: LinkUserToLLM :exec
INSERT
INTO users_llmservices (
  "user_handle", "llmservice_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "llmservice_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, llmservice_id, role, created_at, updated_at
`

type LinkUserToLLMParams struct {
	UserHandle   string `db:"user_handle" json:"user_handle"`
	LLMServiceID int32  `db:"llmservice_id" json:"llmservice_id"`
	Role         string `db:"role" json:"role"`
}

func (q *Queries) LinkUserToLLM(ctx context.Context, arg LinkUserToLLMParams) error {
	_, err := q.db.Exec(ctx, linkUserToLLM, arg.UserHandle, arg.LLMServiceID, arg.Role)
	return err
}

const retrieveAPI = `-- name: RetrieveAPI :one
SELECT api_standard_handle, description, key_method, key_field, vector_size, created_at, updated_at
FROM api_standards
WHERE "api_standard_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveAPI(ctx context.Context, apiStandardHandle string) (ApiStandard, error) {
	row := q.db.QueryRow(ctx, retrieveAPI, apiStandardHandle)
	var i ApiStandard
	err := row.Scan(
		&i.ApiStandardHandle,
		&i.Description,
		&i.KeyMethod,
		&i.KeyField,
		&i.VectorSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveEmbeddings = `-- name: RetrieveEmbeddings :one
SELECT embeddings.id, embeddings.owner, embeddings.project_id, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice_id, embeddings.text, embeddings.created_at, embeddings.updated_at, projects."project_handle", llmservices."llmservice_handle"
FROM embeddings
JOIN llmservices
ON embeddings."llmservice_id" = llmservices."llmservice_id"
JOIN projects
ON embeddings."project_id" = projects."project_id"
WHERE embeddings."owner" = $1
AND projects."project_handle" = $2
AND embeddings."text_id" = $3
LIMIT 1
`

type RetrieveEmbeddingsParams struct {
	Owner         string      `db:"owner" json:"owner"`
	ProjectHandle string      `db:"project_handle" json:"project_handle"`
	TextID        pgtype.Text `db:"text_id" json:"text_id"`
}

type RetrieveEmbeddingsRow struct {
	ID               int32                  `db:"id" json:"id"`
	Owner            string                 `db:"owner" json:"owner"`
	ProjectID        int32                  `db:"project_id" json:"project_id"`
	TextID           pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding        pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim     int32                  `db:"embedding_dim" json:"embedding_dim"`
	LLMServiceID     int32                  `db:"llmservice_id" json:"llmservice_id"`
	Text             pgtype.Text            `db:"text" json:"text"`
	CreatedAt        pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt        pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	ProjectHandle    string                 `db:"project_handle" json:"project_handle"`
	LLMServiceHandle string                 `db:"llmservice_handle" json:"llmservice_handle"`
}

func (q *Queries) RetrieveEmbeddings(ctx context.Context, arg RetrieveEmbeddingsParams) (RetrieveEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, retrieveEmbeddings, arg.Owner, arg.ProjectHandle, arg.TextID)
	var i RetrieveEmbeddingsRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.ProjectID,
		&i.TextID,
		&i.Embedding,
		&i.EmbeddingDim,
		&i.LLMServiceID,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ProjectHandle,
		&i.LLMServiceHandle,
	)
	return i, err
}

const retrieveLLM = `-- name: RetrieveLLM :one
SELECT llmservice_id, llmservice_handle, owner, description, endpoint, api_key, api_standard, created_at, updated_at
FROM llmservices
WHERE "owner" = $1
AND "llmservice_handle" = $2
LIMIT 1
`

type RetrieveLLMParams struct {
	Owner            string `db:"owner" json:"owner"`
	LLMServiceHandle string `db:"llmservice_handle" json:"llmservice_handle"`
}

func (q *Queries) RetrieveLLM(ctx context.Context, arg RetrieveLLMParams) (Llmservice, error) {
	row := q.db.QueryRow(ctx, retrieveLLM, arg.Owner, arg.LLMServiceHandle)
	var i Llmservice
	err := row.Scan(
		&i.LLMServiceID,
		&i.LLMServiceHandle,
		&i.Owner,
		&i.Description,
		&i.Endpoint,
		&i.ApiKey,
		&i.ApiStandard,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveProject = `-- name: RetrieveProject :one
SELECT project_id, project_handle, owner, description, metadata_scheme, created_at, updated_at
FROM projects
WHERE "owner" = $1
AND "project_handle" = $2
LIMIT 1
`

type RetrieveProjectParams struct {
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) RetrieveProject(ctx context.Context, arg RetrieveProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, retrieveProject, arg.Owner, arg.ProjectHandle)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.ProjectHandle,
		&i.Owner,
		&i.Description,
		&i.MetadataScheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT user_handle, name, email, vdb_api_key, created_at, updated_at
FROM users
WHERE "user_handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveUser(ctx context.Context, userHandle string) (User, error) {
	row := q.db.QueryRow(ctx, retrieveUser, userHandle)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAPI = `-- name: UpsertAPI :one
INSERT
INTO api_standards (
  "api_standard_handle", "description", "key_method", "key_field", "vector_size", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, NOW(), NOW()
)
ON CONFLICT ("api_standard_handle") DO UPDATE SET
  "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "vector_size" = $5,
  "updated_at" = NOW()
RETURNING "api_standard_handle"
`

type UpsertAPIParams struct {
	ApiStandardHandle string      `db:"api_standard_handle" json:"api_standard_handle"`
	Description       pgtype.Text `db:"description" json:"description"`
	KeyMethod         string      `db:"key_method" json:"key_method"`
	KeyField          pgtype.Text `db:"key_field" json:"key_field"`
	VectorSize        int32       `db:"vector_size" json:"vector_size"`
}

func (q *Queries) UpsertAPI(ctx context.Context, arg UpsertAPIParams) (string, error) {
	row := q.db.QueryRow(ctx, upsertAPI,
		arg.ApiStandardHandle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
		arg.VectorSize,
	)
	var api_standard_handle string
	err := row.Scan(&api_standard_handle)
	return api_standard_handle, err
}

const upsertEmbeddings = `-- name: UpsertEmbeddings :one
INSERT
INTO embeddings (
  "id", "owner", "project_id", "text_id", "embedding", "embedding_dim", "llmservice_id", "text", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $9, NOW(), NOW()
)
ON CONFLICT ("id") DO UPDATE SET
  "text_id" = $2,
  "owner" = $3,
  "project_id" = $4,
  "embedding" = $5,
  "embedding_dim" = $6,
  "llmservice_id" = $7,
  "text" = $8,
  "updated_at" = NOW()
RETURNING "id", "text_id"
`

type UpsertEmbeddingsParams struct {
	ID           int32                  `db:"id" json:"id"`
	Owner        string                 `db:"owner" json:"owner"`
	ProjectID    int32                  `db:"project_id" json:"project_id"`
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding    pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim int32                  `db:"embedding_dim" json:"embedding_dim"`
	LLMServiceID int32                  `db:"llmservice_id" json:"llmservice_id"`
	Text         pgtype.Text            `db:"text" json:"text"`
	Text_2       pgtype.Text            `db:"text_2" json:"text_2"`
}

type UpsertEmbeddingsRow struct {
	ID     int32       `db:"id" json:"id"`
	TextID pgtype.Text `db:"text_id" json:"text_id"`
}

func (q *Queries) UpsertEmbeddings(ctx context.Context, arg UpsertEmbeddingsParams) (UpsertEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, upsertEmbeddings,
		arg.ID,
		arg.Owner,
		arg.ProjectID,
		arg.TextID,
		arg.Embedding,
		arg.EmbeddingDim,
		arg.LLMServiceID,
		arg.Text,
		arg.Text_2,
	)
	var i UpsertEmbeddingsRow
	err := row.Scan(&i.ID, &i.TextID)
	return i, err
}

const upsertLLM = `-- name: UpsertLLM :one
INSERT
INTO llmservices (
  "llmservice_handle", "owner", "description", "endpoint", "api_key", "api_standard", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
ON CONFLICT ("owner", "llmservice_handle") DO UPDATE SET
  "description" = $3,
  "endpoint" = $4,
  "api_key" = $5,
  "api_standard" = $6,
  "updated_at" = NOW()
RETURNING "llmservice_id", "llmservice_handle", "owner"
`

type UpsertLLMParams struct {
	LLMServiceHandle string      `db:"llmservice_handle" json:"llmservice_handle"`
	Owner            string      `db:"owner" json:"owner"`
	Description      pgtype.Text `db:"description" json:"description"`
	Endpoint         string      `db:"endpoint" json:"endpoint"`
	ApiKey           pgtype.Text `db:"api_key" json:"api_key"`
	ApiStandard      string      `db:"api_standard" json:"api_standard"`
}

type UpsertLLMRow struct {
	LLMServiceID     int32  `db:"llmservice_id" json:"llmservice_id"`
	LLMServiceHandle string `db:"llmservice_handle" json:"llmservice_handle"`
	Owner            string `db:"owner" json:"owner"`
}

func (q *Queries) UpsertLLM(ctx context.Context, arg UpsertLLMParams) (UpsertLLMRow, error) {
	row := q.db.QueryRow(ctx, upsertLLM,
		arg.LLMServiceHandle,
		arg.Owner,
		arg.Description,
		arg.Endpoint,
		arg.ApiKey,
		arg.ApiStandard,
	)
	var i UpsertLLMRow
	err := row.Scan(&i.LLMServiceID, &i.LLMServiceHandle, &i.Owner)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
INSERT
INTO projects (
  "project_handle", "owner", "description", "metadata_scheme", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("owner", "project_handle") DO UPDATE SET
  "description" = $3,
  "metadata_scheme" = $4,
  "updated_at" = NOW()
RETURNING "project_id", "owner", "project_handle"
`

type UpsertProjectParams struct {
	ProjectHandle  string      `db:"project_handle" json:"project_handle"`
	Owner          string      `db:"owner" json:"owner"`
	Description    pgtype.Text `db:"description" json:"description"`
	MetadataScheme pgtype.Text `db:"metadata_scheme" json:"metadata_scheme"`
}

type UpsertProjectRow struct {
	ProjectID     int32  `db:"project_id" json:"project_id"`
	Owner         string `db:"owner" json:"owner"`
	ProjectHandle string `db:"project_handle" json:"project_handle"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (UpsertProjectRow, error) {
	row := q.db.QueryRow(ctx, upsertProject,
		arg.ProjectHandle,
		arg.Owner,
		arg.Description,
		arg.MetadataScheme,
	)
	var i UpsertProjectRow
	err := row.Scan(&i.ProjectID, &i.Owner, &i.ProjectHandle)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT
INTO users (
  "user_handle", "name", "email", "vdb_api_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("user_handle") DO UPDATE SET
  "name" = $2,
  "email" = $3,
  "vdb_api_key" = $4,
  "updated_at" = NOW()
RETURNING user_handle, name, email, vdb_api_key, created_at, updated_at
`

type UpsertUserParams struct {
	UserHandle string      `db:"user_handle" json:"user_handle"`
	Name       pgtype.Text `db:"name" json:"name"`
	Email      string      `db:"email" json:"email"`
	VdbApiKey  string      `db:"vdb_api_key" json:"vdb_api_key"`
}

// Generate go code with: sqlc generate
//
//	$1, $2, $3, (decode(sqlc.arg(vdb_api_key)::bytea, 'hex')), NOW(), NOW()
//	"vdb_api_key" = (decode(sqlc.arg(vdb_api_key)::bytea, 'hex')),
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.UserHandle,
		arg.Name,
		arg.Email,
		arg.VdbApiKey,
	)
	var i User
	err := row.Scan(
		&i.UserHandle,
		&i.Name,
		&i.Email,
		&i.VdbApiKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
