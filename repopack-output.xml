This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-10-29T08:22:58.890Z

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Repository files, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.
</notes>

<additional_info>

For more information about Repopack, visit: https://github.com/yamadashy/repopack
</additional_info>

</file_summary>

<repository_structure>
api/
  openapi.yml
docs/
  ChatGPT.md
internal/
  auth/
    authenticate.go
  database/
    migrations/
      001_create_initial_scheme.sql
      002_create_emb_index.sql
      tern.conf.tpl
    queries/
      queries.sql
    database.go
    db.go
    migrations.go
    models.go
    queries.sql.go
  handlers/
    embeddings_test.go
    embeddings.go
    handlers_test.go
    handlers.go
    llm_process.go
    llm_service.go
    projects_test.go
    projects.go
    similars.go
    users_test.go
    users.go
  models/
    embeddings.go
    llm_process.go
    llm_service.go
    options.go
    project.go
    similar.go
    user.go
testdata/
  postgres/
    enable-vector.sql
    users.yml
  invalid_embeddings.json
  invalid_project.json
  invalid_user.json
  valid_embeddings.json
  valid_project.json
  valid_user.json
.gitignore
.repopackignore
go.mod
go.sum
LICENSE
main.go
README.md
repopack.config.json
sqlc.yaml
template.env
</repository_structure>

<repository_files>
This section contains the contents of the repository's files.

<file path="api/openapi.yml">
# Missing information and assumptions:
#
# - Detailed request and response schemas for each endpoint are needed.
# - Error response codes need to be defined for each operation.
# - Path and query parameters need to be fully specified with types and descriptions.
# - For the llm-process endpoint, the exact nature of "multiple text fields or text-id parameters"
#   needs clarification for accurate schema definition.

openapi: "3.1.0"
info:
  title: "DHaMPS VDB API"
  version: "0.0.1"

servers:
  - url: "https://example.com/"

paths:
  /users:
    put:
      summary: Create or update a user
      operationId: putAdminUsers
      tags:
        - Admin
      security:
        - pasetoAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                email:
                  type: string
                apiKey:
                  type: string
      responses:
        "200":
          description: User created or updated
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                  username:
                    type: string
                  email:
                    type: string
        "401":
          description: Unauthorized
        "400":
          description: Bad Request

    # Repeat this pattern for POST and GET (all users' handles)

  /users/{user}:
    get:
      summary: Get information about a specific user
      operationId: getAdminUser
      tags:
        - Admin
      security:
        - pasetoAuth: []
      parameters:
        - name: user
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: User found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/user"
        "401":
          description: Unauthorized
        "404":
          description: User not found

    patch:
      summary: Update a specific user
      operationId: patchAdminUser
      tags:
        - Admin
      security:
        - pasetoAuth: []
      parameters:
        - name: user
          in: path
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                email:
                  type: string
                apiKey:
                  type: string
      responses:
        "200":
          description: User updated
        "401":
          description: Unauthorized
        "404":
          description: User not found

    # Repeat this pattern for DELETE

  /projects/{user}:
    put:
      summary: Create or update a project
      operationId: putUserProjects
      tags:
        - Projects
      security:
        - pasetoAuth: []
      # Parameters and request body definition goes here
      responses:
        "200":
          description: Project created or updated
        "401":
          description: Unauthorized

    # Repeat this pattern for POST and GET

  /projects/{user}/{project}:
    get:
      summary: Get information about a specific project
      operationId: getUserProject
      tags:
        - Projects
      security:
        - pasetoAuth: []
      parameters:
        - name: user
          in: path
          required: true
          schema:
            type: string
        - name: project
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: Project found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/project"
        "401":
          description: Unauthorized
        "404":
          description: Project not found

    # Repeat this pattern for PATCH and DELETE

  /embeddings/{user}/{project}:
    put:
      summary: Create or update embeddings for a project
      operationId: putProjectEmbeddings
      tags:
        - Embeddings
      security:
        - pasetoAuth: []
      # Define request and response structure
    post:
      summary: Create embeddings for provided text
      operationId: postProjectEmbeddings
      tags:
        - Embeddings
      security:
        - pasetoAuth: []
      # Define request and response structure

    # Repeat this pattern for GET and DELETE (all the project's embeddings)

  /embeddings/{user}/{project}/{id}:
    get:
      summary: Get information about a specific embedding
      operationId: getProjectEmbedding
      tags:
        - Embeddings
      security:
        - pasetoAuth: []
      parameters:
        - name: user
          in: path
          required: true
          schema:
            type: string
        - name: project
          in: path
          required: true
          schema:
            type: string
        - name: id
          in: path
          required: true
          schema:
            type: string
      responses:
        "200":
          description: Embedding found
          content:
            application/json:
              schema:
                $ref: "#/components/schemas/embedding"
        "401":
          description: Unauthorized
        "404":
          description: Embedding not found

    # Repeat this pattern for PATCH and DELETE

  /similars/{user}/{project}:
    post:
      summary: Create similar items for a project
      operationId: postProjectSimilars
      tags:
        - Similars
      security:
        - pasetoAuth: []
      # Define request and response structure

  /similars/{user}/{project}/{id}:
    get:
      summary: Retrieve similar items
      operationId: getProjectSimilars
      tags:
        - Similars
      security:
        - pasetoAuth: []
      parameters:
        - name: count
          in: query
          schema:
            type: integer
        - name: threshold
          in: query
          schema:
            type: number
      # Define response structure

  /llm-process:
    post:
      summary: Process text with LLM service
      operationId: llmProcess
      tags:
        - LLM
      security:
        - pasetoAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                serviceId:
                  type: string
                projectId:
                  type: string
                contextId:
                  type: string
                textFields:
                  type: array
                  items:
                    type: string
      responses:
        "200":
          description: Processed successfully
        "401":
          description: Unauthorized

components:
  securitySchemes:
    pasetoAuth:
      type: http
      scheme: bearer
      bearerFormat: PASETO
  schemas:
    user:
      type: object
      properties:
        handle:
          type: string
          minLength: 3
          maxLength: 20
        name:
          type: string
          minLength: 3
          maxLength: 50
        email:
          type: string
          format: email
        apiKey:
          type: string
          minLength: 32
          maxLength: 32
        projects:
          type: array
          items:
            type: string
            minLength: 3
            maxLength: 50
      required:
        - handle
        - email
        - apiKey
    project:
      type: object
      properties:
        handle:
          type: string
          minLength: 3
          maxLength: 50
        description:
          type: string
          maxLength: 255
        shared_with:
          type: array
          items:
            type: string
            minLength: 3
            maxLength: 20
          uniqueItems: true
          default: ["*"]
        instances:
          type: array
          items:
            type: string
            minLength: 3
            maxLength: 50
      required:
        - handle
    llmService:
      type: object
      properties:
        serviceName:
          type: string
        endpoint:
          type: string
          format: uri
        token:
          type: string
        tokenMethod:
          type: string
          enum:
            - header
            - query
          default: header
        contextData:
          type: string
          maxLength: 255
        systemPrompt:
          type: string
          maxLength: 255
        requestTemplate:
          type: string
        respFieldname:
          type: string
      required:
        - serviceName
        - endpoint
    embedding:
      type: object
      properties:
        id:
          type: string
          minLength: 32
          maxLength: 32
        text:
          type: string
        vector:
          type: array
          items:
            type: number
        metadata:
          type: array
          items:
            type: object
            properties:
              key: string
              value: string
            required: key
      required:
        - id
    similars:
      type: array
      items:
        type: string
</file>

<file path="docs/ChatGPT.md">
# ChatGPT Output

I had ChatGPT (4o) write code implementing an OpenAPI spec developed in dialogue with it.

## OpenAPI spec

```yaml
openapi: 3.0.0
info:
  title: Example API
  version: 1.0.0

servers:
  - url: 'https://example.com/'

paths:
  /admin/users:
    put:
      summary: Create or update a user
      operationId: putAdminUsers
      tags:
        - Admin
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                email:
                  type: string
                apiKey:
                  type: string
      responses:
        '200':
          description: User created or updated
          content:
            application/json:
              schema:
                type: object
                properties:
                  id:
                    type: string
                  username:
                    type: string
                  email:
                    type: string
        '401':
          description: Unauthorized
        '400':
          description: Bad Request

  /admin/users/{user}:
    patch:
      summary: Update a specific user
      operationId: patchAdminUser
      tags:
        - Admin
      security:
        - bearerAuth: []
      parameters:
        - name: user
          in: path
          required: true
          schema:
            type: string
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                email:
                  type: string
                apiKey:
                  type: string
      responses:
        '200':
          description: User updated
        '401':
          description: Unauthorized
        '404':
          description: User not found

    # Repeating this pattern for other methods like GET and DELETE

  /{user}/projects:
    put:
      summary: Create or update a project
      operationId: putUserProjects
      tags:
        - Projects
      security:
        - bearerAuth: []
      # Parameters and request body definition goes here
      responses:
        '200':
          description: Project created or updated
        '401':
          description: Unauthorized

    # Similar for PATCH, GET, DELETE on /{user}/projects/:project

  /{user}/{project}/embeddings:
    put:
      summary: Create or update embeddings for a project
      operationId: putProjectEmbeddings
      tags:
        - Embeddings
      security:
        - bearerAuth: []
      # Define request and response structure
    post:
      summary: Create embeddings for provided text
      operationId: postProjectEmbeddings
      tags:
        - Embeddings
      security:
        - bearerAuth: []
      # Define request and response structure

    # Similar for GET, DELETE on /{user}/{project}/embeddings/:id

  /{user}/{project}/similars/{id}:
    get:
      summary: Retrieve similar items
      operationId: getProjectSimilars
      tags:
        - Similars
      security:
        - bearerAuth: []
      parameters:
        - name: count
          in: query
          schema:
            type: integer
        - name: threshold
          in: query
          schema:
            type: number
      # Define response structure

  /llm-process:
    post:
      summary: Process text with LLM service
      operationId: llmProcess
      tags:
        - LLM
      security:
        - bearerAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                serviceId:
                  type: string
                projectId:
                  type: string
                contextId:
                  type: string
                textFields:
                  type: array
                  items:
                    type: string
      responses:
        '200':
          description: Processed successfully
        '401':
          description: Unauthorized

components:
  securitySchemes:
    bearerAuth:
      type: http
      scheme: bearer
      bearerFormat: JWT
```

> Missing information and assumptions:
>
> - Detailed request and response schemas for each endpoint are needed.
> - Error response codes need to be defined for each operation.
> - Authentication method is assumed to be Bearer Token (JWT), which needs to be confirmed.
> - Path and query parameters need to be fully specified with types and descriptions.
> - For the llm-process endpoint, the exact nature of "multiple text fields or text-id parameters" needs clarification for accurate schema definition.
> This is a basic structure, and you will need to fill in the details based on the actual requirements and data structures of your API.

Then, requesting PASETO tokens:

```yaml
openapi: 3.0.0
info:
  title: Example API
  version: 1.0.0

servers:
  - url: 'https://example.com/'

paths:
  /admin/users:
    put:
      summary: Create or update a user
      operationId: putAdminUsers
      tags:
        - Admin
      security:
        - pasetoAuth: []
      requestBody:
        required: true
        content:
          application/json:
            schema:
              type: object
              properties:
                username:
                  type: string
                email:
                  type: string
                apiKey:
                  type: string
      responses:
        '200':
          description: User created or updated
        '401':
          description: Unauthorized
        # Define other responses as needed

    # Other endpoints definitions go here...

components:
  securitySchemes:
    pasetoAuth:
      type: http
      scheme: bearer
      bearerFormat: PASETO
```

> Please note that while OpenAPI doesn't natively distinguish between JWT and PASETO as they both use Bearer tokens, specifying bearerFormat helps indicate the expected token format. It's also important to document this in the API documentation so that consumers know that the API uses PASETO tokens for authentication.

## Golang implementation

Here is the golang implementation using the huma framework and go's own `http.ServeMux()` router:

Project structure:

```default
example-api/
├── main.go
├── handlers/
│   ├── admin.go
│   ├── projects.go
│   ├── embeddings.go
│   ├── similars.go
│   ├── llm_process.go
└── models/
    ├── user.go
    ├── project.go
    ├── embedding.go
    ├── similar.go
    ├── llm_process.go
```

```{code} go
:filename: main.go
:linenos:
package main

import (
    "net/http"

    "github.com/danielgtaylor/huma/v2"
    "example-api/handlers"
)

func main() {
    router := http.NewServeMux()
    api := huma.NewRouter("Example API", "1.0.0")

    handlers.RegisterAdminRoutes(api)
    handlers.RegisterProjectRoutes(api)
    handlers.RegisterEmbeddingRoutes(api)
    handlers.RegisterSimilarRoutes(api)
    handlers.RegisterLLMProcessRoutes(api)

    router.Handle("/", api)
    http.ListenAndServe(":8080", router)
}
```

```{code} go
:filename: handlers/admin.go
:linenos:
package handlers

import (
    "github.com/danielgtaylor/huma/v2"
    "example-api/models"
)

func RegisterAdminRoutes(api *huma.Router) {
    api.Resource("/admin/users").
        Put("Create or update a user", func(ctx huma.Context, input models.User) {
            // Implement your logic here
        })

    api.Resource("/admin/users/{user}").
        Patch("Update a specific user", func(ctx huma.Context, input models.User) {
            // Implement your logic here
        }).
        Get("Get a specific user", func(ctx huma.Context) {
            // Implement your logic here
        }).
        Delete("Delete a specific user", func(ctx huma.Context) {
            // Implement your logic here
        })
}
```

```{code} go
:filename: handlers/projects.go
:linenos:
package handlers

import (
    "github.com/danielgtaylor/huma/v2"
    "example-api/models"
)

func RegisterProjectRoutes(api *huma.Router) {
    api.Resource("/{user}/projects").
        Put("Create or update a project", func(ctx huma.Context, input models.Project) {
            // Implement your logic here
        })

    api.Resource("/{user}/projects/{project}").
        Patch("Update a specific project", func(ctx huma.Context, input models.Project) {
            // Implement your logic here
        }).
        Get("Get a specific project", func(ctx huma.Context) {
            // Implement your logic here
        }).
        Delete("Delete a specific project", func(ctx huma.Context) {
            // Implement your logic here
        })
}
```

```{code} go
:filename: handlers/embeddings.go
:linenos:
package handlers

import (
    "github.com/danielgtaylor/huma/v2"
    "example-api/models"
)

func RegisterEmbeddingRoutes(api *huma.Router) {
    api.Resource("/{user}/{project}/embeddings").
        Put("Create or update embeddings for a project", func(ctx huma.Context, input models.Embedding) {
            // Implement your logic here
        }).
        Post("Create embeddings for provided text", func(ctx huma.Context, input models.Embedding) {
            // Implement your logic here
        })

    api.Resource("/{user}/{project}/embeddings/{id}").
        Get("Get a specific embedding", func(ctx huma.Context) {
            // Implement your logic here
        }).
        Delete("Delete a specific embedding", func(ctx huma.Context) {
            // Implement your logic here
        })
}
```

```{code} go
:filename: handlers/similars.go
:linenos:
package handlers

import (
    "github.com/danielgtaylor/huma/v2"
    "example-api/models"
)

func RegisterSimilarRoutes(api *huma.Router) {
    api.Resource("/{user}/{project}/similars/{id}").
        Get("Retrieve similar items", func(ctx huma.Context) {
            // Implement your logic here
        })

    api.Resource("/{user}/{project}/similars").
        Post("Retrieve similar items with query", func(ctx huma.Context, input models.SimilarQuery) {
            // Implement your logic here
        })
}
```

```{code} go
:filename: handlers/llm_process.go
:linenos:
package handlers

import (
    "github.com/danielgtaylor/huma/v2"
    "example-api/models"
)

func RegisterLLMProcessRoutes(api *huma.Router) {
    api.Resource("/llm-process").
        Post("Process text with LLM service", func(ctx huma.Context, input models.LLMProcessRequest) {
            // Implement your logic here
        })
}
```

```{code} go
:filename: models/user.go
:linenos:
package models

type User struct {
    Username string `json:"username"`
    Email    string `json:"email"`
    APIKey   string `json:"apiKey"`
}
```

```{code} go
:filename: models/project.go
:linenos:
package models

type Project struct {
    // Define project fields here
}
```

```{code} go
:filename: models/embedding.go
:linenos:
package models

type Embedding struct {
    // Define embedding fields here
}
```

```{code} go
:filename: models/similar.go
:linenos:
package models

type SimilarQuery struct {
    Count     int     `json:"count"`
    Threshold float64 `json:"threshold"`
}
```

```{code} go
:filename: models/llm_process.go
:linenos:
package models

type LLMProcessRequest struct {
    ServiceID  string   `json:"serviceId"`
    ProjectID  string   `json:"projectId"`
    ContextID  string   `json:"contextId"`
    TextFields []string `json:"textFields"`
}
```

> This code sets up the basic structure and routing for your API using the Huma v2 framework and Go's http.ServeMux. Each handler file contains the route definitions for a specific part of the API, and each model file defines the data structures used in the API.
>
> You will need to fill in the implementation details for each handler function and define the full structure of the models as required by your API.
</file>

<file path="internal/auth/authenticate.go">
package auth

import (
	"net/http"
	"slices"
	"strings"

	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
)

// Config is the security scheme configuration for the API.
var Config = map[string]*huma.SecurityScheme{
	// Example Authorization Code flow.
	"myAuth": {
		Type: "oauth2",
		Flows: &huma.OAuthFlows{
			AuthorizationCode: &huma.OAuthFlow{
				AuthorizationURL: "https://example.com/oauth/authorize",
				TokenURL:         "https://example.com/oauth/token",
				Scopes: map[string]string{
					"scope1": "Scope 1 description...",
					"scope2": "Scope 2 description...",
				},
			},
		},
	},

	// Example alternative describing the use of JWTs without documenting how
	// they are issued or which flows might be supported. This is simpler but
	// tells clients less information.
	"anotherAuth": {
		Type:         "http",
		Scheme:       "bearer",
		BearerFormat: "JWT",
	},
	"adminAuth": {
		Type:   "apiKey",
		In:     "header",
		Scheme: "bearer",
		Name:   "X-API-Key",
	},
	"ownerAuth": {
		Type:   "apiKey",
		In:     "header",
		Scheme: "bearer",
		Name:   "X-API-Key",
	},
}

// AuthMiddleware creates a middleware that will authorize requests based on
// the required scopes for the operation.
func AuthMiddleware(api huma.API, options *models.Options) func(ctx huma.Context, next func(huma.Context)) {
	return func(ctx huma.Context, next func(huma.Context)) {
		var anyOfNeededScopes []string
		isAuthorizationRequired := false
		for _, opScheme := range ctx.Operation().Security {
			var ok bool
			if anyOfNeededScopes, ok = opScheme["myAuth"]; ok {
				isAuthorizationRequired = true
				break
			}
		}

		if !isAuthorizationRequired {
			next(ctx)
			return
		}

		token := strings.TrimPrefix(ctx.Header("Authorization"), "Bearer ")
		if len(token) == 0 {
			huma.WriteErr(api, ctx, http.StatusUnauthorized, "Unauthorized")
			return
		}

		// Parse and validate the JWT.
		parsed, err := jwt.ParseString(token,
			jwt.WithValidate(true),
			jwt.WithIssuer("my-issuer"),
			jwt.WithAudience("my-audience"),
		)
		if err != nil {
			huma.WriteErr(api, ctx, http.StatusUnauthorized, "Unauthorized")
			return
		}

		// Ensure the claims required for this operation are present.
		scopes, _ := parsed.Get("scopes")
		if scopes, ok := scopes.([]string); ok {
			for _, scope := range scopes {
				if slices.Contains(anyOfNeededScopes, scope) {
					next(ctx)
					return
				}
			}
		}

		huma.WriteErr(api, ctx, http.StatusForbidden, "Forbidden")
	}
}
</file>

<file path="internal/database/migrations/001_create_initial_scheme.sql">
-- This enables the vector extension.

-- Currently disabled, because it requires
-- Superuser privileges in PostgreSQL
-- CREATE EXTENSION IF NOT EXISTS vector;

-- This creates the users table.

CREATE TABLE IF NOT EXISTS users(
  "handle" VARCHAR(20) PRIMARY KEY,
  "name" TEXT,
  "email" TEXT UNIQUE NOT NULL,
  "vdb_key" CHAR(32) UNIQUE NOT NULL,
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL
);

-- This creates the projects table.

CREATE TABLE IF NOT EXISTS projects(
  "project_id" SERIAL PRIMARY KEY,
  "handle" VARCHAR(20) NOT NULL,
  "owner" VARCHAR(20) NOT NULL REFERENCES "users"("handle") ON DELETE CASCADE,
  "description" TEXT,
  "metadata_scheme" TEXT,
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL,
  UNIQUE ("handle", "owner")
);

CREATE INDEX IF NOT EXISTS projects_handle ON "projects"("handle");

-- This creates the users_projects associations table.

CREATE TABLE IF NOT EXISTS vdb_roles(
  "vdb_role" VARCHAR(20) PRIMARY KEY
);

INSERT INTO "vdb_roles"("vdb_role")
VALUES ('owner'), ('writer'), ('reader');

CREATE TABLE IF NOT EXISTS users_projects(
  "user_handle" VARCHAR(20) REFERENCES "users"("handle") ON DELETE CASCADE,
  "project_id" SERIAL REFERENCES "projects"("project_id") ON DELETE CASCADE,
  "role" VARCHAR(20) NOT NULL REFERENCES "vdb_roles"("vdb_role"),
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL,
  PRIMARY KEY ("user_handle", "project_id")
);

-- This creates the LLM Services table.

-- This creates the api_standards table.

CREATE TABLE IF NOT EXISTS key_methods(
  "key_method" VARCHAR(20) PRIMARY KEY
);

INSERT INTO "key_methods"("key_method")
VALUES ('auth_bearer'), ('body_form'), ('query_param'), ('custom_header');

CREATE TABLE IF NOT EXISTS api_standards(
  "handle" VARCHAR(20) PRIMARY KEY,
  "description" TEXT,
  "key_method" VARCHAR(20) NOT NULL REFERENCES "key_methods"("key_method"),
  "key_field" VARCHAR(20),
  "vector_size" INTEGER NOT NULL,
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL
);

CREATE TABLE IF NOT EXISTS instances(
  "llmservice_id" SERIAL PRIMARY KEY,
  "handle" VARCHAR(20) NOT NULL,
  "owner" VARCHAR(20) NOT NULL REFERENCES "users"("handle") ON DELETE CASCADE,
  "description" TEXT,
  "endpoint" TEXT NOT NULL,
  "api_key" TEXT,
  "api_standard" VARCHAR(20) NOT NULL REFERENCES "api_standards"("handle"),
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL,
  UNIQUE ("handle", "owner")
);

CREATE INDEX IF NOT EXISTS llmservices_handle ON "instances"("handle");

-- This creates the users_llmservices associations table.

CREATE TABLE IF NOT EXISTS users_llmservices(
  "user" VARCHAR(20) NOT NULL REFERENCES "users"("handle") ON DELETE CASCADE,
  "llmservice" SERIAL NOT NULL REFERENCES "instances"("llmservice_id") ON DELETE CASCADE,
  "role" VARCHAR(20) NOT NULL REFERENCES "vdb_roles"("vdb_role"),
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL,
  PRIMARY KEY ("user", "llmservice")
);

-- This creates the projects_llmservices associations table.

CREATE TABLE IF NOT EXISTS projects_llmservices(
  "project" SERIAL NOT NULL REFERENCES "projects"("project_id") ON DELETE CASCADE,
  "llmservice" SERIAL NOT NULL REFERENCES "instances"("llmservice_id") ON DELETE CASCADE,
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL,
  PRIMARY KEY ("project", "llmservice")
);

-- This creates the embeddings table.

CREATE TABLE IF NOT EXISTS embeddings(
  "id" SERIAL PRIMARY KEY,
  "owner" VARCHAR(20) NOT NULL REFERENCES "users"("handle") ON DELETE CASCADE,
  "project" SERIAL NOT NULL REFERENCES "projects"("project_id") ON DELETE CASCADE,
  "text_id" TEXT,
  "embedding" halfvec NOT NULL,
  "embedding_dim" INTEGER NOT NULL,
  "llmservice" SERIAL NOT NULL REFERENCES "instances"("llmservice_id"),
  "text" TEXT,
  -- TODO: add metadata handling
  -- "metadata" jsonb,
  "created_at" TIMESTAMP NOT NULL,
  "updated_at" TIMESTAMP NOT NULL
);

CREATE INDEX IF NOT EXISTS embeddings_text_id ON "embeddings"("text_id");

-- We will create the index for the vector in a separate schema version
-- CREATE INDEX ON embedding USING hnsw (embedding halfvec_cosine_ops) WITH (m = 16, ef_construction = 128);


---- create above / drop below ----

-- This removes the users table.

DROP TABLE IF EXISTS users;

-- This removes the projects table.

DROP TABLE IF EXISTS projects;

DROP INDEX IF EXISTS projects_handle;

-- This removes the users_projects associations table.

DROP TABLE IF EXISTS users_projects;

DROP TABLE IF EXISTS vdb_roles;

-- This removes the LLM Services table.

DROP TABLE IF EXISTS instances;

DROP INDEX IF EXISTS llmservices_handle;

-- This removes the users_llmservices associations table.

DROP TABLE IF EXISTS users_llmservices;

-- This removes the projects_llmservices associations table.

DROP TABLE IF EXISTS projects_llmservices;

-- This removes the embeddings table.

DROP TABLE IF EXISTS embeddings;

DROP INDEX IF EXISTS embeddings_text_id;

-- This removes the api_standards table.

DROP TABLE IF EXISTS key_methods;

DROP TABLE IF EXISTS api_standards;

-- This removes the vector extension.
-- Again, as we have disabled it above,
-- we disable it here, too.
-- DROP EXTENSION vector;
</file>

<file path="internal/database/migrations/002_create_emb_index.sql">
-- This creates an approximate index on the embeddings vectors.

-- Without an index, pg_vector will use a sequential scan to find the nearest neighbors.
-- This will yield perfect recall but will be very slow.
-- PGVector supports two approximate indexes: IVFFlat and HNSW.
-- Both IVFFlat and HNSW are approximate indexes that work with heuristics.
-- That means that there could be errors in their search results.
-- However, they are much faster than exact indexes.

-- HNSW is a good choice for high-dimensional vectors and shines in query time
--   and robustness when data is being updated.
-- IVFFlat is a good choice for low-dimensional vectors and shines in
--   index construction time and memory usage.

-- The m parameter is the number of neighbors to consider during search.
-- The ef_construction parameter is the number of neighbors to consider during index construction.
-- The ef_search parameter is the number of neighbors to consider during search.
-- The vector_size parameter is the size of the vectors in the index.
-- The halfvec_cosine_ops parameter is the cosine similarity operation on half vectors.

-- The HNSW parameters we're using should yield a recall of 0.998 with a decent query time.

-- However, you can only create indexes on rows with the same number of dimensions (using expression and partial indexing):

-- CREATE INDEX embeddings_vector ON embeddings USING hnsw (embedding halfvec_cosine_ops) WITH (m = 16, ef_construction = 128);
CREATE INDEX IF NOT EXISTS embeddings_vector_384  ON embeddings USING hnsw ((embedding::halfvec(384))  halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 384);  -- Cohere embed-multilingual-light-v3.0, embed-english-light-v3.0
CREATE INDEX IF NOT EXISTS embeddings_vector_768  ON embeddings USING hnsw ((embedding::halfvec(768))  halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 768);  -- BERT base, Cohere embed-multilingual-v2.0, Gemini Embeddings
CREATE INDEX IF NOT EXISTS embeddings_vector_1024 ON embeddings USING hnsw ((embedding::halfvec(1024)) halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 1024); -- BERT large, SBERT, Cohere embed-multilingual-v3.0, embed-english-v3.0
CREATE INDEX IF NOT EXISTS embeddings_vector_1536 ON embeddings USING hnsw ((embedding::halfvec(1536)) halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 1536); -- OpenAI text-embedding-ada-002, text-embedding-3-small
CREATE INDEX IF NOT EXISTS embeddings_vector_3072 ON embeddings USING hnsw ((embedding::halfvec(3072)) halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 3072); -- OpenAI text-embedding-3-large
-- CREATE INDEX IF NOT EXISTS embeddings_vector_4096 ON embeddings USING hnsw ((embedding::halfvec(4096)) halfvec_cosine_ops) WITH (m = 24, ef_construction = 200) WHERE (embedding_dim = 4096); -- Cohere embed-english-v2.0, Llama 3.1, Mistral 7B, OpenAI text-embedding-ada-001

-- You can then use the index to find the nearest neighbors of a vector:
-- SELECT * FROM embeddings WHERE model_id = 123 ORDER BY embedding::vector(768) <-> '[3,1,2,...]' LIMIT 5;

SET hnsw.ef_search = 100;

---- create above / drop below ----

-- This removes the index on embedding vectors.

DROP INDEX IF EXISTS embeddings_vector_384;
DROP INDEX IF EXISTS embeddings_vector_768;
DROP INDEX IF EXISTS embeddings_vector_1024;
DROP INDEX IF EXISTS embeddings_vector_1536;
DROP INDEX IF EXISTS embeddings_vector_3072;
-- DROP INDEX IF EXISTS embeddings_vector_4096;

SET hnsw.ef_search = 40;
</file>

<file path="internal/database/migrations/tern.conf.tpl">
[database]
# host is required (network host or path to Unix domain socket)
# host = 
# port = 5432
# database is required
# database =
# user defaults to OS user
# user =
# password =
# version_table = public.schema_version
#
# sslmode generally matches the behavior described in:
# http://www.postgresql.org/docs/9.4/static/libpq-ssl.html#LIBPQ-SSL-PROTECTION
#
# There are only two modes that most users should use:
# prefer - on trusted networks where security is not required
# verify-full - require SSL connection
# sslmode = prefer
#
# sslrootcert is generally used with sslmode=verify-full
# sslrootcert = /path/to/root/ca

# Proxy the above database connection via SSH
# [ssh-tunnel]
# host =
# port = 22
# user defaults to OS user
# user =
# password is not required if using SSH agent authentication
# password =

[data]
# Any fields in the data section are available in migration templates
# prefix = foo
</file>

<file path="internal/database/queries/queries.sql">
-- Generate go code with: sqlc generate

-- name: UpsertUser :one
INSERT INTO users (
  "handle", "name", "email", "vdb_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("handle") DO UPDATE SET
  "name" = $2,
  "email" = $3,
  "vdb_key" = $4,
  "updated_at" = NOW()
RETURNING *;

-- name: DeleteUser :exec
DELETE FROM users
WHERE "handle" = $1;

-- name: RetrieveUser :one
SELECT * FROM users
WHERE "handle" = $1 LIMIT 1;

-- name: GetUsers :many
SELECT "handle" FROM users ORDER BY "handle" ASC LIMIT $1 OFFSET $2;

-- name: GetUsersByProject :many
SELECT users."handle", users_projects."role"
FROM users JOIN users_projects
ON users."handle" = users_projects."user_handle"
JOIN projects ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1 AND projects."handle" = $2
ORDER BY users."handle" ASC LIMIT $3 OFFSET $4;


-- name: UpsertProject :one
INSERT INTO projects (
  "handle", "owner", "description", "metadata_scheme", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("handle", "owner") DO UPDATE SET
  "description" = $3,
  "metadata_scheme" = $4,
  "updated_at" = NOW()
RETURNING "project_id", "handle", "owner";

-- name: DeleteProject :exec
DELETE FROM projects
WHERE "owner" = $1
  AND "handle" = $2;

-- name: GetProjectsByUser :many
SELECT projects.*, users_projects."role"
FROM projects JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
ORDER BY projects."handle" ASC LIMIT $2 OFFSET $3;

-- name: RetrieveProject :one
SELECT * FROM projects
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1;

-- name: LinkProjectToUser :one
INSERT INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "project_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING *;

-- TODO: name: TransferProject :one



-- name: UpsertLLM :one
INSERT INTO instances (
  "handle", "owner", "description", "endpoint", "api_key", "api_standard", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
ON CONFLICT ("handle", "owner") DO UPDATE SET
  "description" = $3,
  "endpoint" = $4,
  "api_key" = $5,
  "api_standard" = $6,
  "updated_at" = NOW()
RETURNING "llmservice_id", "handle", "owner";

-- name: DeleteLLM :exec
DELETE FROM instances
WHERE "owner" = $1
  AND "handle" = $2;

-- name: RetrieveLLM :one
SELECT * FROM instances
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1;

-- name: LinkUserToLLM :exec
INSERT INTO users_llmservices (
  "user", "llmservice", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user", "llmservice") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING *;

-- name: LinkProjectToLLM :exec
INSERT INTO projects_llmservices (
  "project", "llmservice", "created_at", "updated_at"
) VALUES (
  $1, $2, NOW(), NOW()
)
ON CONFLICT ("project", "llmservice") DO NOTHING
RETURNING *;

-- name: GetLLMsByProject :many
SELECT instances.* FROM instances
JOIN (
  projects_llmservices JOIN projects
  ON projects_llmservices."project" = projects."project_id"
)
ON instances."llmservice_id" = projects_llmservices."llmservice"
WHERE projects."owner" = $1
  AND projects."handle" = $2
ORDER BY instances."handle" ASC LIMIT $3 OFFSET $4;

-- name: GetLLMsByUser :many
SELECT instances.* FROM instances
JOIN (
  projects_llmservices JOIN users_projects
  ON projects_llmservices."project" = users_projects."project_id"
)
ON instances."llmservice_id" = projects_llmservices."llmservice"
WHERE users_projects."user_handle" = $1
ORDER BY instances."handle" ASC LIMIT $2 OFFSET $3;


-- TODO: Add metadata field
-- name: UpsertEmbeddings :one
INSERT INTO embeddings (
  "id", "owner", "project", "text_id", "embedding", "embedding_dim", "llmservice", "text", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $9, NOW(), NOW()
)
ON CONFLICT ("id") DO UPDATE SET
  "text_id" = $2,
  "owner" = $3,
  "project" = $4,
  "embedding" = $5,
  "embedding_dim" = $6,
  "llmservice" = $7,
  "text" = $8,
  "updated_at" = NOW()
RETURNING "id", "text_id";

-- name: DeleteEmbeddingsByID :exec
DELETE FROM embeddings
WHERE "id" = $1;

-- name: DeleteEmbeddingsByProject :exec
DELETE FROM embeddings
WHERE "owner" = $1
  AND "project" = $2;

-- name: DeleteEmbeddingsByDocID :exec
DELETE FROM embeddings
WHERE "owner" = $1
  AND "project" = $2
  AND "text_id" = $3;

-- name: RetrieveEmbeddings :one
SELECT embeddings.*, projects."handle" AS "project", instances."handle"
FROM embeddings
JOIN instances
  ON embeddings."llmservice" = instances."llmservice_id"
JOIN projects
  ON projects."project_id" = embeddings."project"
WHERE embeddings."owner" = $1
  AND "project" = $2
  AND embeddings."text_id" = $3
LIMIT 1;

-- name: GetEmbeddingsByProject :many
SELECT embeddings.*, projects."handle" AS "project", instances."handle" AS "llmservice"
FROM embeddings
JOIN instances
  ON instances."llmservice_id" = embeddings."llmservice"
JOIN projects
  ON projects."project_id" = embeddings."project"
WHERE embeddings."owner" = $1
  AND "project" = $2
ORDER BY embeddings."text_id" ASC LIMIT $3 OFFSET $4;


-- name: UpsertAPI :one
INSERT INTO api_standards (
  "handle", "description", "key_method", "key_field", "vector_size", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, NOW(), NOW()
)
ON CONFLICT ("handle") DO UPDATE SET
  "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "vector_size" = $5,
  "updated_at" = NOW()
RETURNING "handle";

-- name: DeleteAPI :exec
DELETE FROM api_standards
WHERE "handle" = $1;

-- name: RetrieveAPI :one
SELECT * FROM api_standards
WHERE "handle" = $1 LIMIT 1;

-- name: GetAPIs :many
SELECT * FROM api_standards
ORDER BY "handle" ASC LIMIT $1 OFFSET $2;



-- name: GetSimilarsByVector :many
SELECT embeddings."id", embeddings."text_id", instances."owner", instances."handle"
FROM embeddings JOIN instances
ON embeddings."llmservice" = instances."llmservice_id"
ORDER BY "embedding" <=> $1
LIMIT $2 OFFSET $3;

-- name: GetSimilarsByID :many
SELECT e2."id", e2."text_id", 1 - (e1.embedding <=> e2.embedding) AS cosine_similarity
FROM embeddings e1
CROSS JOIN embeddings e2
WHERE e1."text_id" = $1
  AND e2."id" != e1."id"
ORDER BY e1.embedding <=> e2.embedding
LIMIT $2 OFFSET $3;
</file>

<file path="internal/database/database.go">
package database

import (
	"context"
	"fmt"
	"os"
	"time"

	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Database initialization

func InitDB(options *models.Options) (*pgxpool.Pool, error) {
  println("--- Connecting to database ...")

  // urlExample := "postgres://username:password@localhost:5432/database_name"
  url := fmt.Sprintf("postgres://%s:%s@%s:%d/%s",
    options.DBUser, options.DBPassword, options.DBHost, options.DBPort, options.DBName)

  // Connect to the database, first without concurrency to check the schema version
  ctx_cancel, cancel := context.WithTimeout(context.Background(), 5*time.Second)
  defer cancel()
  err := VerifySchema(ctx_cancel, url)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to verify schema: %v\n", err)
    return nil, err
  }

  // For the actual application, connect to the db using a connection pool
  ctx_bg := context.Background()
  pool, err := pgxpool.New(ctx_bg, url)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to get connection pool from database: %v\n", err)
    return nil, err
  }
  defer pool.Close()
  fmt.Printf("    Successfully got connection pool from postgres database: %s@%s:%d/%s.\n", // alternatively, print conn.ConnInfo().DatabaseName
    options.DBUser, options.DBHost, options.DBPort, options.DBName)

  // Run test query (get all users)
  conn, err := pool.Acquire(ctx_bg)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to get connection from pool: %v\n", err)
    return nil, err
  }
  err = testQuery(ctx_bg, conn)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to run test query: %v\n", err)
    return nil, err
  }

  // Done, everything has been set up. Return connection pool.
  println("--- Database up and initialized.")
  return pool, nil
}

func VerifySchema(ctx context.Context, url string) error {
  conn, err := pgx.Connect(ctx, url)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to connect to database: %v\n", err)
    return err
  }
  // Check schema version of database
  println("--- Checking schema version of database ...")
  migrator, err := NewMigrator(ctx, conn)
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to initialize migrator: %v\n", err)
    return err
  }
  // get the current migration status
  now, exp, info, err := migrator.Info()
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to get schema info: %v\n", err)
    return err
  }
  if now < exp {
    // migration is required, dump out the current state
    // and perform the migration
    println("    Database scheme needs migration, current state: ")
    println(info)

    ctx_cancel, cancel := context.WithTimeout(ctx, 10*time.Second)
    defer cancel()
    err = migrator.Migrate(ctx_cancel)
    if err != nil {
        fmt.Fprintf(os.Stderr, "EEE Unable to migrate schema: %v\n", err)
        return err
      }
    println("    Database migration successful, schema up to date!")
  } else {
    println("    Database schema up to date, no database migration needed")
  }

  conn.Close(ctx)
  return nil
}

func testQuery(ctx context.Context, conn *pgxpool.Conn) error {
  println("--- Send test query - list all users:")

  ctx_cancel, cancel := context.WithTimeout(ctx, 5*time.Second)
  defer cancel()

  queries := New(conn)
  users, err := queries.GetUsers(ctx_cancel, GetUsersParams{Limit: 10, Offset: 0})
  if err != nil {
    fmt.Fprintf(os.Stderr, "EEE Unable to get users: %v\n", err)
    return err
  }
  println(users)
  return nil
}
</file>

<file path="internal/database/db.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package database

import (
	"context"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/pgx/v5/pgconn"
)

type DBTX interface {
	Exec(context.Context, string, ...interface{}) (pgconn.CommandTag, error)
	Query(context.Context, string, ...interface{}) (pgx.Rows, error)
	QueryRow(context.Context, string, ...interface{}) pgx.Row
}

func New(db DBTX) *Queries {
	return &Queries{db: db}
}

type Queries struct {
	db DBTX
}

func (q *Queries) WithTx(tx pgx.Tx) *Queries {
	return &Queries{
		db: tx,
	}
}
</file>

<file path="internal/database/migrations.go">
package database

// This is mostly from https://github.com/tardisx/embed_tern,
// with some adjustments for pgxpool and for how it is called in my app's context.

import (
	"context"
	"embed"
	"fmt"
	"io/fs"

	"github.com/jackc/pgx/v5"
	"github.com/jackc/tern/v2/migrate"
)

const versionTable = "db_version"

type Migrator struct {
  migrator *migrate.Migrator
}

//go:embed migrations/*.sql
var migrationFiles embed.FS

func NewMigrator(ctx context.Context, conn *pgx.Conn) (Migrator, error) {

  migrator, err := migrate.NewMigratorEx(
    ctx, conn, versionTable,
    &migrate.MigratorOptions{
      DisableTx: false,
    })
  if err != nil {
    return Migrator{}, err
  }

  migrationRoot, err := fs.Sub(migrationFiles, "migrations")
  if err != nil {
    return Migrator{}, err
  }

  err = migrator.LoadMigrations(migrationRoot)
  if err != nil {
    return Migrator{}, err
  }

  return Migrator{
    migrator: migrator,
  }, nil
}

// Info the current migration version and the embedded maximum migration, and a textual
// representation of the migration state for informational purposes.
func (m Migrator) Info() (int32, int32, string, error) {

  version, err := m.migrator.GetCurrentVersion(context.Background())
  if err != nil {
    return 0, 0, "", err
  }
  info := ""

  var last int32
  for _, thisMigration := range m.migrator.Migrations {
    last = thisMigration.Sequence

    cur := version == thisMigration.Sequence
    indicator := "  "
    if cur {
      indicator = "->"
    }
    info = info + fmt.Sprintf(
      "%2s %3d %s\n",
      indicator,
      thisMigration.Sequence, thisMigration.Name)
  }

  return version, last, info, nil
}

// Migrate migrates the DB to the most recent version of the schema.
func (m Migrator) Migrate(ctx context.Context) error {
  err := m.migrator.Migrate(ctx)
  return err
}

// MigrateTo migrates to a specific version of the schema. Use '0' to undo all migrations.
func (m Migrator) MigrateTo(ctx context.Context, ver int32) error {
  err := m.migrator.MigrateTo(ctx, ver)
  return err
}
</file>

<file path="internal/database/models.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0

package database

import (
	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

type ApiStandard struct {
	Handle      string           `db:"handle" json:"handle"`
	Description pgtype.Text      `db:"description" json:"description"`
	KeyMethod   string           `db:"key_method" json:"key_method"`
	KeyField    pgtype.Text      `db:"key_field" json:"key_field"`
	VectorSize  int32            `db:"vector_size" json:"vector_size"`
	CreatedAt   pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt   pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Embedding struct {
	ID           int32                  `db:"id" json:"id"`
	Owner        string                 `db:"owner" json:"owner"`
	Project      int32                  `db:"project" json:"project"`
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding    pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim int32                  `db:"embedding_dim" json:"embedding_dim"`
	Llmservice   int32                  `db:"llmservice" json:"llmservice"`
	Text         pgtype.Text            `db:"text" json:"text"`
	CreatedAt    pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
}

type KeyMethod struct {
	KeyMethod string `db:"key_method" json:"key_method"`
}

type Llmservice struct {
	LlmserviceID int32            `db:"llmservice_id" json:"llmservice_id"`
	Handle       string           `db:"handle" json:"handle"`
	Owner        string           `db:"owner" json:"owner"`
	Description  pgtype.Text      `db:"description" json:"description"`
	Endpoint     string           `db:"endpoint" json:"endpoint"`
	ApiKey       pgtype.Text      `db:"api_key" json:"api_key"`
	ApiStandard  string           `db:"api_standard" json:"api_standard"`
	CreatedAt    pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type Project struct {
	ProjectID      int32            `db:"project_id" json:"project_id"`
	Handle         string           `db:"handle" json:"handle"`
	Owner          string           `db:"owner" json:"owner"`
	Description    pgtype.Text      `db:"description" json:"description"`
	MetadataScheme pgtype.Text      `db:"metadata_scheme" json:"metadata_scheme"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type ProjectsLlmservice struct {
	Project    int32            `db:"project" json:"project"`
	Llmservice int32            `db:"llmservice" json:"llmservice"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type User struct {
	Handle    string           `db:"handle" json:"handle"`
	Name      pgtype.Text      `db:"name" json:"name"`
	Email     string           `db:"email" json:"email"`
	VDBKey string           `db:"vdb_key" json:"vdb_key"`
	CreatedAt pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type UsersLlmservice struct {
	User       string           `db:"user" json:"user"`
	Llmservice int32            `db:"llmservice" json:"llmservice"`
	Role       string           `db:"role" json:"role"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type UsersProject struct {
	UserHandle string           `db:"user_handle" json:"user_handle"`
	ProjectID  int32            `db:"project_id" json:"project_id"`
	Role       string           `db:"role" json:"role"`
	CreatedAt  pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt  pgtype.Timestamp `db:"updated_at" json:"updated_at"`
}

type VdbRole struct {
	VdbRole string `db:"vdb_role" json:"vdb_role"`
}
</file>

<file path="internal/database/queries.sql.go">
// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: queries.sql

package database

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
	pgvector_go "github.com/pgvector/pgvector-go"
)

const deleteAPI = `-- name: DeleteAPI :exec
DELETE FROM api_standards
WHERE "handle" = $1
`

func (q *Queries) DeleteAPI(ctx context.Context, handle string) error {
	_, err := q.db.Exec(ctx, deleteAPI, handle)
	return err
}

const deleteDocEmbeddings = `-- name: DeleteEmbeddingsByDocID :exec
DELETE FROM embeddings
WHERE "owner" = $1
  AND "project" = $2
  AND "text_id" = $3
`

type DeleteEmbeddingsByDocIDParams struct {
	Owner   string      `db:"owner" json:"owner"`
	Project int32       `db:"project" json:"project"`
	TextID  pgtype.Text `db:"text_id" json:"text_id"`
}

func (q *Queries) DeleteEmbeddingsByDocID(ctx context.Context, arg DeleteEmbeddingsByDocIDParams) error {
	_, err := q.db.Exec(ctx, deleteDocEmbeddings, arg.Owner, arg.Project, arg.TextID)
	return err
}

const deleteEmbeddingsByID = `-- name: DeleteEmbeddingsByID :exec
DELETE FROM embeddings
WHERE "id" = $1
`

func (q *Queries) DeleteEmbeddingsByID(ctx context.Context, id int32) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByID, id)
	return err
}

const deleteEmbeddingsByProject = `-- name: DeleteEmbeddingsByProject :exec
DELETE FROM embeddings
WHERE "owner" = $1
  AND "project" = $2
`

type DeleteEmbeddingsByProjectParams struct {
	Owner   string `db:"owner" json:"owner"`
	Project int32  `db:"project" json:"project"`
}

func (q *Queries) DeleteEmbeddingsByProject(ctx context.Context, arg DeleteEmbeddingsByProjectParams) error {
	_, err := q.db.Exec(ctx, deleteEmbeddingsByProject, arg.Owner, arg.Project)
	return err
}

const deleteLLM = `-- name: DeleteLLM :exec
DELETE FROM instances
WHERE "owner" = $1
  AND "handle" = $2
`

type DeleteLLMParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
}

func (q *Queries) DeleteLLM(ctx context.Context, arg DeleteLLMParams) error {
	_, err := q.db.Exec(ctx, deleteLLM, arg.Owner, arg.Handle)
	return err
}

const deleteProject = `-- name: DeleteProject :exec
DELETE FROM projects
WHERE "owner" = $1
  AND "handle" = $2
`

type DeleteProjectParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
}

func (q *Queries) DeleteProject(ctx context.Context, arg DeleteProjectParams) error {
	_, err := q.db.Exec(ctx, deleteProject, arg.Owner, arg.Handle)
	return err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM users
WHERE "handle" = $1
`

func (q *Queries) DeleteUser(ctx context.Context, handle string) error {
	_, err := q.db.Exec(ctx, deleteUser, handle)
	return err
}

const getAPIs = `-- name: GetAPIs :many
SELECT handle, description, key_method, key_field, vector_size, created_at, updated_at FROM api_standards
ORDER BY "handle" ASC LIMIT $1 OFFSET $2
`

type GetAPIsParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetAPIs(ctx context.Context, arg GetAPIsParams) ([]ApiStandard, error) {
	rows, err := q.db.Query(ctx, getAPIs, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ApiStandard
	for rows.Next() {
		var i ApiStandard
		if err := rows.Scan(
			&i.Handle,
			&i.Description,
			&i.KeyMethod,
			&i.KeyField,
			&i.VectorSize,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getEmbeddingsByProject = `-- name: GetEmbeddingsByProject :many
SELECT embeddings.id, embeddings.owner, embeddings.project, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice, embeddings.text, embeddings.created_at, embeddings.updated_at, projects."handle" AS "project", instances."handle" AS "llmservice"
FROM embeddings
JOIN instances
  ON instances."llmservice_id" = embeddings."llmservice"
JOIN projects
  ON projects."project_id" = embeddings."project"
WHERE embeddings."owner" = $1
  AND "project" = $2
ORDER BY embeddings."text_id" ASC LIMIT $3 OFFSET $4
`

type GetEmbeddingsByProjectParams struct {
	Owner   string `db:"owner" json:"owner"`
	Project int32  `db:"project" json:"project"`
	Limit   int32  `db:"limit" json:"limit"`
	Offset  int32  `db:"offset" json:"offset"`
}

type GetEmbeddingsByProjectRow struct {
	ID           int32                  `db:"id" json:"id"`
	Owner        string                 `db:"owner" json:"owner"`
	Project      int32                  `db:"project" json:"project"`
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding    pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim int32                  `db:"embedding_dim" json:"embedding_dim"`
	Llmservice   int32                  `db:"llmservice" json:"llmservice"`
	Text         pgtype.Text            `db:"text" json:"text"`
	CreatedAt    pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	Project_2    string                 `db:"project_2" json:"project_2"`
	Llmservice_2 string                 `db:"llmservice_2" json:"llmservice_2"`
}

func (q *Queries) GetEmbeddingsByProject(ctx context.Context, arg GetEmbeddingsByProjectParams) ([]GetEmbeddingsByProjectRow, error) {
	rows, err := q.db.Query(ctx, getEmbeddingsByProject,
		arg.Owner,
		arg.Project,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetEmbeddingsByProjectRow
	for rows.Next() {
		var i GetEmbeddingsByProjectRow
		if err := rows.Scan(
			&i.ID,
			&i.Owner,
			&i.Project,
			&i.TextID,
			&i.Embedding,
			&i.EmbeddingDim,
			&i.Llmservice,
			&i.Text,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Project_2,
			&i.Llmservice_2,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByProject = `-- name: GetLLMsByProject :many
SELECT instances.llmservice_id, instances.handle, instances.owner, instances.description, instances.endpoint, instances.api_key, instances.api_standard, instances.created_at, instances.updated_at FROM instances
JOIN (
  projects_llmservices JOIN projects
  ON projects_llmservices."project" = projects."project_id"
)
ON instances."llmservice_id" = projects_llmservices."llmservice"
WHERE projects."owner" = $1
  AND projects."handle" = $2
ORDER BY instances."handle" ASC LIMIT $3 OFFSET $4
`

type GetLLMsByProjectParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMsByProject(ctx context.Context, arg GetLLMsByProjectParams) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByProject,
		arg.Owner,
		arg.Handle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LlmserviceID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLLMsByUser = `-- name: GetLLMsByUser :many
SELECT instances.llmservice_id, instances.handle, instances.owner, instances.description, instances.endpoint, instances.api_key, instances.api_standard, instances.created_at, instances.updated_at FROM instances
JOIN (
  projects_llmservices JOIN users_projects
  ON projects_llmservices."project" = users_projects."project_id"
)
ON instances."llmservice_id" = projects_llmservices."llmservice"
WHERE users_projects."user_handle" = $1
ORDER BY instances."handle" ASC LIMIT $2 OFFSET $3
`

type GetLLMsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

func (q *Queries) GetLLMsByUser(ctx context.Context, arg GetLLMsByUserParams) ([]Llmservice, error) {
	rows, err := q.db.Query(ctx, getLLMsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Llmservice
	for rows.Next() {
		var i Llmservice
		if err := rows.Scan(
			&i.LlmserviceID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.Endpoint,
			&i.ApiKey,
			&i.ApiStandard,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getProjectsByUser = `-- name: GetProjectsByUser :many
SELECT projects.project_id, projects.handle, projects.owner, projects.description, projects.metadata_scheme, projects.created_at, projects.updated_at, users_projects."role"
FROM projects JOIN users_projects
ON projects."project_id" = users_projects."project_id"
WHERE users_projects."user_handle" = $1
ORDER BY projects."handle" ASC LIMIT $2 OFFSET $3
`

type GetProjectsByUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	Limit      int32  `db:"limit" json:"limit"`
	Offset     int32  `db:"offset" json:"offset"`
}

type GetProjectsByUserRow struct {
	ProjectID      int32            `db:"project_id" json:"project_id"`
	Handle         string           `db:"handle" json:"handle"`
	Owner          string           `db:"owner" json:"owner"`
	Description    pgtype.Text      `db:"description" json:"description"`
	MetadataScheme pgtype.Text      `db:"metadata_scheme" json:"metadata_scheme"`
	CreatedAt      pgtype.Timestamp `db:"created_at" json:"created_at"`
	UpdatedAt      pgtype.Timestamp `db:"updated_at" json:"updated_at"`
	Role           string           `db:"role" json:"role"`
}

func (q *Queries) GetProjectsByUser(ctx context.Context, arg GetProjectsByUserParams) ([]GetProjectsByUserRow, error) {
	rows, err := q.db.Query(ctx, getProjectsByUser, arg.UserHandle, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetProjectsByUserRow
	for rows.Next() {
		var i GetProjectsByUserRow
		if err := rows.Scan(
			&i.ProjectID,
			&i.Handle,
			&i.Owner,
			&i.Description,
			&i.MetadataScheme,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Role,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByID = `-- name: GetSimilarsByID :many
SELECT e2."id", e2."text_id", 1 - (e1.embedding <=> e2.embedding) AS cosine_similarity
FROM embeddings e1
CROSS JOIN embeddings e2
WHERE e1."text_id" = $1
  AND e2."id" != e1."id"
ORDER BY e1.embedding <=> e2.embedding
LIMIT $2 OFFSET $3
`

type GetSimilarsByIDParams struct {
	TextID pgtype.Text `db:"text_id" json:"text_id"`
	Limit  int32       `db:"limit" json:"limit"`
	Offset int32       `db:"offset" json:"offset"`
}

type GetSimilarsByIDRow struct {
	ID               int32       `db:"id" json:"id"`
	TextID           pgtype.Text `db:"text_id" json:"text_id"`
	CosineSimilarity int32       `db:"cosine_similarity" json:"cosine_similarity"`
}

func (q *Queries) GetSimilarsByID(ctx context.Context, arg GetSimilarsByIDParams) ([]GetSimilarsByIDRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByID, arg.TextID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByIDRow
	for rows.Next() {
		var i GetSimilarsByIDRow
		if err := rows.Scan(&i.ID, &i.TextID, &i.CosineSimilarity); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getSimilarsByVector = `-- name: GetSimilarsByVector :many
SELECT embeddings."id", embeddings."text_id", instances."owner", instances."handle"
FROM embeddings JOIN instances
ON embeddings."llmservice" = instances."llmservice_id"
ORDER BY "embedding" <=> $1
LIMIT $2 OFFSET $3
`

type GetSimilarsByVectorParams struct {
	Embedding pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	Limit     int32                  `db:"limit" json:"limit"`
	Offset    int32                  `db:"offset" json:"offset"`
}

type GetSimilarsByVectorRow struct {
	ID     int32       `db:"id" json:"id"`
	TextID pgtype.Text `db:"text_id" json:"text_id"`
	Owner  string      `db:"owner" json:"owner"`
	Handle string      `db:"handle" json:"handle"`
}

func (q *Queries) GetSimilarsByVector(ctx context.Context, arg GetSimilarsByVectorParams) ([]GetSimilarsByVectorRow, error) {
	rows, err := q.db.Query(ctx, getSimilarsByVector, arg.Embedding, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetSimilarsByVectorRow
	for rows.Next() {
		var i GetSimilarsByVectorRow
		if err := rows.Scan(
			&i.ID,
			&i.TextID,
			&i.Owner,
			&i.Handle,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsers = `-- name: GetUsers :many
SELECT "handle" FROM users ORDER BY "handle" ASC LIMIT $1 OFFSET $2
`

type GetUsersParams struct {
	Limit  int32 `db:"limit" json:"limit"`
	Offset int32 `db:"offset" json:"offset"`
}

func (q *Queries) GetUsers(ctx context.Context, arg GetUsersParams) ([]string, error) {
	rows, err := q.db.Query(ctx, getUsers, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var handle string
		if err := rows.Scan(&handle); err != nil {
			return nil, err
		}
		items = append(items, handle)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUsersByProject = `-- name: GetUsersByProject :many
SELECT users."handle", users_projects."role"
FROM users JOIN users_projects
ON users."handle" = users_projects."user_handle"
JOIN projects ON users_projects."project_id" = projects."project_id"
WHERE projects."owner" = $1 AND projects."handle" = $2
ORDER BY users."handle" ASC LIMIT $3 OFFSET $4
`

type GetUsersByProjectParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
	Limit  int32  `db:"limit" json:"limit"`
	Offset int32  `db:"offset" json:"offset"`
}

type GetUsersByProjectRow struct {
	Handle string `db:"handle" json:"handle"`
	Role   string `db:"role" json:"role"`
}

func (q *Queries) GetUsersByProject(ctx context.Context, arg GetUsersByProjectParams) ([]GetUsersByProjectRow, error) {
	rows, err := q.db.Query(ctx, getUsersByProject,
		arg.Owner,
		arg.Handle,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUsersByProjectRow
	for rows.Next() {
		var i GetUsersByProjectRow
		if err := rows.Scan(&i.Handle, &i.Role); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const linkProjectToLLM = `-- name: LinkProjectToLLM :exec
INSERT INTO projects_llmservices (
  "project", "llmservice", "created_at", "updated_at"
) VALUES (
  $1, $2, NOW(), NOW()
)
ON CONFLICT ("project", "llmservice") DO NOTHING
RETURNING project, llmservice, created_at, updated_at
`

type LinkProjectToLLMParams struct {
	Project    int32 `db:"project" json:"project"`
	Llmservice int32 `db:"llmservice" json:"llmservice"`
}

func (q *Queries) LinkProjectToLLM(ctx context.Context, arg LinkProjectToLLMParams) error {
	_, err := q.db.Exec(ctx, linkProjectToLLM, arg.Project, arg.Llmservice)
	return err
}

const linkProjectToUser = `-- name: LinkProjectToUser :one
INSERT INTO users_projects (
  "user_handle", "project_id", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user_handle", "project_id") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING user_handle, project_id, role, created_at, updated_at
`

type LinkProjectToUserParams struct {
	UserHandle string `db:"user_handle" json:"user_handle"`
	ProjectID  int32  `db:"project_id" json:"project_id"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) LinkProjectToUser(ctx context.Context, arg LinkProjectToUserParams) (UsersProject, error) {
	row := q.db.QueryRow(ctx, linkProjectToUser, arg.UserHandle, arg.ProjectID, arg.Role)
	var i UsersProject
	err := row.Scan(
		&i.UserHandle,
		&i.ProjectID,
		&i.Role,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const linkUserToLLM = `-- name: LinkUserToLLM :exec
INSERT INTO users_llmservices (
  "user", "llmservice", "role", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, NOW(), NOW()
)
ON CONFLICT ("user", "llmservice") DO UPDATE SET
  "role" = $3,
  "updated_at" = NOW()
RETURNING "user", llmservice, role, created_at, updated_at
`

type LinkUserToLLMParams struct {
	User       string `db:"user" json:"user"`
	Llmservice int32  `db:"llmservice" json:"llmservice"`
	Role       string `db:"role" json:"role"`
}

func (q *Queries) LinkUserToLLM(ctx context.Context, arg LinkUserToLLMParams) error {
	_, err := q.db.Exec(ctx, linkUserToLLM, arg.User, arg.Llmservice, arg.Role)
	return err
}

const retrieveAPI = `-- name: RetrieveAPI :one
SELECT handle, description, key_method, key_field, vector_size, created_at, updated_at FROM api_standards
WHERE "handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveAPI(ctx context.Context, handle string) (ApiStandard, error) {
	row := q.db.QueryRow(ctx, retrieveAPI, handle)
	var i ApiStandard
	err := row.Scan(
		&i.Handle,
		&i.Description,
		&i.KeyMethod,
		&i.KeyField,
		&i.VectorSize,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveEmbeddings = `-- name: RetrieveEmbeddings :one
SELECT embeddings.id, embeddings.owner, embeddings.project, embeddings.text_id, embeddings.embedding, embeddings.embedding_dim, embeddings.llmservice, embeddings.text, embeddings.created_at, embeddings.updated_at, projects."handle" AS "project", instances."handle"
FROM embeddings
JOIN instances
  ON embeddings."llmservice" = instances."llmservice_id"
JOIN projects
  ON projects."project_id" = embeddings."project"
WHERE embeddings."owner" = $1
  AND "project" = $2
  AND embeddings."text_id" = $3
LIMIT 1
`

type RetrieveEmbeddingsParams struct {
	Owner   string      `db:"owner" json:"owner"`
	Project int32       `db:"project" json:"project"`
	TextID  pgtype.Text `db:"text_id" json:"text_id"`
}

type RetrieveEmbeddingsRow struct {
	ID           int32                  `db:"id" json:"id"`
	Owner        string                 `db:"owner" json:"owner"`
	Project      int32                  `db:"project" json:"project"`
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding    pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim int32                  `db:"embedding_dim" json:"embedding_dim"`
	Llmservice   int32                  `db:"llmservice" json:"llmservice"`
	Text         pgtype.Text            `db:"text" json:"text"`
	CreatedAt    pgtype.Timestamp       `db:"created_at" json:"created_at"`
	UpdatedAt    pgtype.Timestamp       `db:"updated_at" json:"updated_at"`
	Project_2    string                 `db:"project_2" json:"project_2"`
	Handle       string                 `db:"handle" json:"handle"`
}

func (q *Queries) RetrieveEmbeddings(ctx context.Context, arg RetrieveEmbeddingsParams) (RetrieveEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, retrieveEmbeddings, arg.Owner, arg.Project, arg.TextID)
	var i RetrieveEmbeddingsRow
	err := row.Scan(
		&i.ID,
		&i.Owner,
		&i.Project,
		&i.TextID,
		&i.Embedding,
		&i.EmbeddingDim,
		&i.Llmservice,
		&i.Text,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Project_2,
		&i.Handle,
	)
	return i, err
}

const retrieveLLM = `-- name: RetrieveLLM :one
SELECT llmservice_id, handle, owner, description, endpoint, api_key, api_standard, created_at, updated_at FROM instances
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1
`

type RetrieveLLMParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
}

func (q *Queries) RetrieveLLM(ctx context.Context, arg RetrieveLLMParams) (Llmservice, error) {
	row := q.db.QueryRow(ctx, retrieveLLM, arg.Owner, arg.Handle)
	var i Llmservice
	err := row.Scan(
		&i.LlmserviceID,
		&i.Handle,
		&i.Owner,
		&i.Description,
		&i.Endpoint,
		&i.ApiKey,
		&i.ApiStandard,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveProject = `-- name: RetrieveProject :one
SELECT project_id, handle, owner, description, metadata_scheme, created_at, updated_at FROM projects
WHERE "owner" = $1
  AND "handle" = $2
LIMIT 1
`

type RetrieveProjectParams struct {
	Owner  string `db:"owner" json:"owner"`
	Handle string `db:"handle" json:"handle"`
}

func (q *Queries) RetrieveProject(ctx context.Context, arg RetrieveProjectParams) (Project, error) {
	row := q.db.QueryRow(ctx, retrieveProject, arg.Owner, arg.Handle)
	var i Project
	err := row.Scan(
		&i.ProjectID,
		&i.Handle,
		&i.Owner,
		&i.Description,
		&i.MetadataScheme,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const retrieveUser = `-- name: RetrieveUser :one
SELECT handle, name, email, vdb_key, created_at, updated_at FROM users
WHERE "handle" = $1 LIMIT 1
`

func (q *Queries) RetrieveUser(ctx context.Context, handle string) (User, error) {
	row := q.db.QueryRow(ctx, retrieveUser, handle)
	var i User
	err := row.Scan(
		&i.Handle,
		&i.Name,
		&i.Email,
		&i.VDBKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const upsertAPI = `-- name: UpsertAPI :one
INSERT INTO api_standards (
  "handle", "description", "key_method", "key_field", "vector_size", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, NOW(), NOW()
)
ON CONFLICT ("handle") DO UPDATE SET
  "description" = $2,
  "key_method" = $3,
  "key_field" = $4,
  "vector_size" = $5,
  "updated_at" = NOW()
RETURNING "handle"
`

type UpsertAPIParams struct {
	Handle      string      `db:"handle" json:"handle"`
	Description pgtype.Text `db:"description" json:"description"`
	KeyMethod   string      `db:"key_method" json:"key_method"`
	KeyField    pgtype.Text `db:"key_field" json:"key_field"`
	VectorSize  int32       `db:"vector_size" json:"vector_size"`
}

func (q *Queries) UpsertAPI(ctx context.Context, arg UpsertAPIParams) (string, error) {
	row := q.db.QueryRow(ctx, upsertAPI,
		arg.Handle,
		arg.Description,
		arg.KeyMethod,
		arg.KeyField,
		arg.VectorSize,
	)
	var handle string
	err := row.Scan(&handle)
	return handle, err
}

const upsertEmbeddings = `-- name: UpsertEmbeddings :one
INSERT INTO embeddings (
  "id", "owner", "project", "text_id", "embedding", "embedding_dim", "llmservice", "text", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $9, NOW(), NOW()
)
ON CONFLICT ("id") DO UPDATE SET
  "text_id" = $2,
  "owner" = $3,
  "project" = $4,
  "embedding" = $5,
  "embedding_dim" = $6,
  "llmservice" = $7,
  "text" = $8,
  "updated_at" = NOW()
RETURNING "id", "text_id"
`

type UpsertEmbeddingsParams struct {
	ID           int32                  `db:"id" json:"id"`
	Owner        string                 `db:"owner" json:"owner"`
	Project      int32                  `db:"project" json:"project"`
	TextID       pgtype.Text            `db:"text_id" json:"text_id"`
	Embedding    pgvector_go.HalfVector `db:"embedding" json:"embedding"`
	EmbeddingDim int32                  `db:"embedding_dim" json:"embedding_dim"`
	Llmservice   int32                  `db:"llmservice" json:"llmservice"`
	Text         pgtype.Text            `db:"text" json:"text"`
	Text_2       pgtype.Text            `db:"text_2" json:"text_2"`
}

type UpsertEmbeddingsRow struct {
	ID     int32       `db:"id" json:"id"`
	TextID pgtype.Text `db:"text_id" json:"text_id"`
}

// TODO: Add metadata field
func (q *Queries) UpsertEmbeddings(ctx context.Context, arg UpsertEmbeddingsParams) (UpsertEmbeddingsRow, error) {
	row := q.db.QueryRow(ctx, upsertEmbeddings,
		arg.ID,
		arg.Owner,
		arg.Project,
		arg.TextID,
		arg.Embedding,
		arg.EmbeddingDim,
		arg.Llmservice,
		arg.Text,
		arg.Text_2,
	)
	var i UpsertEmbeddingsRow
	err := row.Scan(&i.ID, &i.TextID)
	return i, err
}

const upsertLLM = `-- name: UpsertLLM :one



INSERT INTO instances (
  "handle", "owner", "description", "endpoint", "api_key", "api_standard", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, $5, $6, NOW(), NOW()
)
ON CONFLICT ("handle", "owner") DO UPDATE SET
  "description" = $3,
  "endpoint" = $4,
  "api_key" = $5,
  "api_standard" = $6,
  "updated_at" = NOW()
RETURNING "llmservice_id", "handle", "owner"
`

type UpsertLLMParams struct {
	Handle      string      `db:"handle" json:"handle"`
	Owner       string      `db:"owner" json:"owner"`
	Description pgtype.Text `db:"description" json:"description"`
	Endpoint    string      `db:"endpoint" json:"endpoint"`
	ApiKey      pgtype.Text `db:"api_key" json:"api_key"`
	ApiStandard string      `db:"api_standard" json:"api_standard"`
}

type UpsertLLMRow struct {
	LlmserviceID int32  `db:"llmservice_id" json:"llmservice_id"`
	Handle       string `db:"handle" json:"handle"`
	Owner        string `db:"owner" json:"owner"`
}

// TODO: name: TransferProject :one
func (q *Queries) UpsertLLM(ctx context.Context, arg UpsertLLMParams) (UpsertLLMRow, error) {
	row := q.db.QueryRow(ctx, upsertLLM,
		arg.Handle,
		arg.Owner,
		arg.Description,
		arg.Endpoint,
		arg.ApiKey,
		arg.ApiStandard,
	)
	var i UpsertLLMRow
	err := row.Scan(&i.LlmserviceID, &i.Handle, &i.Owner)
	return i, err
}

const upsertProject = `-- name: UpsertProject :one
INSERT INTO projects (
  "handle", "owner", "description", "metadata_scheme", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("handle", "owner") DO UPDATE SET
  "description" = $3,
  "metadata_scheme" = $4,
  "updated_at" = NOW()
RETURNING "project_id", "handle", "owner"
`

type UpsertProjectParams struct {
	Handle         string      `db:"handle" json:"handle"`
	Owner          string      `db:"owner" json:"owner"`
	Description    pgtype.Text `db:"description" json:"description"`
	MetadataScheme pgtype.Text `db:"metadata_scheme" json:"metadata_scheme"`
}

type UpsertProjectRow struct {
	ProjectID int32  `db:"project_id" json:"project_id"`
	Handle    string `db:"handle" json:"handle"`
	Owner     string `db:"owner" json:"owner"`
}

func (q *Queries) UpsertProject(ctx context.Context, arg UpsertProjectParams) (UpsertProjectRow, error) {
	row := q.db.QueryRow(ctx, upsertProject,
		arg.Handle,
		arg.Owner,
		arg.Description,
		arg.MetadataScheme,
	)
	var i UpsertProjectRow
	err := row.Scan(&i.ProjectID, &i.Handle, &i.Owner)
	return i, err
}

const upsertUser = `-- name: UpsertUser :one

INSERT INTO users (
  "handle", "name", "email", "vdb_key", "created_at", "updated_at"
) VALUES (
  $1, $2, $3, $4, NOW(), NOW()
)
ON CONFLICT ("handle") DO UPDATE SET
  "name" = $2,
  "email" = $3,
  "vdb_key" = $4,
  "updated_at" = NOW()
RETURNING handle, name, email, vdb_key, created_at, updated_at
`

type UpsertUserParams struct {
	Handle    string      `db:"handle" json:"handle"`
	Name      pgtype.Text `db:"name" json:"name"`
	Email     string      `db:"email" json:"email"`
	VDBKey string      `db:"vdb_key" json:"vdb_key"`
}

// Generate go code with: sqlc generate
func (q *Queries) UpsertUser(ctx context.Context, arg UpsertUserParams) (User, error) {
	row := q.db.QueryRow(ctx, upsertUser,
		arg.Handle,
		arg.Name,
		arg.Email,
		arg.VDBKey,
	)
	var i User
	err := row.Scan(
		&i.Handle,
		&i.Name,
		&i.Email,
		&i.VDBKey,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
</file>

<file path="internal/handlers/embeddings_test.go">
package handlers_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strconv"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestEmbeddingsFunc(t *testing.T) {
	// Get the database connection pool from package variable
	pool := connPool

	// Create a mock key generator
	mockKeyGen := new(MockKeyGen)
	// Set up expectations for the mock key generator
	mockKeyGen.On("RandomKey", 64).Return("12345678901234567890123456789012", nil)

	// Start the server
	err, shutDownServer := startTestServer(t, pool, mockKeyGen)
	assert.NoError(t, err)

	// Create user to be used in project tests
	aliceJSON := `{"handle": "alice", "name": "Alice Doe", "email": "alice@foo.bar"}`
	fmt.Print("    Creating user (alice) for testing ...\n")
	aliceAPIKey, err := createUser(t, aliceJSON)
	assert.NoError(t, err)

	// Create project to be used in embedding tests
	projectJSON := `{"handle": "test1", "description": "A test project"}`
	fmt.Print("    Creating project (test1) for testing ...\n")
	projectID, err := createProject(t, projectJSON, "alice", aliceAPIKey)
	assert.NoError(t, err)
	fmt.Printf("    Project ID: %s\n", strconv.Itoa(projectID))

	// Define test cases
	tt := []struct {
		name         string
		method       string
		requestPath  string
		bodyPath     string
		apiKeyHeader string
		expectBody   string
		expectStatus int16
	}{
		{
			name:         "Valid get all embeddings",
			method:       http.MethodGet,
			requestPath:  "/embeddings/alice/test1",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"no embeddings found.\"\n}\n",
			expectStatus: 404,
		},
	}

	for _, v := range tt {
		t.Run(v.name, func(t *testing.T) {

			// We need to handle the body only for PUT and POST requests
			// For GET and DELETE requests, the body is nil
			reqBody := io.Reader(nil)
			if v.method == http.MethodGet || v.method == http.MethodDelete {
				reqBody = nil
			} else {
				f, err := os.Open(v.bodyPath)
				assert.NoError(t, err)
				defer func() {
					if err := f.Close(); err != nil {
						t.Fatal(err)
					}
				}()
				b := new(bytes.Buffer)
				_, err = io.Copy(b, f)
				assert.NoError(t, err)
				reqBody = bytes.NewReader(b.Bytes())
			}
			requestURL := fmt.Sprintf("http://%v:%d%v", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(v.method, requestURL, reqBody)
			assert.NoError(t, err)
			req.Header.Add("Authorization", "Bearer "+v.apiKeyHeader)
			resp, err := http.DefaultClient.Do(req)
			if err != nil {
				t.Errorf("Error sending request: %v\n", err)
			}
			assert.NoError(t, err)
			defer resp.Body.Close()

			if resp.StatusCode != int(v.expectStatus) {
				t.Errorf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			} else {
				t.Logf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			}

			respBody, err := io.ReadAll(resp.Body) // response body is []byte
			assert.NoError(t, err)
			formattedResp := ""
			if v.expectBody != "" {
				if respBody == nil {
					t.Errorf("Expected body %s, got nil\n", v.expectBody)
				} else {
					fr := new(bytes.Buffer)
					if isJSON(string(respBody)) && (strings.Contains(string(respBody), "{") || strings.Contains(string(respBody), "[")) {
						err = json.Indent(fr, respBody, "", "  ")
						// fmt.Printf("Error: %v\nresponse: %v\n", err, string(respBody))
						assert.NoError(t, err)
						formattedResp = fr.String()
					} else {
						formattedResp = string(respBody)
					}
				}
			}
			// if (resp.StatusCode != http.StatusOK) || (resp.StatusCode != int(v.expectStatus)) {
			assert.Equal(t, v.expectBody, formattedResp, "they should be equal")
			// }
		})
	}

	// Verify that the expectations regarding the mock key generation were met
	mockKeyGen.AssertExpectations(t)

	// Cleanup removes items created by the put function test
	// (deleting '/users/alice' should delete all the projects and embeddings connected
	//  to alice as well)
	t.Cleanup(func() {
		tt := []struct {
			name        string
			requestPath string
		}{
			{
				name:        "clean up alice",
				requestPath: "/users/alice",
			},
		}

		for _, v := range tt {
			fmt.Printf("Running cleanup: %s\n", v.name)
			requestURL := fmt.Sprintf("http://%s:%d%s", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(http.MethodDelete, requestURL, nil)
			assert.NoError(t, err)
			_, err = http.DefaultClient.Do(req)
			if err != nil && err.Error() != "no rows in result set" {
				t.Fatalf("Error sending request: %v\n", err)
			}
			assert.NoError(t, err)
		}
		fmt.Print("Shutting down server\n")
		shutDownServer()
	})

}
</file>

<file path="internal/handlers/embeddings.go">
package handlers

import (
	"context"
	"fmt"
	"net/http"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Get user and project
func getUserProj(ctx context.Context, user, project string) (string, int32, error) {
	// Check if user and project exist
	u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: user})
	if err != nil {
		return "", 0, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", user))
	} else if u.Body.Handle != user {
		return "", 0, huma.Error404NotFound(fmt.Sprintf("user %s not found", user))
	}
	p, err := getProjectFunc(ctx, &models.GetProjectRequest{User: user, Project: project})
	if err != nil {
		return "", 0, huma.Error500InternalServerError(fmt.Sprintf("unable to get %s's project %s", user, project))
	} else if p.Body.Project.Handle != project {
		return "", 0, huma.Error404NotFound(fmt.Sprintf("%s's project %s not found", user, project))
	}
	return u.Body.Handle, int32(p.Body.Project.Id), nil
}

// Create a new embeddings
func postProjEmbeddingsFunc(ctx context.Context, input *models.PostProjEmbeddingsRequest) (*models.UploadProjEmbeddingsResponse, error) {
	if len(input.Body.Embeddings) == 0 {
		return nil, huma.Error400BadRequest("nothing to do, because len(embeddings) == 0.")
	}

	// Check if user and project exist
	u, p, err := getUserProj(ctx, input.User, input.Project)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
	} else if u != input.User {
		return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
	} else if p == 0 {
		return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found", input.Project))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// For each embedding, build query parameters and run the query
	ids := []string{}
	queries := database.New(pool)
	for _, embedding := range input.Body.Embeddings {
		// Build query parameters (embeddings)
		params := database.UpsertEmbeddingsParams{
			Owner:        u,
			Project:      p,
			TextID:       pgtype.Text{String: embedding.TextID, Valid: true},
			Embedding:    embedding.Vector,
			EmbeddingDim: embedding.VectorDim,
			Llmservice:   embedding.Llmservice,
			Text:         pgtype.Text{String: embedding.Text, Valid: true},
			// TODO: add metadata handling
			// Metadata: embedding.Metadata,
		}
		// Run the queries (upload embeddings)
		result, err := queries.UpsertEmbeddings(ctx, params)
		if err != nil {
			return nil, huma.Error500InternalServerError("unable to upload embeddings")
		}
		ids = append(ids, result.TextID.String)
	}

	// Build response
	response := &models.UploadProjEmbeddingsResponse{}
	response.Body.IDs = ids
	return response, nil
}

func getProjEmbeddingsFunc(ctx context.Context, input *models.GetProjEmbeddingsRequest) (*models.GetProjEmbeddingsResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.User)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.User, err))
	}
	user := input.User

	// Check if project exists
	p, err := queries.RetrieveProject(ctx, database.RetrieveProjectParams{Owner: input.User, Handle: input.Project})
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found for user %s", input.Project, input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if project %s exists before deleting. %v", input.Project, err))
	}
	project := p.ProjectID

	// Build query parameters (embeddings)
	params := database.GetEmbeddingsByProjectParams{
		Owner:   user,
		Project: project,
		Limit:   int32(input.Limit),
		Offset:  int32(input.Offset),
	}

	// Run the query
	embeddings, err := queries.GetEmbeddingsByProject(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError("unable to get embeddings")
	}
	if len(embeddings) == 0 {
		return nil, huma.Error404NotFound("no embeddings found.")
	}

	// Build the response
	e := []models.Embeddings{}
	for _, embedding := range embeddings {
		e = append(e, models.Embeddings{
			TextID:     embedding.TextID.String,
			Vector:     embedding.Embedding,
			VectorDim:  embedding.EmbeddingDim,
			Llmservice: embedding.Llmservice,
			Text:       embedding.Text.String,
		})
	}
	response := &models.GetProjEmbeddingsResponse{}
	response.Body.Embeddings = e
	return response, nil
}

func deleteProjEmbeddingsFunc(ctx context.Context, input *models.DeleteProjEmbeddingsRequest) (*models.DeleteProjEmbeddingsResponse, error) {
	// Check if user and project exist
	u, p, err := getUserProj(ctx, input.User, input.Project)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
	} else if u != input.User {
		return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
	} else if p == 0 {
		return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found", input.Project))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Build query parameters (embeddings)
	params := database.DeleteEmbeddingsByProjectParams{
		Owner:   u,
		Project: p,
	}

	// Run the query
	queries := database.New(pool)
	err = queries.DeleteEmbeddingsByProject(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError("unable to delete embeddings")
	}

	// Build the response
	response := &models.DeleteProjEmbeddingsResponse{}
	response.Body = fmt.Sprintf("Successfully deleted all embeddings for %s's project %s", input.User, input.Project)

	return response, nil
}

func getDocEmbeddingsFunc(ctx context.Context, input *models.GetDocEmbeddingsRequest) (*models.GetDocEmbeddingsResponse, error) {
	// Check if user and project exist
	u, p, err := getUserProj(ctx, input.User, input.Project)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
	} else if u != input.User {
		return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
	} else if p == 0 {
		return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found", input.Project))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Build query parameters (embeddings)
	params := database.RetrieveEmbeddingsParams{
		Owner:   u,
		Project: p,
		TextID:  pgtype.Text{String: input.ID, Valid: true},
	}

	// Run the query
	queries := database.New(pool)
	embedding, err := queries.RetrieveEmbeddings(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError("unable to get embeddings")
	}
	if embedding.TextID.String == "" {
		return nil, huma.Error404NotFound("no embeddings found.")
	}

	// Build the response
	e := models.Embeddings{
		TextID:     embedding.TextID.String,
		Vector:     embedding.Embedding,
		VectorDim:  embedding.EmbeddingDim,
		Llmservice: embedding.Llmservice,
		Text:       embedding.Text.String,
	}
	response := &models.GetDocEmbeddingsResponse{}
	response.Body.Embeddings = e

	return response, nil
}

func deleteDocEmbeddingsFunc(ctx context.Context, input *models.DeleteEmbeddingsByDocIDRequest) (*models.DeleteEmbeddingsByDocIDResponse, error) {
	// Check if user and project exist
	u, p, err := getUserProj(ctx, input.User, input.Project)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
	} else if u != input.User {
		return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
	} else if p == 0 {
		return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found", input.Project))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Build query parameters (embeddings)
	params := database.DeleteEmbeddingsByDocIDParams{
		Owner:   u,
		Project: p,
		TextID:  pgtype.Text{String: input.ID, Valid: true},
	}

	// Run the query
	queries := database.New(pool)
	err = queries.DeleteEmbeddingsByDocID(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError("unable to delete embeddings")
	}

	// Build the response
	response := &models.DeleteEmbeddingsByDocIDResponse{}
	response.Body = fmt.Sprintf("Successfully deleted embeddings for document %s (%s's project %s)", input.ID, input.User, input.Project)
	return response, nil
}

// RegisterEmbeddingsRoutes registers all the embeddings routes with the API
func RegisterEmbeddingsRoutes(pool *pgxpool.Pool, api huma.API) error {
	// Define huma.Operations for each route
	postProjEmbeddingsOp := huma.Operation{
		OperationID: "postEmbeddings",
		Method:      http.MethodPost,
		Path:        "/embeddings/{user}/{project}",
		Summary:     "Create embeddings for a project",
		Tags:        []string{"embeddings"},
	}
	getProjEmbeddingsOp := huma.Operation{
		OperationID: "getEmbeddings",
		Method:      http.MethodGet,
		Path:        "/embeddings/{user}/{project}",
		Summary:     "Get all embeddings for a project",
		Tags:        []string{"embeddings"},
	}
	deleteProjEmbeddingsOp := huma.Operation{
		OperationID: "deleteEmbeddings",
		Method:      http.MethodDelete,
		Path:        "/embeddings/{user}/{project}",
		Summary:     "Delete all embeddings for a project",
		Tags:        []string{"embeddings"},
	}
	getDocEmbeddingsOp := huma.Operation{
		OperationID: "getDocEmbeddings",
		Method:      http.MethodGet,
		Path:        "/embeddings/{user}/{project}/{id}",
		Summary:     "Get embeddings for a specific document",
		Tags:        []string{"embeddings"},
	}
	deleteDocEmbeddingsOp := huma.Operation{
		OperationID: "deleteDocEmbeddings",
		Method:      http.MethodDelete,
		Path:        "/embeddings/{user}/{project}/{id}",
		Summary:     "Delete embeddings for a specific document",
		Tags:        []string{"embeddings"},
	}

	// huma.Register(api, putProjEmbeddingsOp, addPoolToContext(pool, putProjEmbeddingsFunc))
	huma.Register(api, postProjEmbeddingsOp, addPoolToContext(pool, postProjEmbeddingsFunc))
	huma.Register(api, getProjEmbeddingsOp, addPoolToContext(pool, getProjEmbeddingsFunc))
	huma.Register(api, deleteProjEmbeddingsOp, addPoolToContext(pool, deleteProjEmbeddingsFunc))
	huma.Register(api, getDocEmbeddingsOp, addPoolToContext(pool, getDocEmbeddingsFunc))
	huma.Register(api, deleteDocEmbeddingsOp, addPoolToContext(pool, deleteDocEmbeddingsFunc))
	return nil
}
</file>

<file path="internal/handlers/handlers_test.go">
package handlers_test

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net"
	"net/http"
	"net/http/httptest"
	"os"
	"path/filepath"
	"strings"
	"testing"
	"time"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/handlers"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	huma "github.com/danielgtaylor/huma/v2"
	"github.com/danielgtaylor/huma/v2/adapters/humago"
	"github.com/danielgtaylor/huma/v2/humatest"
	"github.com/jackc/pgx/v5/pgxpool"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/testcontainers/testcontainers-go"
	"github.com/testcontainers/testcontainers-go/modules/postgres"
	"github.com/testcontainers/testcontainers-go/wait"
)

// TODO: Use values from env or config to override default options.
// TODO: Set up timeouts!

// Each package ("handlers", in this case) can have its own TestMain function.
// This function is executed before any tests in the package are run and can
// be used to set up resources needed by the tests. It can also be used to
// run setup code that should only be run once for the entire package.
// It has a signature of func TestMain(m *testing.M), where m has a single
// method Run() that runs all the tests in the package. It should call os.Exit
// with the result of m.Run() to signal the test runner whether the tests
// passed or failed.

// While there is the humago package to set up a testing API against which we
// could register our routes and run requests, we use an actual API connecting
// to a real database. We still can choose between a live postgres database and
// a testcontainer spun up just for testing.

var (
	options = models.Options{
		Debug:      true,
		Host:       "localhost",
		Port:       8080,
		DBHost:     "localhost",
		DBName:     "testdb",
		DBUser:     "test",
		DBPassword: "test",
	}
	connPool *pgxpool.Pool
	teardown func()
)

// TestMain function initializes the database container.
// Then it runs all the tests. Setup of api, router and server
// is done in the tests themselves to provide better isolation.
func TestMain(m *testing.M) {
	// Get a database connection pool
	var err error
	connPool, err, teardown = getTestDatabase()
	if err != nil {
		fmt.Printf("Unable to get database connection pool: %v", err)
		teardown()
		os.Exit(1)
	}
	if connPool == nil {
		fmt.Print("Database connection pool is nil")
		teardown()
		os.Exit(1)
	}
	defer connPool.Close()
	defer teardown()
	fmt.Print("\n    Database ready\n    Running tests ...\n\n")

	// Run the tests
	code := m.Run() // Execute all the tests

	os.Exit(code)
}

// --- Helper functions and types ---

// GetTestDatabase spins up a new Postgres container and returns
// a connection pool, an error value and a closure.
// Please always make sure to call the closure as it is the teardown
// function terminating the container.
func getTestDatabase() (*pgxpool.Pool, error, func()) {
	ctx := context.Background()

	// 1. Run PostgreSQL container
	pgVectorContainer, err := postgres.Run(ctx,
		// "pgvector/pgvector:pg16",
		"pgvector/pgvector:0.7.4-pg16",
		postgres.WithDatabase(options.DBName),
		postgres.WithUsername(options.DBUser),
		postgres.WithPassword(options.DBPassword),
		postgres.WithInitScripts(filepath.Join("..", "..", "testdata", "postgres", "enable-vector.sql")),
		testcontainers.WithWaitStrategy(
			// First, we wait for the container to log readiness twice.
			// This is because it will restart itself after the first startup.
			wait.ForLog("database system is ready to accept connections").WithOccurrence(2).WithStartupTimeout(120*time.Second),
			// Then, we wait for docker to actually serve the port on localhost.
			// For non-linux OSes like Mac and Windows, Docker or Rancher Desktop will have to start a separate proxy.
			// Without this, the tests will be flaky on those OSes!
			wait.ForListeningPort("5432/tcp").WithStartupTimeout(120*time.Second),
		),
	)
	if err != nil {
		fmt.Printf("Error creating container: %v\n", err)
		return nil, err, nil
	}
	connStr, err := pgVectorContainer.ConnectionString(ctx, "sslmode=disable")
	if err != nil {
		fmt.Printf("Error reading connection string: %v\n", err)
		return nil, err, nil
	}

	// 2. Connect to db
	connPool, err := pgxpool.New(context.Background(), connStr)
	if err != nil {
		fmt.Printf("Error creating connection pool: %v\n", err)
		return nil, err, nil
	}
	err = connPool.Ping(context.Background())
	if err != nil {
		fmt.Printf("Error pinging connection pool: %v\n", err)
		return nil, err, nil
	}
	fmt.Printf("Connection pool of database %v/%v established.\n", options.DBHost, options.DBName)

	// 3. Prepare test database
	err = database.VerifySchema(ctx, connStr)
	if err != nil {
		fmt.Printf("Error preparing test database: %v\n", err)
		return nil, err, nil
	}

	return connPool, nil, func() {
		err := pgVectorContainer.Terminate(context.Background())
		if err != nil {
			fmt.Printf("Error terminating container: %v\n", err)
		}
	}
}

// setupServer sets up server, router and API for testing.
// It returns an error value and a closure function that
// should be called to clean up.
// It is supposed to be called from the various tests.
func startTestServer(t *testing.T, pool *pgxpool.Pool, keyGen handlers.RandomKeyGenerator) (error, func()) {
	/* Use transactions to isolate tests from each other.

	   // Get a database connection
	   conn, err := pool.Acquire(context.Background())
	   if err != nil {
	       t.Fatal(err)
	   }

	   // Start a transaction
	   _, err = conn.Exec(context.Background(), "BEGIN")
	   if err != nil {
	       t.Fatal(err)
	   }
	*/

	// Create a new router & API
	router := http.NewServeMux()
	api := humago.New(router, huma.DefaultConfig("DHaMPS Vector Database API", "0.0.1"))
	err := handlers.AddRoutes(pool, keyGen, api)
	if err != nil {
		fmt.Printf("Unable to add routes to API: %v", err)
		return err, func() {}
	}
	fmt.Print("    Router ready\n")

	/* HTTP Server setup (we set up httptest.Server below instead)
	   // Create the HTTP server
	   server := &http.Server{
	     Addr:    fmt.Sprintf("%s:%d", options.Host, options.Port),
	     Handler: router,
	   }
	   // Start the server
	   go func() {
	     if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
	       fmt.Printf("Unable to start server: %v", err)
	       server.Close()    // Close the server
	       connPool.Close()  // Close the database connection
	       teardown()
	       os.Exit(1)
	     }
	   }()
	   time.Sleep(1 * time.Second) // Wait for the server to start
	*/

	// For testing, we use a httptest.Server instead of a real server.
	// Running this on our custom port requires setting up a listener...
	// create a listener with the desired port.
	l, err := net.Listen("tcp", fmt.Sprintf("%s:%d", options.Host, options.Port))
	assert.NoError(t, err)
	if err != nil {
		fmt.Printf("Error setting up listener: %v", err)
		return err, func() {}
	}
	// Create a new server with the router.
	server := httptest.NewUnstartedServer(router)
	// NewUnstartedServer creates a server-cum-listener.
	// Close that listener and replace with the one we created.
	server.Listener.Close()
	server.Listener = l
	// Start the server.
	server.Start()
	fmt.Printf("    Server listening on %s:%d\n", options.Host, options.Port)

	cleanup := func() {
		// Close the server
		server.Close()
		/* Clean up transactions.
		   _, err := conn.Exec(context.Background(), "ROLLBACK")
		   if err != nil {
		       t.Fatal(err)
		   }
		   conn.Release()
		*/
	}

	return nil, cleanup
}

// MockKeyGen is a mock implementation of the RandomKeyGenerator interface.
type MockKeyGen struct{ mock.Mock }

// Implement mock's randomKey method
func (m *MockKeyGen) RandomKey(len int) (string, error) {
	args := m.Called(len)
	return args.String(0), args.Error(1)
}

// createUser creates a user and returns the API key and an error value
// it accepts a JSON string encoding the user object as input
func createUser(t *testing.T, userJSON string) (string, error) {
	requestURL := fmt.Sprintf("http://%s:%d/users/alice", options.Host, options.Port)
	requestBody := bytes.NewReader([]byte(userJSON))
	req, err := http.NewRequest(http.MethodPut, requestURL, requestBody)
	assert.NoError(t, err)
	resp, err := http.DefaultClient.Do(req)
	assert.NoError(t, err)
	defer resp.Body.Close()
	// get API key for user alice from response body
	body, err := io.ReadAll(resp.Body)
	assert.NoError(t, err)
	userInfo := models.UserResponse{}
	err = json.Unmarshal(body, &userInfo)
	assert.NoError(t, err)
	return userInfo.APIKey, nil
}

// createProject creates a project and returns the project ID and an error value
// it accepts a JSON string encoding the project object as input
func createProject(t *testing.T, projectJSON string, user string, apiKey string) (int, error) {
	jsonInput := &struct {
		Handle      string `json:"handle" doc:"Handle of created or updated project"`
		Description string `json:"description" doc:"Description of the project"`
	}{}
	err := json.Unmarshal([]byte(projectJSON), jsonInput)
	if err != nil {
		fmt.Printf("Error unmarshalling project JSON: %v\n", err)
	}
	assert.NoError(t, err)

	requestURL := fmt.Sprintf("http://%s:%d/projects/%s/%s", options.Host, options.Port, user, jsonInput.Handle)
	requestBody := bytes.NewReader([]byte(projectJSON))
	req, err := http.NewRequest(http.MethodPut, requestURL, requestBody)
	req.Header.Set("Authorization", "Bearer "+apiKey)
	assert.NoError(t, err)

	resp, err := http.DefaultClient.Do(req)
	assert.NoError(t, err)
	defer resp.Body.Close()

	// get project ID from response body
	body, err := io.ReadAll(resp.Body)
	assert.NoError(t, err)

	projectInfo := &struct {
		Handle string `json:"id" doc:"Handle of created or updated project"`
		Id     int    `json:"project_id" doc:"Unique project identifier"`
	}{}
	err = json.Unmarshal(body, &projectInfo)
	if err != nil {
		fmt.Printf("Error unmarshalling project info: %v\nbody: %v", err, string(body))
	}
	assert.NoError(t, err)

	return projectInfo.Id, nil
}

// isJSON checks if a string is a valid JSON.
func isJSON(str string) bool {
	var js json.RawMessage
	return json.Unmarshal([]byte(str), &js) == nil
}

// --- After setup, here come some actual tests ---

func TestMyAPI(t *testing.T) {
	t.Skip("skipping TestMyAPI")
	// Get a database connection pool
	connPool, err, teardown := getTestDatabase()
	if err != nil {
		fmt.Printf("Unable to get database connection pool: %v", err)
		teardown()
		os.Exit(1)
	}
	if connPool == nil {
		fmt.Print("Database connection pool is nil")
		teardown()
		os.Exit(1)
	}
	defer connPool.Close()
	defer teardown()
	fmt.Print("\n    Database ready\n")

	// Create a mock key generator
	mockKeyGen := new(MockKeyGen)
	// Set up expectations for the mock key generator
	mockKeyGen.On("randomKey", 32).Return("abcdefabcdefabcd", nil)

	_, api := humatest.New(t)

	// Register routes...
	err = handlers.AddRoutes(connPool, mockKeyGen, api)
	assert.NoError(t, err)

	// Make a GET request
	resp := api.Get("/some/path?foo=bar")
	if resp.Code != http.StatusOK {
		t.Errorf("Unexpected status code %v", resp.Code)
	}

	// Make a PUT request
	resp = api.Put("/some/path",
		"My-Header: abc123",
		map[string]any{
			"author": "daniel",
			"rating": 5,
		})
	if resp.Code != http.StatusOK {
		t.Errorf("Unexpected status code %v", resp.Code)
	}

	if !strings.Contains(resp.Body.String(), "some text") {
		t.Errorf("Unexpected response body %v", resp.Body.String())
	}

	// Verify that the expectations regarding the mock key generation were met
	mockKeyGen.AssertExpectations(t)
}
</file>

<file path="internal/handlers/handlers.go">
package handlers

import (
	"context"
	"crypto/rand"
	"encoding/hex"
	"errors"
	"fmt"
	"net/http"

	"github.com/jackc/pgx/v5/pgxpool"

	huma "github.com/danielgtaylor/huma/v2"
)

type contextKey string

const (
  PoolKey = contextKey("dbPool")
  KeyGenKey = contextKey("keyGen")
)

// Error responses
var (
  ErrPoolNotFound = errors.New("database connection pool not found in context")
  ErrKeyGenNotFound = errors.New("key generator not found in context")
)

// The type definitions and functions that follow are used to
// mock the crypto/rand.Read function for testing purposes.
type RandomKeyGenerator interface {
  RandomKey(len int) (key string, err error)
}

type StandardKeyGen struct{}

func (s StandardKeyGen) RandomKey(len int) (string, error) {
  b := make([]byte, len)
  _, err := rand.Read(b)
  if err != nil {
    return "", err
  }
  return hex.EncodeToString(b), nil
}

// AddRoutes adds all the routes to the API
func AddRoutes(pool *pgxpool.Pool, keyGen RandomKeyGenerator, api huma.API) error {
  err := RegisterUsersRoutes(pool, keyGen, api)
  if err != nil {
    fmt.Printf("    Unable to register Users routes: %v\n", err)
    return err
  }
  err = RegisterProjectsRoutes(pool, api)
  if err != nil {
    fmt.Printf("    Unable to register Projects routes: %v\n", err)
    return err
  }
  err = RegisterEmbeddingsRoutes(pool, api)
  if err != nil {
    fmt.Printf("    Unable to register Embeddings routes: %v\n", err)
    return err
  }
  // err = handlers.RegisterSimilarRoutes(pool, api)
  // err = handlers.RegisterLLMProcessRoutes(pool, api)
  return nil
}

// Middleware to add the connection pool to the context
func addPoolToContext[I any, O any](pool *pgxpool.Pool, next func(context.Context, *I) (*O, error)) func(context.Context, *I) (*O, error) {
  return func(ctx context.Context, input *I) (*O, error) {
    if pool == nil {
      return nil, fmt.Errorf("provided pool is nil")
    }
    ctx = context.WithValue(ctx, PoolKey, pool)
    return next(ctx, input)
  }
}

// Middleware to add the key generator to the context
func addKeyGenToContext[I any, O any](keyGen RandomKeyGenerator, next func(context.Context, *I) (*O, error)) func(context.Context, *I) (*O, error) {
  return func(ctx context.Context, input *I) (*O, error) {
    if keyGen == nil {
      return nil, fmt.Errorf("provided keyGen is nil")
    }
    ctx = context.WithValue(ctx, KeyGenKey, keyGen)
    return next(ctx, input)
  }
}

// Get the database connection pool from the context
// (exported helper function so that blackbox testing can access it)
func GetDBPool(ctx context.Context) (*pgxpool.Pool, error) {
  pool, ok := ctx.Value(PoolKey).(*pgxpool.Pool)
  if !ok {
      return nil, huma.NewError(http.StatusInternalServerError, ErrPoolNotFound.Error())
  }
  return pool, nil
}

// Get the key generator from the context
// (exported helper function so that blackbox testing can access it)
func GetKeyGen(ctx context.Context) (RandomKeyGenerator, error) {
  keyGen, ok := ctx.Value(KeyGenKey).(RandomKeyGenerator)
  if !ok {
      return nil, huma.NewError(http.StatusInternalServerError, ErrKeyGenNotFound.Error())
  }
  return keyGen, nil
}
</file>

<file path="internal/handlers/llm_process.go">
package handlers

import (
  "context"
  "net/http"

  "github.com/mpilhlt/dhamps-vdb/internal/models"

  "github.com/danielgtaylor/huma/v2"
)

// Define handler functions for each route
func postLLMProcessFunc(ctx context.Context, input *models.LLMProcessRequest) (*models.LLMProcessResponse, error) {
  // Implement your logic here
  return nil, nil
}

// RegisterLLMProcessRoutes registers the routes for the LLMProcess service
func RegisterLLMProcessRoutes(api huma.API) {
  // Define huma.Operations for each route
  postLLMProcessOp := huma.Operation{
    OperationID: "postLLMProcess",
    Method:      http.MethodPost,
    Path:        "/llm-process",
    Summary:     "Process text with LLM service",
    Tags:        []string{"llm-process"},
  }

  huma.Register(api, postLLMProcessOp, postLLMProcessFunc)
}
</file>

<file path="internal/handlers/llm_service.go">
package handlers

import (
	"context"
	"fmt"
	"net/http"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Create a new llm service
func postLLMFunc(ctx context.Context, input *models.PostLLMRequest) (*models.UploadLLMResponse, error) {
  // Check if user exists
  if u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: input.User}) ; u.Body.Handle != input.User {
    return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
  }

  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Run the query
  queries := database.New(pool)
  llm, err := queries.UpsertLLM(ctx, database.UpsertLLMParams{
    Owner: input.User,
    Handle: input.Body.LLMService.Handle,
    Endpoint: input.Body.LLMService.Endpoint,
    ApiKey: pgtype.Text{ String: input.Body.LLMService.APIKey, Valid: true },
    ApiStandard: input.Body.LLMService.ApiStandard,
  })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to upload llm service")
  }
  // Add llm service to user
  err = queries.LinkUserToLLM(ctx, database.LinkUserToLLMParams{ User: input.User, Llmservice: llm.LlmserviceID })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to link llm service to user")
  }

  // Build response
  response := &models.UploadLLMResponse{}
  response.Body.Handle = llm.Handle

  return response, nil
}

func putLLMFunc(ctx context.Context, input *models.PutLLMRequest) (*models.UploadLLMResponse, error) {
  // Check if user exists
  if u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: input.User}) ; u.Body.Handle != input.User {
    return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
  }

  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Run the query
  queries := database.New(pool)
  llm, err := queries.UpsertLLM(ctx, database.UpsertLLMParams{
    Owner: input.User,
    Handle: input.Handle,
    Endpoint: input.Body.LLMService.Endpoint,
    ApiKey: pgtype.Text{ String: input.Body.LLMService.APIKey, Valid: true },
    ApiStandard: input.Body.LLMService.ApiStandard,
  })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to upload llm service")
  }
  // Add llm service to user
  err = queries.LinkUserToLLM(ctx, database.LinkUserToLLMParams{ User: input.User, Llmservice: llm.LlmserviceID })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to link llm service to user")
  }

  // Build response
  response := &models.UploadLLMResponse{}
  response.Body.Handle = llm.Handle

  return response, nil
}

func getLLMFunc(ctx context.Context, input *models.GetLLMRequest) (*models.GetLLMResponse, error) {
  // Check if user exists
  if u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: input.User}) ; u.Body.Handle != input.User {
    return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
  }

  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Run the query
  queries := database.New(pool)
  llm, err := queries.RetrieveLLM(ctx, database.RetrieveLLMParams{ Owner: input.User, Handle: input.Handle })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to retrieve embeddings")
  }
  if llm.Handle != input.Handle {
    return nil, huma.Error404NotFound(fmt.Sprintf("embeddings for %s not found", input.Handle))
  }

  // Build response
  ls := models.LLMService{
    Handle: llm.Handle,
    Endpoint: llm.Endpoint,
    APIKey: llm.ApiKey.String,
    ApiStandard: llm.ApiStandard,
  }
  response := &models.GetLLMResponse{}
  response.Body.LLMService = ls

  return response, nil
}

func getUserLLMsFunc(ctx context.Context, input *models.GetUserLLMsRequest) (*models.GetUserLLMsResponse, error) {
  // Check if user exists
  if u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: input.User}) ; u.Body.Handle != input.User {
    return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
  }

  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Run the query
  queries := database.New(pool)
  llm, err := queries.GetLLMsByUser(ctx, database.GetLLMsByUserParams{ UserHandle: input.User, Limit: int32(input.Limit), Offset: int32(input.Offset) })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to retrieve embeddings")
  }
  if len(llm) == 0 {
    return nil, huma.Error404NotFound(fmt.Sprintf("no llm services for %s found", input.User))
  }

  // Build response
  ls := []models.LLMService{}
  for _, l := range llm {
    ls = append(ls, models.LLMService{
      Handle: l.Handle,
      Endpoint: l.Endpoint,
      APIKey: l.ApiKey.String,
      ApiStandard: l.ApiStandard,
    })
  }
  response := &models.GetUserLLMsResponse{}
  response.Body.LLMServices = ls

  return response, nil
}

func deleteLLMFunc(ctx context.Context, input *models.DeleteLLMRequest) (*models.DeleteLLMResponse, error) {
  // Check if user exists
  if u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: input.User}) ; u.Body.Handle != input.User {
    return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", input.User))
  }
  // Check if llm service exists
  if llm, err := getLLMFunc(ctx, &models.GetLLMRequest{User: input.User, Handle: input.Handle}) ; llm.Body.LLMService.Handle != input.Handle {
    return nil, huma.Error404NotFound(fmt.Sprintf("llm service %s not found for user %s", input.Handle, input.User))
  } else if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get llm service %s for user %s", input.Handle, input.User))
  }

  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Run the query
  queries := database.New(pool)
  err = queries.DeleteLLM(ctx, database.DeleteLLMParams{ Owner: input.User, Handle: input.Handle })
  if err != nil {
    return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to delete llm service %s for user %s", input.Handle, input.User))
  }

  // Build response
  response := &models.DeleteLLMResponse{}
  response.Body.Message = fmt.Sprintf("llm service %s deleted for user %s", input.Handle, input.User)

  return response, nil
}

// RegisterLLMServiceRoutes registers the routes for the management of LLM services
func RegisterLLMServiceRoutes(pool *pgxpool.Pool, api huma.API) error {
  // Define huma.Operations for each route
  postLLMServiceOp := huma.Operation{
    OperationID: "postLLMService",
    Method:      http.MethodPost,
    Path:        "/instances/{user}",
    Summary:     "Create llm service",
    Tags:        []string{"instances"},
  }
  putLLMServiceOp := huma.Operation{
    OperationID: "putLLMService",
    Method:      http.MethodPut,
    Path:        "/instances/{user}/{handle}",
    Summary:     "Create or update llm service",
    Tags:        []string{"instances"},
  }
  getUserLLMServicesOp := huma.Operation{
    OperationID: "getUserLLMServices",
    Method:      http.MethodGet,
    Path:        "/instances/{user}",
    Summary:     "Get all llm services for a user",
    Tags:        []string{"instances"},
  }
  getLLMServiceOp := huma.Operation{
    OperationID: "getLLMService",
    Method:      http.MethodGet,
    Path:        "/instances/{user}/{handle}",
    Summary:     "Get a specific llm service for a user",
    Tags:        []string{"instances"},
  }
  deleteLLMServiceOp := huma.Operation{
    OperationID: "deleteLLMService",
    Method:      http.MethodDelete,
    Path:        "/instances/{user}/{handle}",
    Summary:     "Delete all embeddings for a user",
    Tags:        []string{"instances"},
  }

  huma.Register(api, postLLMServiceOp, addPoolToContext(pool, postLLMFunc))
  huma.Register(api, putLLMServiceOp, addPoolToContext(pool, putLLMFunc))
  huma.Register(api, getUserLLMServicesOp, addPoolToContext(pool, getUserLLMsFunc))
  huma.Register(api, getLLMServiceOp, addPoolToContext(pool, getLLMFunc))
  huma.Register(api, deleteLLMServiceOp, addPoolToContext(pool, deleteLLMFunc))
  return nil
}
</file>

<file path="internal/handlers/projects_test.go">
package handlers_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestProjectFunc(t *testing.T) {
	// Get the database connection pool from package variable
	pool := connPool

	// Create a mock key generator
	mockKeyGen := new(MockKeyGen)
	// Set up expectations for the mock key generator
	mockKeyGen.On("RandomKey", 64).Return("12345678901234567890123456789012", nil)

	// Start the server
	err, shutDownServer := startTestServer(t, pool, mockKeyGen)
	assert.NoError(t, err)

	// Create user to be used in project tests
	aliceJSON := `{"handle": "alice", "name": "Alice Doe", "email": "alice@foo.bar"}`
	fmt.Print("    Creating user (alice) for testing ...\n")
	aliceAPIKey, err := createUser(t, aliceJSON)
	assert.NoError(t, err)

	// Define test cases
	tt := []struct {
		name         string
		method       string
		requestPath  string
		bodyPath     string
		apiKeyHeader string
		expectBody   string
		expectStatus int16
	}{
		{
			name:         "Valid get all projects, no projects present",
			method:       http.MethodGet,
			requestPath:  "/projects/alice",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/GetProjectsResponseBody.json\",\n  \"projects\": []\n}\n",
			expectStatus: 200,
		},
		{
			name:         "Put project, valid json",
			method:       http.MethodPut,
			requestPath:  "/projects/alice/test1",
			bodyPath:     "../../testdata/valid_project.json",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/UploadProjectResponseBody.json\",\n  \"id\": \"test1\",\n  \"project_id\": 0\n}\n",
			expectStatus: 201,
		},
		{
			name:         "Put project, invalid json",
			method:       http.MethodPut,
			requestPath:  "/projects/alice/test2",
			bodyPath:     "../../testdata/invalid_project.json",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Unprocessable Entity\",\n  \"status\": 422,\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"message\": \"expected required property handle to be present\",\n      \"location\": \"body\",\n      \"value\": {\n        \"description\": \"This is a test project\",\n        \"foo\": \"test1\"\n      }\n    },\n    {\n      \"message\": \"unexpected property\",\n      \"location\": \"body.foo\",\n      \"value\": {\n        \"description\": \"This is a test project\",\n        \"foo\": \"test1\"\n      }\n    }\n  ]\n}\n",
			expectStatus: 422,
		},
		{
			name:         "Put project, valid json but invalid project handle",
			method:       http.MethodPut,
			requestPath:  "/projects/alice/test3",
			bodyPath:     "../../testdata/valid_project.json",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"project handle in URL (test3) does not match project handle in body (test1)\"\n}\n",
			expectStatus: 400,
		},
		{
			name:         "Post project, valid json",
			method:       http.MethodPost,
			requestPath:  "/projects/alice",
			bodyPath:     "../../testdata/valid_project.json",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/UploadProjectResponseBody.json\",\n  \"id\": \"test1\",\n  \"project_id\": 0\n}\n",
			expectStatus: 201,
		},
		{
			name:         "Post project, invalid json",
			method:       http.MethodPost,
			requestPath:  "/projects/alice",
			bodyPath:     "../../testdata/invalid_project.json",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Unprocessable Entity\",\n  \"status\": 422,\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"message\": \"expected required property handle to be present\",\n      \"location\": \"body\",\n      \"value\": {\n        \"description\": \"This is a test project\",\n        \"foo\": \"test1\"\n      }\n    },\n    {\n      \"message\": \"unexpected property\",\n      \"location\": \"body.foo\",\n      \"value\": {\n        \"description\": \"This is a test project\",\n        \"foo\": \"test1\"\n      }\n    }\n  ]\n}\n",
			expectStatus: 422,
		},
		{
			name:         "Valid get project",
			method:       http.MethodGet,
			requestPath:  "/projects/alice/test1",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/GetProjectResponseBody.json\",\n  \"project\": {\n    \"project_id\": 0,\n    \"handle\": \"test1\",\n    \"description\": \"This is a test project\",\n    \"shared_with\": [\n      \"alice\"\n    ]\n  }\n}\n",
			expectStatus: 200,
		},
		{
			name:         "Valid get all projects",
			method:       http.MethodGet,
			requestPath:  "/projects/alice",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/GetProjectsResponseBody.json\",\n  \"projects\": [\n    {\n      \"project_id\": 2,\n      \"handle\": \"test1\",\n      \"description\": \"This is a test project\",\n      \"shared_with\": [\n        \"alice\"\n      ]\n    }\n  ]\n}\n",
			expectStatus: 200,
		},
		{
			name:         "Valid get all projects, invalid user",
			method:       http.MethodGet,
			requestPath:  "/projects/john",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"user john not found\"\n}\n",
			expectStatus: 404,
		},
		{
			name:         "Get nonexistent project",
			method:       http.MethodGet,
			requestPath:  "/projects/alice/test2",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"user alice's project test2 not found\"\n}\n",
			expectStatus: 404,
		},
		{
			name:         "Delete project",
			method:       http.MethodDelete,
			requestPath:  "/projects/alice/test1",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "",
			expectStatus: 204,
		},
		{
			name:         "Delete nonexistent project",
			method:       http.MethodDelete,
			requestPath:  "/projects/alice/test2",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"project test2 not found for user alice\"\n}\n",
			expectStatus: 404,
		},
		{
			name:         "Delete project, invalid user",
			method:       http.MethodDelete,
			requestPath:  "/projects/john/test1",
			bodyPath:     "",
			apiKeyHeader: aliceAPIKey,
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"user john not found\"\n}\n",
			expectStatus: 404,
		},
	}

	for _, v := range tt {
		t.Run(v.name, func(t *testing.T) {

			// We need to handle the body only for PUT and POST requests
			// For GET and DELETE requests, the body is nil
			reqBody := io.Reader(nil)
			if v.method == http.MethodGet || v.method == http.MethodDelete {
				reqBody = nil
			} else {
				f, err := os.Open(v.bodyPath)
				assert.NoError(t, err)
				defer func() {
					if err := f.Close(); err != nil {
						t.Fatal(err)
					}
				}()
				b := new(bytes.Buffer)
				_, err = io.Copy(b, f)
				assert.NoError(t, err)
				reqBody = bytes.NewReader(b.Bytes())
			}
			requestURL := fmt.Sprintf("http://%v:%d%v", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(v.method, requestURL, reqBody)
			assert.NoError(t, err)
			req.Header.Add("Authorization", "Bearer "+v.apiKeyHeader)
			resp, err := http.DefaultClient.Do(req)
			if err != nil {
				t.Errorf("Error sending request: %v\n", err)
			}
			assert.NoError(t, err)
			defer resp.Body.Close()

			if resp.StatusCode != int(v.expectStatus) {
				t.Errorf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			} else {
				t.Logf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			}

			respBody, err := io.ReadAll(resp.Body) // response body is []byte
			assert.NoError(t, err)
			formattedResp := ""
			if v.expectBody != "" {
				if respBody == nil {
					t.Errorf("Expected body %s, got nil\n", v.expectBody)
				} else {
					fr := new(bytes.Buffer)
					if isJSON(string(respBody)) && (strings.Contains(string(respBody), "{") || strings.Contains(string(respBody), "[")) {
						err = json.Indent(fr, respBody, "", "  ")
						// fmt.Printf("Error: %v\nresponse: %v\n", err, string(respBody))
						assert.NoError(t, err)
						formattedResp = fr.String()
					} else {
						formattedResp = string(respBody)
					}
				}
			}
			// if (resp.StatusCode != http.StatusOK) || (resp.StatusCode != int(v.expectStatus)) {
			assert.Equal(t, v.expectBody, formattedResp, "they should be equal")
			// }
		})
	}

	// Verify that the expectations regarding the mock key generation were met
	mockKeyGen.AssertExpectations(t)

	// Cleanup removes items created by the put function test
	// (deleting '/users/alice' should delete all the projects connected to alice as well)
	t.Cleanup(func() {
		tt := []struct {
			name        string
			requestPath string
		}{
			{
				name:        "clean up alice",
				requestPath: "/users/alice",
			},
		}

		for _, v := range tt {
			fmt.Printf("Running cleanup: %s\n", v.name)
			requestURL := fmt.Sprintf("http://%s:%d%s", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(http.MethodDelete, requestURL, nil)
			assert.NoError(t, err)
			_, err = http.DefaultClient.Do(req)
			if err != nil && err.Error() != "no rows in result set" {
				t.Fatalf("Error sending request: %v\n", err)
			}
			assert.NoError(t, err)
		}
		fmt.Print("Shutting down server\n")
		shutDownServer()
	})

}
</file>

<file path="internal/handlers/projects.go">
package handlers

import (
	"context"
	"fmt"
	"net/http"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// TODO: Add LLMServices fields

// Create a new project
func putProjectFunc(ctx context.Context, input *models.PutProjectRequest) (*models.UploadProjectResponse, error) {
	if input.Project != input.Body.Handle {
		return nil, huma.Error400BadRequest(fmt.Sprintf("project handle in URL (%s) does not match project handle in body (%s)", input.Project, input.Body.Handle))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	} else if pool == nil {
		return nil, huma.Error500InternalServerError("database connection pool is nil")
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.User)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.User, err))
	}

	// 1. Upload project

	// Build query parameters (project)
	readers := make(map[string]bool)
	for _, user := range input.Body.SharedWith {
		if user == "*" {
			users, err := getUsersFunc(ctx, &models.GetUsersRequest{})
			if err != nil {
				return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", user))
			}
			for _, uu := range users.Body {
				if uu != input.User {
					readers[uu] = true
				}
			}
		} else {
			u, err := getUserFunc(ctx, &models.GetUserRequest{Handle: user})
			if err != nil {
				return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user %s", user))
			}
			if u.Body.Handle != user {
				return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", user))
			}
			if user != input.User {
				readers[user] = true
			}
		}
	}

	project := database.UpsertProjectParams{
		Handle:      input.Project,
		Description: pgtype.Text{String: input.Body.Description, Valid: true},
		Owner:       input.User,
	}

	p, err := queries.UpsertProject(ctx, project)
	if err != nil {
		return nil, huma.Error500InternalServerError("unable to upload project")
	}

	// 2. Link project and owner
	params := database.LinkProjectToUserParams{ProjectID: p.ProjectID, UserHandle: input.User, Role: "owner"}
	_, err = queries.LinkProjectToUser(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to link project to owner %s", input.User))
	}

	// 3. Link project and other assigned readers
	for reader := range readers {
		params := database.LinkProjectToUserParams{ProjectID: p.ProjectID, UserHandle: reader, Role: "reader"}
		_, err := queries.LinkProjectToUser(ctx, params)
		if err != nil {
			return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to upload project reader %s", reader))
		}
		// registeredReaders = append(registeredReaders, u.UserHandle)
	}

	// 4. Build the response
	response := &models.UploadProjectResponse{}
	response.Body.Handle = p.Handle

	return response, nil
}

// Create a user (without a handle being present in the URL)
func postProjectFunc(ctx context.Context, input *models.PostProjectRequest) (*models.UploadProjectResponse, error) {
	return putProjectFunc(ctx, &models.PutProjectRequest{User: input.User, Project: input.Body.Handle, Body: input.Body})
}

// Get all projects for a specific user
func getProjectsFunc(ctx context.Context, input *models.GetProjectsRequest) (*models.GetProjectsResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.User)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.User, err))
	}

	// Run the queries
	p, err := queries.GetProjectsByUser(ctx, database.GetProjectsByUserParams{UserHandle: input.User, Limit: int32(input.Limit), Offset: int32(input.Offset)})
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("no projects found for user %s", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get projects for user %s", input.User))
	}
	projects := []models.Project{}
	// Get the authorized reader accounts for each project
	for _, project := range p {
		readers := []string{}
		rows, err := queries.GetUsersByProject(ctx, database.GetUsersByProjectParams{Owner: input.User, Handle: project.Handle, Limit: 999, Offset: 0})
		if err != nil {
			return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get readers for %s's project %s", input.User, project.Handle))
		}
		for _, row := range rows {
			readers = append(readers, row.Handle)
		}
		projects = append(projects, models.Project{
			Id:                int(project.ProjectID),
			Handle:            project.Handle,
			Description:       project.Description.String,
			SharedWith: readers,
			LLMServices:       nil,
		})
	}

	// Build the response
	response := &models.GetProjectsResponse{}
	response.Body.Projects = projects

	return response, nil
}

// Retrieve a specific project
func getProjectFunc(ctx context.Context, input *models.GetProjectRequest) (*models.GetProjectResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.User)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.User, err))
	}

	// Build the query parameters
	params := database.RetrieveProjectParams{
		Owner:  input.User,
		Handle: input.Project,
	}

	// Run the queries
	p, err := queries.RetrieveProject(ctx, params)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s's project %s not found", input.User, input.Project))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get project %s for user %s", input.Project, input.User))
	}
	// Get the authorized reader accounts for the project
	readers := []string{}
	rows, err := queries.GetUsersByProject(ctx, database.GetUsersByProjectParams{Owner: input.User, Handle: input.Project, Limit: 999, Offset: 0})
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get authorized reader accounts for %s's project %s", input.User, input.Project))
	}
	for _, row := range rows {
		readers = append(readers, row.Handle)
	}

	// Build the response
	response := &models.GetProjectResponse{}
	response.Body.Project = models.Project{
		Handle:            p.Handle,
		Description:       p.Description.String,
		MetadataScheme:    p.MetadataScheme.String,
		SharedWith: readers,
		LLMServices:       nil,
	}

	return response, nil
}

func deleteProjectFunc(ctx context.Context, input *models.DeleteProjectRequest) (*models.DeleteProjectResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.User)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.User, err))
	}

	// Check if project exists
	_, err = queries.RetrieveProject(ctx, database.RetrieveProjectParams{Owner: input.User, Handle: input.Project})
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("project %s not found for user %s", input.Project, input.User))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if project %s exists before deleting. %v", input.Project, err))
	}

	// Build the query parameters
	params := database.DeleteProjectParams{
		Owner:  input.User,
		Handle: input.Project,
	}

	// Run the query
	err = queries.DeleteProject(ctx, params)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to delete project %s for user %s", input.Project, input.User))
	}

	// Build the response
	response := &models.DeleteProjectResponse{}

	return response, nil
}

// RegisterProjectRoutes registers all the project routes with the API
func RegisterProjectsRoutes(pool *pgxpool.Pool, api huma.API) error {
	// Define huma.Operations for each route
	putProjectOp := huma.Operation{
		OperationID:   "putProject",
		Method:        http.MethodPut,
		Path:          "/projects/{user}/{project}",
		DefaultStatus: http.StatusCreated,
		Summary:       "Create or update a project",
		Tags:          []string{"admin", "projects"},
	}
	postProjectOp := huma.Operation{
		OperationID:   "postProject",
		Method:        http.MethodPost,
		Path:          "/projects/{user}",
		DefaultStatus: http.StatusCreated,
		Summary:       "Create or update a project",
		Tags:          []string{"admin", "projects"},
	}
	getProjectsOp := huma.Operation{
		OperationID: "getProjects",
		Method:      http.MethodGet,
		Path:        "/projects/{user}",
		Summary:     "Get all projects for a specific user",
		Tags:        []string{"admin", "projects"},
	}
	getProjectOp := huma.Operation{
		OperationID: "getProject",
		Method:      http.MethodGet,
		Path:        "/projects/{user}/{project}",
		Summary:     "Get a specific project",
		Tags:        []string{"admin", "projects"},
	}
	deleteProjectOp := huma.Operation{
		OperationID:   "deleteProject",
		Method:        http.MethodDelete,
		Path:          "/projects/{user}/{project}",
		DefaultStatus: http.StatusNoContent,
		Summary:       "Delete a specific project",
		Tags:          []string{"admin", "projects"},
	}

	huma.Register(api, putProjectOp, addPoolToContext(pool, putProjectFunc))
	huma.Register(api, postProjectOp, addPoolToContext(pool, postProjectFunc))
	huma.Register(api, getProjectsOp, addPoolToContext(pool, getProjectsFunc))
	huma.Register(api, getProjectOp, addPoolToContext(pool, getProjectFunc))
	huma.Register(api, deleteProjectOp, addPoolToContext(pool, deleteProjectFunc))
	return nil
}
</file>

<file path="internal/handlers/similars.go">
package handlers

import (
	"context"
	"net/http"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// Define handler functions for each route
func getSimilarFunc(ctx context.Context, input *models.GetSimilarRequest) (*models.SimilarResponse, error) {
  // Get the database connection pool from the context
  pool, err := GetDBPool(ctx)
  if err != nil {
      return nil, err
  }

  // Build query parameters

  // Run the query
  queries := database.New(pool)
  sim, err := queries.GetSimilarsByID(ctx, database.GetSimilarsByIDParams{
    // TODO: Add User and Project fields
    // User: input.User,
    // Project: pgtype.Text{ String: input.Project, Valid: true },
    TextID: pgtype.Text{ String: input.ID, Valid: true },
    Limit: min(int32(input.Limit), int32(input.Count)),
    Offset: int32(input.Offset),
  })
  if err != nil {
    return nil, huma.Error500InternalServerError("unable to get similar items")
  }
  if len(sim) == 0 {
    return nil, huma.Error404NotFound("no similar items found")
  }

  // Build response
  s := []string{}
  for _, r := range sim {
    s = append(s, r.TextID.String)
  }
  response := &models.SimilarResponse{}
  response.Body.IDs = s
  return response, nil
}

func postSimilarFunc(ctx context.Context, input *models.PostSimilarRequest) (*models.SimilarResponse, error) {
  // Implement your logic here
  return nil, nil
}

// RegisterSimilarRoutes registers the routes for the Similar service
func RegisterSimilarRoutes(pool *pgxpool.Pool, api huma.API) error {
  // Define huma.Operations for each route
  getSimilarOp := huma.Operation{
    OperationID: "getSimilar",
    Method:      http.MethodGet,
    Path:        "/similars/{user}/{project}/{id}",
    Summary:     "Retrieve similar items for a particular document",
    Tags:        []string{"similars"},
  }
  postSimilarOp := huma.Operation{
    OperationID: "postSimilar",
    Method:      http.MethodPost,
    Path:        "/similars/{user}/{project}",
    Summary:     "Retrieve similar items for a query document",
    Tags:        []string{"similars"},
  }

  huma.Register(api, getSimilarOp, addPoolToContext(pool, getSimilarFunc))
  huma.Register(api, postSimilarOp, addPoolToContext(pool, postSimilarFunc))
  return nil
}
</file>

<file path="internal/handlers/users_test.go">
package handlers_test

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestUserFunc(t *testing.T) {
	// Get the database connection pool from package variable
	pool := connPool

	// Create a mock key generator
	mockKeyGen := new(MockKeyGen)
	// Set up expectations for the mock key generator
	mockKeyGen.On("RandomKey", 64).Return("12345678901234567890123456789012", nil)

	// Start the server
	err, shutDownServer := startTestServer(t, pool, mockKeyGen)
	assert.NoError(t, err)

	tt := []struct {
		name         string
		method       string
		requestPath  string
		bodyPath     string
		expectBody   string
		expectStatus int16
	}{
		{
			name:         "Put user, valid json",
			method:       http.MethodPut,
			requestPath:  "/users/alice",
			bodyPath:     "../../testdata/valid_user.json",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/UserResponse.json\",\n  \"handle\": \"alice\",\n  \"apiKey\": \"12345678901234567890123456789012\"\n}\n",
			expectStatus: 201,
		},
		{
			name:         "Put user, invalid json",
			method:       http.MethodPut,
			requestPath:  "/users/john",
			bodyPath:     "../../testdata/invalid_user.json",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Unprocessable Entity\",\n  \"status\": 422,\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"message\": \"expected required property email to be present\",\n      \"location\": \"body\",\n      \"value\": {\n        \"handle\": \"john\",\n        \"name\": \"John Doe\"\n      }\n    }\n  ]\n}\n",
			expectStatus: 422,
		},
		{
			name:         "Put user, valid json but invalid user handle",
			method:       http.MethodPut,
			requestPath:  "/users/bob",
			bodyPath:     "../../testdata/valid_user.json",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Bad Request\",\n  \"status\": 400,\n  \"detail\": \"user handle in URL (bob) does not match user handle in body (alice).\"\n}\n",
			expectStatus: 400,
		},
		{
			name:         "Post user, valid json",
			method:       http.MethodPost,
			requestPath:  "/users",
			bodyPath:     "../../testdata/valid_user.json",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/UserResponse.json\",\n  \"handle\": \"alice\",\n  \"apiKey\": \"12345678901234567890123456789012\"\n}\n",
			expectStatus: 201,
		},
		{
			name:         "Post user, invalid json",
			method:       http.MethodPost,
			requestPath:  "/users",
			bodyPath:     "../../testdata/invalid_user.json",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Unprocessable Entity\",\n  \"status\": 422,\n  \"detail\": \"validation failed\",\n  \"errors\": [\n    {\n      \"message\": \"expected required property email to be present\",\n      \"location\": \"body\",\n      \"value\": {\n        \"handle\": \"john\",\n        \"name\": \"John Doe\"\n      }\n    }\n  ]\n}\n",
			expectStatus: 422,
		},
		{
			name:         "Valid get user",
			method:       http.MethodGet,
			requestPath:  "/users/alice",
			bodyPath:     "",
			expectBody:   "{\n  \"handle\": \"alice\",\n  \"name\": \"Alice Doe\",\n  \"email\": \"alice@foo.bar\",\n  \"apiKey\": \"12345678901234567890123456789012\"\n}\n",
			expectStatus: 200,
		},
		{
			name:         "Valid get all users",
			method:       http.MethodGet,
			requestPath:  "/users",
			bodyPath:     "",
			expectBody:   "[\n  \"alice\"\n]\n",
			expectStatus: 200,
		},
		{
			name:         "Get nonexistent user",
			method:       http.MethodGet,
			requestPath:  "/users/alfons",
			bodyPath:     "",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"user alfons not found. no rows in result set\"\n}\n",
			expectStatus: 404,
		},
		{
			name:         "Get invalid path",
			method:       http.MethodGet,
			requestPath:  "/uxers/alfons",
			bodyPath:     "",
			expectBody:   "",
			expectStatus: 404,
		},
		{
			name:         "Delete user, valid path",
			method:       http.MethodDelete,
			requestPath:  "/users/alice",
			bodyPath:     "",
			expectBody:   "",
			expectStatus: 204,
		},
		{
			name:         "Delete nonexistent user",
			method:       http.MethodDelete,
			requestPath:  "/users/alfons",
			bodyPath:     "",
			expectBody:   "{\n  \"$schema\": \"http://localhost:8080/schemas/ErrorModel.json\",\n  \"title\": \"Not Found\",\n  \"status\": 404,\n  \"detail\": \"user alfons not found\"\n}\n",
			expectStatus: 404,
		},
	}

	for _, v := range tt {
		t.Run(v.name, func(t *testing.T) {

			// We need to handle the body only for PUT and POST requests
			// For GET and DELETE requests, the body is nil
			reqBody := io.Reader(nil)
			if v.method == http.MethodGet || v.method == http.MethodDelete {
				reqBody = nil
			} else {
				f, err := os.Open(v.bodyPath)
				assert.NoError(t, err)
				defer func() {
					if err := f.Close(); err != nil {
						t.Fatal(err)
					}
				}()
				b := new(bytes.Buffer)
				_, err = io.Copy(b, f)
				assert.NoError(t, err)
				reqBody = bytes.NewReader(b.Bytes())
			}
			requestURL := fmt.Sprintf("http://%v:%d%v", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(v.method, requestURL, reqBody)
			assert.NoError(t, err)
			resp, err := http.DefaultClient.Do(req)
			if err != nil {
				t.Errorf("Error sending request: %v\n", err)
			}
			// assert.NoError(t, err)
			defer resp.Body.Close()

			if resp.StatusCode != int(v.expectStatus) {
				t.Errorf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			} else {
				t.Logf("Expected status code %d, got %s\n", v.expectStatus, resp.Status)
			}

			respBody, err := io.ReadAll(resp.Body) // response body is []byte
			assert.NoError(t, err)
			formattedResp := ""
			if v.expectBody != "" {
				fr := new(bytes.Buffer)
				err = json.Indent(fr, respBody, "", "  ")
				assert.NoError(t, err)
				formattedResp = fr.String()
			}
			// if (resp.StatusCode != http.StatusOK) || (resp.StatusCode != int(v.expectStatus)) {
			assert.Equal(t, v.expectBody, formattedResp, "they should be equal")
			// }
		})
	}

	// Verify that the expectations regarding the mock key generation were met
	mockKeyGen.AssertExpectations(t)

	// Cleanup removes items created by the put function test
	// ('/users/alice' and '/users/bob' in case this has erroneously been created)
	t.Cleanup(func() {
		tt := []struct {
			name        string
			requestPath string
		}{
			{
				name:        "clean up alice",
				requestPath: "/users/alice",
			},
			{
				name:        "clean up bob",
				requestPath: "/users/bob",
			},
		}

		for _, v := range tt {
			fmt.Printf("Running cleanup: %s\n", v.name)
			requestURL := fmt.Sprintf("http://%s:%d%s", options.Host, options.Port, v.requestPath)
			req, err := http.NewRequest(http.MethodDelete, requestURL, nil)
			assert.NoError(t, err)
			_, err = http.DefaultClient.Do(req)
			if err != nil && err.Error() != "no rows in result set" {
				t.Fatalf("Error sending request: %v\n", err)
			}
			assert.NoError(t, err)
		}
		fmt.Print("Shutting down server\n")
		shutDownServer()
	})

}
</file>

<file path="internal/handlers/users.go">
package handlers

import (
	"context"
	"fmt"
	"net/http"

	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2"
	"github.com/jackc/pgx/v5/pgtype"
	"github.com/jackc/pgx/v5/pgxpool"
)

// putUserFunc creates or updates a user
func putUserFunc(ctx context.Context, input *models.PutUserRequest) (*models.UploadUserResponse, error) {
	if input.Handle != input.Body.Handle {
		return nil, huma.Error400BadRequest(fmt.Sprintf("user handle in URL (%s) does not match user handle in body (%v).", input.Handle, input.Body.Handle))
	}

	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	} else if pool == nil {
		return nil, huma.Error500InternalServerError("database connection pool is nil")
	}

	// Get the API key generator from the context
	keyGen, err := GetKeyGen(ctx)
	if err != nil {
		return nil, err
	}

	// Build query parameters (user - eventually with new API key)
	// Check if user already exists
	queries := database.New(pool)
	u, err := queries.RetrieveUser(ctx, input.Handle)
	if err != nil && err.Error() != "no rows in result set" {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s already exists. %v", input.Handle, err))
	}
	api_key := ""
	if u.Handle == input.Handle {
		// User exists, so don't create API key
		api_key = u.VDBKey
	} else {
		// User does not exist, so create a new API key
		k, err := keyGen.RandomKey(64)
		if err != nil {
			return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to create API key for user %s. %v", input.Handle, err))
		}
		api_key = k
	}
	user := database.UpsertUserParams{
		Handle:    input.Handle,
		Name:      pgtype.Text{String: input.Body.Name, Valid: true},
		Email:     input.Body.Email,
		VDBKey: api_key,
	}

	// Run the query
	u, err = queries.UpsertUser(ctx, user)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to upload user. %v", err))
	}

	// Build the response
	response := &models.UploadUserResponse{}
	response.Body.Handle = u.Handle
	response.Body.APIKey = u.VDBKey
	return response, nil
}

// Create a user (without a handle being present in the URL)
func postUserFunc(ctx context.Context, input *models.PostUserRequest) (*models.UploadUserResponse, error) {
	u, err := putUserFunc(ctx, &models.PutUserRequest{Handle: input.Body.Handle, Body: input.Body})
	if err != nil {
		return nil, err
	}
	return u, nil
}

// Get all users
func getUsersFunc(ctx context.Context, input *models.GetUsersRequest) (*models.GetUsersResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	} else if pool == nil {
		return nil, huma.Error500InternalServerError("database connection pool is nil")
	}

	// Run the query
	queries := database.New(pool)
	allUsers, err := queries.GetUsers(ctx, database.GetUsersParams{Limit: int32(input.Limit), Offset: int32(input.Offset)})
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get list of users. %v", err))
	}
	if len(allUsers) == 0 {
		return nil, huma.Error404NotFound("no users found.")
	}

	// Build the response
	response := &models.GetUsersResponse{}
	response.Body = allUsers

	return response, nil
}

// Get a specific user
func getUserFunc(ctx context.Context, input *models.GetUserRequest) (*models.GetUserResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	} else if pool == nil {
		return nil, huma.Error500InternalServerError("database connection pool is nil")
	}

	// Run the query
	queries := database.New(pool)
	u, err := queries.RetrieveUser(ctx, input.Handle)
	if err != nil {
		// return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to get user data for user %s. %v", input.User, err))
		return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found. %v", input.Handle, err))
	}

	// Build the response
	returnUser := &models.User{
		Handle: u.Handle,
		Name:   u.Name.String,
		Email:  u.Email,
		APIKey: u.VDBKey,
	}
	response := &models.GetUserResponse{}
	response.Body = *returnUser

	return response, nil
}

// Delete a specific user
func deleteUserFunc(ctx context.Context, input *models.DeleteUserRequest) (*models.DeleteUserResponse, error) {
	// Get the database connection pool from the context
	pool, err := GetDBPool(ctx)
	if err != nil {
		return nil, err
	} else if pool == nil {
		return nil, huma.Error500InternalServerError("database connection pool is nil")
	}

	// Check if user exists
	queries := database.New(pool)
	_, err = queries.RetrieveUser(ctx, input.Handle)
	if err != nil {
		if err.Error() == "no rows in result set" {
			return nil, huma.Error404NotFound(fmt.Sprintf("user %s not found", input.Handle))
		}
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to check if user %s exists before deleting. %v", input.Handle, err))
	}

	// Run the query
	err = queries.DeleteUser(ctx, input.Handle)
	if err != nil {
		return nil, huma.Error500InternalServerError(fmt.Sprintf("unable to delete user %s. %v", input.Handle, err))
	}

	// Build the response
	response := &models.DeleteUserResponse{}
	return response, nil
}

// RegisterUsersRoutes registers all the admin routes with the API
func RegisterUsersRoutes(pool *pgxpool.Pool, keyGen RandomKeyGenerator, api huma.API) error {
	// Define huma.Operations for each route
	putUserOp := huma.Operation{
		OperationID:   "putUser",
		Method:        http.MethodPut,
		Path:          "/users/{handle}",
		DefaultStatus: http.StatusCreated,
		Summary:       "Create or update a user",
		Security: []map[string][]string{
			{"adminAuth": {}},
		},
		Tags: []string{"admin", "users"},
	}
	postUserOp := huma.Operation{
		OperationID:   "postUser",
		Method:        http.MethodPost,
		Path:          "/users",
		DefaultStatus: http.StatusCreated,
		Summary:       "Create a user",
		Security: []map[string][]string{
			{"adminAuth": {}},
		},
		Tags: []string{"admin", "users"},
	}
	getUsersOp := huma.Operation{
		OperationID: "getUsers",
		Method:      http.MethodGet,
		Path:        "/users",
		Summary:     "Get information about all users",
		Security: []map[string][]string{
			{"adminAuth": {}},
		},
		Tags: []string{"admin", "users"},
	}
	getUserOp := huma.Operation{
		OperationID: "getUser",
		Method:      http.MethodGet,
		Path:        "/users/{handle}",
		Summary:     "Get information about a specific user",
		Tags:        []string{"admin", "users"},
	}
	deleteUserOp := huma.Operation{
		OperationID:   "deleteUser",
		Method:        http.MethodDelete,
		Path:          "/users/{handle}",
		DefaultStatus: http.StatusNoContent,
		Summary:       "Delete a specific user",
		Security: []map[string][]string{
			{"adminAuth": {}},
		},
		Tags: []string{"admin", "users"},
	}

	// Register the routes with middleware
	huma.Register(api, putUserOp, addPoolToContext(pool, addKeyGenToContext(keyGen, putUserFunc)))
	huma.Register(api, postUserOp, addPoolToContext(pool, addKeyGenToContext(keyGen, postUserFunc)))
	huma.Register(api, getUsersOp, addPoolToContext(pool, getUsersFunc))
	huma.Register(api, getUserOp, addPoolToContext(pool, getUserFunc))
	huma.Register(api, deleteUserOp, addPoolToContext(pool, deleteUserFunc))
	return nil
}
</file>

<file path="internal/models/embeddings.go">
package models

import (
	"net/http"

	"github.com/pgvector/pgvector-go"
)

// Embeddings contains a single document's embeddings record with id, embeddings and possibly more information.
type Embeddings struct {
  TextID              string `json:"id" doc:"Identifier for the document"`
  Vector              pgvector.HalfVector `json:"vector" doc:"Half-precision embeddings vector for the document"`
  VectorDim           int32 `json:"vector_dim" doc:"Dimensionality of the embeddings vector"`
  Llmservice          int32 `json:"llmservice" doc:"ID of the language model service used to generate the embeddings"`
  Text                string `json:"text,omitempty" doc:"Text content of the document"`
  ProjectId           int    `json:"project_id" doc:"Unique project identifier"`
  User                string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project             string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  // TODO: add metadata handling
  // Metadata map[string]interface{} `json:"metadata,omitempty" doc:"Metadata for the document. E.g. creation year, author name or text genre."`
}

type Embeddingss []Embeddings

func (es Embeddingss) GetIDs() []string {
  var ids []string
  for _, e := range es {
    ids = append(ids, e.TextID)
  }
  return ids
}

// Request and Response structs for the user administration API
// The request structs must be structs with fields for the request path/query/header/cookie parameters and/or body.
// The response structs must be structs with fields for the output headers and body of the operation, if any.

// Put/post project embeddings
// PUT Path: "/embeddings/{user}/{project}/{id}"

type PutProjEmbeddingsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  ID         string `json:"id" path:"id" maxLength:"200" minLength:"3" example:"https%3A%2F%2Fid.salamanca.school%2Ftexts%2FW0017%3Afrontmatter.1.1%0A" doc:"Document identifier"`
  Body       struct {
    Embeddings Embeddings `json:"embeddings" doc:"Single set of document embeddings"`
  }
}

// POST Path: "/embeddings/{user}/{project}"

type PostProjEmbeddingsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  Body       struct {
    Embeddings Embeddingss `json:"embeddings" doc:"List of document embeddings"`
  }
}

type UploadProjEmbeddingsResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    IDs       []string `json:"ids" doc:"List of document identifiers"`
  }
}

// Get project embeddings
// Path: "/embeddings/{user}/{project}"

type GetProjEmbeddingsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  Limit      int `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"20" doc:"Maximum number of embeddings to return"`
  Offset     int `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of embeddings"`
}

type GetProjEmbeddingsResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    Embeddings Embeddingss `json:"embeddings" doc:"List of document embeddings"`
  }
}

// Delete project embeddings
// Path: "/embeddings/{user}/{project}"

type DeleteProjEmbeddingsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
}

type DeleteProjEmbeddingsResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body string `json:"body" doc:"Success message"`
}

// Get document embeddings
// Path: "/embeddings/{user}/{project}/{id}"

type GetDocEmbeddingsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  ID         string `json:"id" path:"id" maxLength:"200" minLength:"3" example:"https%3A%2F%2Fid.salamanca.school%2Ftexts%2FW0017%3Afrontmatter.1.1%0A" doc:"Document identifier"`
}

type GetDocEmbeddingsResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    Embeddings `json:"body" doc:"Document embeddings"`
  }
}

// Delete document embeddings
// Path: "/embeddings/{user}/{project}/{id}"

type DeleteEmbeddingsByDocIDRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  ID         string `json:"id" path:"id" maxLength:"200" minLength:"3" example:"https%3A%2F%2Fid.salamanca.school%2Ftexts%2FW0017%3Afrontmatter.1.1%0A" doc:"Document identifier"`
}

type DeleteEmbeddingsByDocIDResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body string `json:"body" doc:"Success message"`
}
</file>

<file path="internal/models/llm_process.go">
package models

type LLMProcessRequest struct {
  ServiceID  string   `json:"serviceId"`
  ProjectID  string   `json:"projectId"`
  ContextID  string   `json:"contextId"`
  TextFields []string `json:"textFields"`
}

type LLMProcessResponse struct {
  TextFields []string `json:"textFields"`
}
</file>

<file path="internal/models/llm_service.go">
package models

import (
	"net/http"
)

// LLMService is a service for managing LLM data.
type LLMService struct {
  Handle           string `json:"serviceName" minLength:"3" maxLength:"20" example:"GPT-4 API" doc:"Service name"`
  Endpoint         string `json:"endpoint" example:"https://api.openai.com/v1/embeddings" doc:"Service endpoint"`
  Description      string `json:"description,omitempty" doc:"Service description"`
  APIKey           string `json:"apiKey,omitempty" example:"12345678901234567890123456789012" doc:"Authentication token for the service"`
  ApiStandard      string `json:"apiStandard" enum:"openai,custom" default:"openai" example:"openai" doc:"Standard of the API"`
  // ContextData      string `json:"contextData,omitempty" doc:"Context data that can be fed to the LLM service. Available in the request template as contextData variable."`
  // SystemPrompt     string `json:"systemPrompt,omitempty" example:"Return the embeddings for the following text:" doc:"System prompt for requests to the service. Available in the request template as systemPrompt variable."`
  // RequestTemplate  string `json:"requestTemplate,omitempty" doc:"Request template for the service. Can use input, contextData, and systemPrompt variables." example:"{\"input\": \"{{ input }}\", \"model\": \"text-embedding-3-small\"}"`
  // RespFieldName    string `json:"respFieldName,omitempty" default:"embedding" example:"embedding" doc:"Field name of the service response containing the embeddings. Supported is a top-level key of a json object."`
}

// Request and Response structs for the project administration API
// The request structs must be structs with fields for the request path/query/header/cookie parameters and/or body.
// The response structs must be structs with fields for the output headers and body of the operation, if any.

// Put/post project
// PUT Path: "/instances/{user}/{handle}"

type PutLLMRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Handle     string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"LLM service handle"`
  Body       struct {
    LLMService LLMService `json:"llm_service" doc:"LLM service to create or update"`
  }
}

// POST Path: "/instances/{user}"

type PostLLMRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Body       struct {
    LLMService LLMService `json:"llm_service" doc:"LLM service to create or update"`
  }
}

type UploadLLMResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    Handle string `json:"handle" doc:"Handle of created or updated LLM service"`
  }
}

// Get all LLM services by user
// Path: "/instances/{user}"

type GetUserLLMsRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Limit      int `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"20" doc:"Maximum number of embeddings to return"`
  Offset     int `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of embeddings"`
}

type GetUserLLMsResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    LLMServices []LLMService `json:"llm_service" doc:"List of LLM Services"`
  }
}

// Get single LLM service
// Path: "/instances/{user}/{handle}"

type GetLLMRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Handle     string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"LLM service handle"`
  Limit      int `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"20" doc:"Maximum number of embeddings to return"`
  Offset     int `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of embeddings"`
}

type GetLLMResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    LLMService LLMService `json:"llm_service" doc:"LLM Service"`
  }
}

// Delete LLM service
// Path: "/instances/{user}/{handle}"

type DeleteLLMRequest struct {
  User       string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Handle     string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"LLM service handle"`
}

type DeleteLLMResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    Message string `json:"message" doc:"Message indicating the deletion was successful"`
  }
}
</file>

<file path="internal/models/options.go">
package models

// Options for the CLI.
type Options struct {
  Debug bool        `doc:"Enable debug logging" short:"d" default:"true"`
  Host  string      `doc:"Hostname to listen on" default:"localhost"`
  Port  int         `doc:"Port to listen on" short:"p" default:"8888"`
  DBHost string     `doc:"Database hostname" default:"localhost"`
  DBPort int        `doc:"Database port" default:"5432"`
  DBUser string     `doc:"Database username" default:"postgres"`
  DBPassword string `doc:"Database password" default:"password"`
  DBName string     `doc:"Database name" default:"postgres"`
  AdminKey string   `doc:"Admin API key"`
}
</file>

<file path="internal/models/project.go">
package models

import "net/http"

// Project is a project that a user is a member of.
type Project struct {
	Id                int          `json:"project_id" doc:"Unique project identifier"`
	Handle            string       `json:"handle" minLength:"3" maxLength:"20" example:"my-gpt-4" doc:"Project handle"`
	Description       string       `json:"description,omitempty" maxLength:"255" doc:"Description of the project."`
	MetadataScheme    string       `json:"metadataScheme,omitempty" doc:"Metadata json scheme used in the project."`
	SharedWith []string     `json:"shared_with,omitempty" default:"" example:"[\"jdoe\",\"foobar\"]" doc:"Account names allowed to retrieve information from the project. Defaults to everyone ([\"*\"])"`
	LLMServices       []LLMService `json:"llmServices,omitempty" doc:"LLM services used in the project"`
}

type ProjectSubmission struct {
	Handle            string       `json:"handle" minLength:"3" maxLength:"20" example:"my-gpt-4" doc:"Project handle"`
	Description       string       `json:"description,omitempty" maxLength:"255" doc:"Description of the project."`
	MetadataScheme    string       `json:"metadataScheme,omitempty" doc:"Metadata json scheme used in the project."`
	SharedWith []string     `json:"shared_with,omitempty" default:"" example:"[\"jdoe\",\"foobar\"]" doc:"Account names allowed to retrieve information from the project. Defaults to everyone ([\"*\"])"`
	LLMServices       []LLMService `json:"llmServices,omitempty" doc:"LLM services used in the project"`
}

// Request and Response structs for the project administration API
// The request structs must be structs with fields for the request path/query/header/cookie parameters and/or body.
// The response structs must be structs with fields for the output headers and body of the operation, if any.

// Put/post project
// PUT Path: "/projects/{user}/{project}"

type PutProjectRequest struct {
	User    string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
	Project string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
	Body    ProjectSubmission
}

// POST Path: "/projects/{user}"

type PostProjectRequest struct {
	User string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
	Body ProjectSubmission
}

type UploadProjectResponse struct {
	Header []http.Header `json:"header,omitempty" doc:"Response headers"`
	Body   struct {
		Handle string `json:"id" doc:"Handle of created or updated project"`
		Id     int    `json:"project_id" doc:"Unique project identifier"`
	}
}

// Get all projects by user
// Path: "/projects/{user}"

type GetProjectsRequest struct {
	User   string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
	Limit  int    `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"10" doc:"Maximum number of projects to return"`
	Offset int    `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of projects"`
}

type GetProjectsResponse struct {
	Header []http.Header `json:"header,omitempty" doc:"Response headers"`
	Body   struct {
		// Handles []string `json:"handles" doc:"Handles of all registered projects for specified user"`
		Projects []Project `json:"projects" doc:"Projects that the user is a member of"`
	}
}

// Get single project
// Path: "/projects/{user}/{project}"

type GetProjectRequest struct {
	User    string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
	Project string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
}

type GetProjectResponse struct {
	Header []http.Header `json:"header,omitempty" doc:"Response headers"`
	Body   struct {
		Project Project `json:"project" doc:"Project information"`
	}
}

// Delete project
// Path: "/projects/{user}/{project}"

type DeleteProjectRequest struct {
	User    string `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
	Project string `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
}

type DeleteProjectResponse struct {
	Header []http.Header `json:"header,omitempty" doc:"Response headers"`
}
</file>

<file path="internal/models/similar.go">
package models

import "net/http"

type GetSimilarRequest struct {
  User       string  `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string  `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  ID         string  `json:"id" path:"id" maxLength:"200" minLength:"3" example:"https%3A%2F%2Fid.salamanca.school%2Ftexts%2FW0017%3Afrontmatter.1.1%0A" doc:"Document identifier"`
  Count      int     `json:"count"`
  Threshold  float64 `json:"threshold"`
  Limit      int     `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"10" doc:"Maximum number of similar documents to return"`
  Offset     int     `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of similar documents"`
}

type PostSimilarRequest struct {
  User       string  `json:"user" path:"user" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Project    string  `json:"project" path:"project" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"Project handle"`
  LLMService string  `json:"llm_service" path:"llm_service" maxLength:"20" minLength:"3" example:"my-gpt-4" doc:"LLM service handle"`
  Count      int     `json:"count"`
  Threshold  float64 `json:"threshold"`
  Limit      int     `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"10" doc:"Maximum number of similar documents to return"`
  Offset     int     `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of similar documents"`
}

type SimilarResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body struct {
    User       string `json:"user" doc:"User handle"`
    Project    string `json:"project" doc:"Project handle"`
    IDs        []string `json:"ids" doc:"List of similar document identifiers"`
  }
}
</file>

<file path="internal/models/user.go">
package models

import "net/http"

// User represents a user account.
type User struct {
  Handle      string `json:"handle"           doc:"User handle" maxLength:"20"  minLength:"3" example:"jdoe"`
  Name        string `json:"name,omitempty"   doc:"User name"   maxLength:"50"                example:"Jane Doe"`
  Email       string `json:"email"            doc:"User email"  maxLength:"100" minLength:"5" example:"foo@bar.com"`
  APIKey      string `json:"apiKey,omitempty" doc:"User API key for dhamps-vdb API" maxLength:"32" minLength:"32" example:"12345678901234567890123456789012"`
  Projects    []Project `json:"projects,omitempty" doc:"Projects that the user is a member of"`
}

// Request and Response structs for the user administration API
// The request structs must be structs with fields for the request path/query/header/cookie parameters and/or body.
// The response structs must be structs with fields for the output headers and body of the operation, if any.

// Put/post user
// PUT Path: "/users/{handle}"

type PutUserRequest struct {
  Handle string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
  Body User `json:"user" doc:"User to create or update"`
}

// POST Path: "/users"

type PostUserRequest struct {
  Body User `json:"user" doc:"User to create or update"`
}

type UploadUserResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body UserResponse
}

type UserResponse struct {
  Handle string `json:"handle" doc:"Handle of created or updated user"`
  APIKey string `json:"apiKey" doc:"API key for the user"`
}

// Get all users
// Path: "/users"

type GetUsersRequest struct {
  Limit int `json:"limit,omitempty" query:"limit" minimum:"1" maximum:"200" example:"10" default:"10" doc:"Maximum number of users to return"`
  Offset int `json:"offset,omitempty" query:"offset" minimum:"0" example:"0" default:"0" doc:"Offset into the list of users"`
}

type GetUsersResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body []string `json:"handles" doc:"Handles of all registered user accounts"`
}

// Get single user information
// Path "/users/{handle}"

type GetUserRequest struct {
  Handle string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
}

type GetUserResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
  Body User `json:"user" doc:"User information"`
}

// Delete user
// Path "/users/{handle}"

type DeleteUserRequest struct {
  Handle string `json:"handle" path:"handle" maxLength:"20" minLength:"3" example:"jdoe" doc:"User handle"`
}

type DeleteUserResponse struct {
  Header []http.Header `json:"header,omitempty" doc:"Response headers"`
}
</file>

<file path="testdata/postgres/enable-vector.sql">
CREATE EXTENSION IF NOT EXISTS vector;
</file>

<file path="testdata/postgres/users.yml">
---
- id: b35ac310-9fa2-40e1-be39-553b07d6235b
  email: john.doe@gmail.com
  full_name: John Doe
  created_at: '2024-01-20 14:26:13.237292+00'
  updated_at: '2024-01-20 14:26:13.237292+00'
  deleted_at:
- id: df1f03c9-1831-442a-9035-0f77bc413ec1
  email: linus@torvalds.com
  full_name: Linus Torvalds
  created_at: '2024-01-20 14:25:28.301043+00'
  updated_at: '2024-01-20 14:25:28.301043+00'
  deleted_at:
</file>

<file path="testdata/invalid_embeddings.json">
{
  "foo": "https://id.salamanca.school/texts/W0001:vol1.1.1.1.1",
  "vector": [],
  "vector_dim": 512,
  "llmservice": 1,
  "text": "This is a test document",
  "project_id": 1,
  "user": "alice",
  "project": "test1"
}
</file>

<file path="testdata/invalid_project.json">
{
  "foo": "test1",
  "description": "This is a test project"
}
</file>

<file path="testdata/invalid_user.json">
{
  "handle": "john",
  "name": "John Doe"
}
</file>

<file path="testdata/valid_embeddings.json">
{
  "id": "https://id.salamanca.school/texts/W0001:vol1.1.1.1.1",
  "vector": [],
  "vector_dim": 512,
  "llmservice": 1,
  "text": "This is a test document",
  "project_id": 1,
  "user": "alice",
  "project": "test1"
}
</file>

<file path="testdata/valid_project.json">
{
  "handle": "test1",
  "description": "This is a test project"
}
</file>

<file path="testdata/valid_user.json">
{
  "handle": "alice",
  "name": "Alice Doe",
  "email": "alice@foo.bar"
}
</file>

<file path=".gitignore">
# If you prefer the allow list template instead of the deny list, see community template:
# https://github.com/github/gitignore/blob/main/community/Golang/Go.AllowList.gitignore
#
# Binaries for programs and plugins
*.exe
*.exe~
*.dll
*.so
*.dylib

# Test binary, built with `go test -c`
*.test

# Output of the go coverage tool, specifically when used with LiteIDE
*.out

# Dependency directories (remove the comment below to include it)
# vendor/

# Go workspace file
go.work

# Files with secrets
.env
tern.conf
</file>

<file path=".repopackignore">
# Add patterns to ignore here, one per line
# Example:
# *.log
# tmp/
</file>

<file path="go.mod">
module github.com/mpilhlt/dhamps-vdb

go 1.22.1

require (
	github.com/danielgtaylor/huma/v2 v2.10.0
	github.com/jackc/pgx/v5 v5.7.0
	github.com/jackc/tern/v2 v2.2.1
	github.com/pgvector/pgvector-go v0.2.2
	github.com/stretchr/testify v1.9.0
	github.com/testcontainers/testcontainers-go v0.34.0
	github.com/testcontainers/testcontainers-go/modules/postgres v0.34.0
)

require (
	dario.cat/mergo v1.0.0 // indirect
	github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 // indirect
	github.com/Masterminds/goutils v1.1.1 // indirect
	github.com/Masterminds/semver/v3 v3.2.1 // indirect
	github.com/Masterminds/sprig/v3 v3.2.3 // indirect
	github.com/Microsoft/go-winio v0.6.2 // indirect
	github.com/cenkalti/backoff/v4 v4.2.1 // indirect
	github.com/containerd/containerd v1.7.18 // indirect
	github.com/containerd/log v0.1.0 // indirect
	github.com/containerd/platforms v0.2.1 // indirect
	github.com/cpuguy83/dockercfg v0.3.2 // indirect
	github.com/danielgtaylor/casing v1.0.0 // indirect
	github.com/davecgh/go-spew v1.1.1 // indirect
	github.com/distribution/reference v0.6.0 // indirect
	github.com/docker/docker v27.1.1+incompatible // indirect
	github.com/docker/go-connections v0.5.0 // indirect
	github.com/docker/go-units v0.5.0 // indirect
	github.com/felixge/httpsnoop v1.0.4 // indirect
	github.com/fxamacker/cbor/v2 v2.6.0 // indirect
	github.com/go-chi/chi v4.1.2+incompatible // indirect
	github.com/go-chi/chi/v5 v5.0.12 // indirect
	github.com/go-logr/logr v1.4.1 // indirect
	github.com/go-logr/stdr v1.2.2 // indirect
	github.com/go-ole/go-ole v1.2.6 // indirect
	github.com/gogo/protobuf v1.3.2 // indirect
	github.com/google/uuid v1.6.0 // indirect
	github.com/huandu/xstrings v1.4.0 // indirect
	github.com/imdario/mergo v0.3.16 // indirect
	github.com/inconshreveable/mousetrap v1.1.0 // indirect
	github.com/jackc/pgpassfile v1.0.0 // indirect
	github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 // indirect
	github.com/jackc/puddle/v2 v2.2.1 // indirect
	github.com/klauspost/compress v1.17.7 // indirect
	github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 // indirect
	github.com/magiconair/properties v1.8.7 // indirect
	github.com/mitchellh/copystructure v1.2.0 // indirect
	github.com/mitchellh/reflectwalk v1.0.2 // indirect
	github.com/moby/docker-image-spec v1.3.1 // indirect
	github.com/moby/patternmatcher v0.6.0 // indirect
	github.com/moby/sys/sequential v0.5.0 // indirect
	github.com/moby/sys/user v0.1.0 // indirect
	github.com/moby/term v0.5.0 // indirect
	github.com/morikuni/aec v1.0.0 // indirect
	github.com/opencontainers/go-digest v1.0.0 // indirect
	github.com/opencontainers/image-spec v1.1.0 // indirect
	github.com/pkg/errors v0.9.1 // indirect
	github.com/pmezard/go-difflib v1.0.0 // indirect
	github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c // indirect
	github.com/shirou/gopsutil/v3 v3.23.12 // indirect
	github.com/shoenig/go-m1cpu v0.1.6 // indirect
	github.com/shopspring/decimal v1.4.0 // indirect
	github.com/sirupsen/logrus v1.9.3 // indirect
	github.com/spf13/cast v1.6.0 // indirect
	github.com/spf13/cobra v1.8.0 // indirect
	github.com/spf13/pflag v1.0.5 // indirect
	github.com/stretchr/objx v0.5.2 // indirect
	github.com/tklauser/go-sysconf v0.3.12 // indirect
	github.com/tklauser/numcpus v0.6.1 // indirect
	github.com/x448/float16 v0.8.4 // indirect
	github.com/yusufpapurcu/wmi v1.2.3 // indirect
	go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 // indirect
	go.opentelemetry.io/otel v1.24.0 // indirect
	go.opentelemetry.io/otel/metric v1.24.0 // indirect
	go.opentelemetry.io/otel/trace v1.24.0 // indirect
	golang.org/x/crypto v0.27.0 // indirect
	golang.org/x/sync v0.8.0 // indirect
	golang.org/x/sys v0.25.0 // indirect
	golang.org/x/text v0.18.0 // indirect
	gopkg.in/yaml.v3 v3.0.1 // indirect
)
</file>

<file path="go.sum">
dario.cat/mergo v1.0.0 h1:AGCNq9Evsj31mOgNPcLyXc+4PNABt905YmuqPYYpBWk=
dario.cat/mergo v1.0.0/go.mod h1:uNxQE+84aUszobStD9th8a29P2fMDhsBdgRYvZOxGmk=
entgo.io/ent v0.13.1 h1:uD8QwN1h6SNphdCCzmkMN3feSUzNnVvV/WIkHKMbzOE=
entgo.io/ent v0.13.1/go.mod h1:qCEmo+biw3ccBn9OyL4ZK5dfpwg++l1Gxwac5B1206A=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24 h1:bvDV9vkmnHYOMsOr4WLk+Vo07yKIzd94sVoIqshQ4bU=
github.com/AdaLogics/go-fuzz-headers v0.0.0-20230811130428-ced1acdcaa24/go.mod h1:8o94RPi1/7XTJvwPpRSzSUedZrtlirdB3r9Z20bi2f8=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1 h1:UQHMgLO+TxOElx5B5HZ4hJQsoJ/PvUvKRhJHDQXO8P8=
github.com/Azure/go-ansiterm v0.0.0-20210617225240-d185dfc1b5a1/go.mod h1:xomTg63KZ2rFqZQzSB4Vz2SUXa1BpHTVz9L5PTmPC4E=
github.com/Masterminds/goutils v1.1.1 h1:5nUrii3FMTL5diU80unEVvNevw1nH4+ZV4DSLVJLSYI=
github.com/Masterminds/goutils v1.1.1/go.mod h1:8cTjp+g8YejhMuvIA5y2vz3BpJxksy863GQaJW2MFNU=
github.com/Masterminds/semver/v3 v3.2.0/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=
github.com/Masterminds/semver/v3 v3.2.1 h1:RN9w6+7QoMeJVGyfmbcgs28Br8cvmnucEXnY0rYXWg0=
github.com/Masterminds/semver/v3 v3.2.1/go.mod h1:qvl/7zhW3nngYb5+80sSMF+FG2BjYrf8m9wsX0PNOMQ=
github.com/Masterminds/sprig/v3 v3.2.3 h1:eL2fZNezLomi0uOLqjQoN6BfsDD+fyLtgbJMAj9n6YA=
github.com/Masterminds/sprig/v3 v3.2.3/go.mod h1:rXcFaZ2zZbLRJv/xSysmlgIM1u11eBaRMhvYXJNkGuM=
github.com/Microsoft/go-winio v0.6.2 h1:F2VQgta7ecxGYO8k3ZZz3RS8fVIXVxONVUPlNERoyfY=
github.com/Microsoft/go-winio v0.6.2/go.mod h1:yd8OoFMLzJbo9gZq8j5qaps8bJ9aShtEA8Ipt1oGCvU=
github.com/cenkalti/backoff/v4 v4.2.1 h1:y4OZtCnogmCPw98Zjyt5a6+QwPLGkiQsYW5oUqylYbM=
github.com/cenkalti/backoff/v4 v4.2.1/go.mod h1:Y3VNntkOUPxTVeUxJ/G5vcM//AlwfmyYozVcomhLiZE=
github.com/containerd/containerd v1.7.18 h1:jqjZTQNfXGoEaZdW1WwPU0RqSn1Bm2Ay/KJPUuO8nao=
github.com/containerd/containerd v1.7.18/go.mod h1:IYEk9/IO6wAPUz2bCMVUbsfXjzw5UNP5fLz4PsUygQ4=
github.com/containerd/log v0.1.0 h1:TCJt7ioM2cr/tfR8GPbGf9/VRAX8D2B4PjzCpfX540I=
github.com/containerd/log v0.1.0/go.mod h1:VRRf09a7mHDIRezVKTRCrOq78v577GXq3bSa3EhrzVo=
github.com/containerd/platforms v0.2.1 h1:zvwtM3rz2YHPQsF2CHYM8+KtB5dvhISiXh5ZpSBQv6A=
github.com/containerd/platforms v0.2.1/go.mod h1:XHCb+2/hzowdiut9rkudds9bE5yJ7npe7dG/wG+uFPw=
github.com/cpuguy83/dockercfg v0.3.2 h1:DlJTyZGBDlXqUZ2Dk2Q3xHs/FtnooJJVaad2S9GKorA=
github.com/cpuguy83/dockercfg v0.3.2/go.mod h1:sugsbF4//dDlL/i+S+rtpIWp+5h0BHJHfjj5/jFyUJc=
github.com/cpuguy83/go-md2man/v2 v2.0.3/go.mod h1:tgQtvFlXSQOSOSIRvRPT7W67SCa46tRHOmNcaadrF8o=
github.com/creack/pty v1.1.18 h1:n56/Zwd5o6whRC5PMGretI4IdRLlmBXYNjScPaBgsbY=
github.com/creack/pty v1.1.18/go.mod h1:MOBLtS5ELjhRRrroQr9kyvTxUAFNvYEK993ew/Vr4O4=
github.com/danielgtaylor/casing v1.0.0 h1:uX+PewTv0zbXeTluwRwlyPMRQEduVP9svLHpbDsQYkw=
github.com/danielgtaylor/casing v1.0.0/go.mod h1:eFdYmNxcuLDrRNW0efVoxSaApmvGXfHZ9k2CT/RSUF0=
github.com/danielgtaylor/huma/v2 v2.10.0 h1:PHiD/e/Fb/fnQmoWvK36KXpIE22GV3Y66XJntUlIkVM=
github.com/danielgtaylor/huma/v2 v2.10.0/go.mod h1:idDy9pDTw0SEN7rzSw47qkkzlUIY2R0pb74qlsFe/ow=
github.com/davecgh/go-spew v1.1.0/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/davecgh/go-spew v1.1.1 h1:vj9j/u1bqnvCEfJOwUhtlOARqs3+rkHYY13jYWTU97c=
github.com/davecgh/go-spew v1.1.1/go.mod h1:J7Y8YcW2NihsgmVo/mv3lAwl/skON4iLHjSsI+c5H38=
github.com/distribution/reference v0.6.0 h1:0IXCQ5g4/QMHHkarYzh5l+u8T3t73zM5QvfrDyIgxBk=
github.com/distribution/reference v0.6.0/go.mod h1:BbU0aIcezP1/5jX/8MP0YiH4SdvB5Y4f/wlDRiLyi3E=
github.com/docker/docker v27.1.1+incompatible h1:hO/M4MtV36kzKldqnA37IWhebRA+LnqqcqDja6kVaKY=
github.com/docker/docker v27.1.1+incompatible/go.mod h1:eEKB0N0r5NX/I1kEveEz05bcu8tLC/8azJZsviup8Sk=
github.com/docker/go-connections v0.5.0 h1:USnMq7hx7gwdVZq1L49hLXaFtUdTADjXGp+uj1Br63c=
github.com/docker/go-connections v0.5.0/go.mod h1:ov60Kzw0kKElRwhNs9UlUHAE/F9Fe6GLaXnqyDdmEXc=
github.com/docker/go-units v0.5.0 h1:69rxXcBk27SvSaaxTtLh/8llcHD8vYHT7WSdRZ/jvr4=
github.com/docker/go-units v0.5.0/go.mod h1:fgPhTUdO+D/Jk86RDLlptpiXQzgHJF7gydDDbaIK4Dk=
github.com/felixge/httpsnoop v1.0.4 h1:NFTV2Zj1bL4mc9sqWACXbQFVBBg2W3GPvqp8/ESS2Wg=
github.com/felixge/httpsnoop v1.0.4/go.mod h1:m8KPJKqk1gH5J9DgRY2ASl2lWCfGKXixSwevea8zH2U=
github.com/frankban/quicktest v1.14.6 h1:7Xjx+VpznH+oBnejlPUj8oUpdxnVs4f8XU8WnHkI4W8=
github.com/frankban/quicktest v1.14.6/go.mod h1:4ptaffx2x8+WTWXmUCuVU6aPUX1/Mz7zb5vbUoiM6w0=
github.com/fxamacker/cbor/v2 v2.6.0 h1:sU6J2usfADwWlYDAFhZBQ6TnLFBHxgesMrQfQgk1tWA=
github.com/fxamacker/cbor/v2 v2.6.0/go.mod h1:pxXPTn3joSm21Gbwsv0w9OSA2y1HFR9qXEeXQVeNoDQ=
github.com/go-chi/chi v4.1.2+incompatible h1:fGFk2Gmi/YKXk0OmGfBh0WgmN3XB8lVnEyNz34tQRec=
github.com/go-chi/chi v4.1.2+incompatible/go.mod h1:eB3wogJHnLi3x/kFX2A+IbTBlXxmMeXJVKy9tTv1XzQ=
github.com/go-chi/chi/v5 v5.0.12 h1:9euLV5sTrTNTRUU9POmDUvfxyj6LAABLUcEWO+JJb4s=
github.com/go-chi/chi/v5 v5.0.12/go.mod h1:DslCQbL2OYiznFReuXYUmQ2hGd1aDpCnlMNITLSKoi8=
github.com/go-logr/logr v1.2.2/go.mod h1:jdQByPbusPIv2/zmleS9BjJVeZ6kBagPoEUsqbVz/1A=
github.com/go-logr/logr v1.4.1 h1:pKouT5E8xu9zeFC39JXRDukb6JFQPXM5p5I91188VAQ=
github.com/go-logr/logr v1.4.1/go.mod h1:9T104GzyrTigFIr8wt5mBrctHMim0Nb2HLGrmQ40KvY=
github.com/go-logr/stdr v1.2.2 h1:hSWxHoqTgW2S2qGc0LTAI563KZ5YKYRhT3MFKZMbjag=
github.com/go-logr/stdr v1.2.2/go.mod h1:mMo/vtBO5dYbehREoey6XUKy/eSumjCCveDpRre4VKE=
github.com/go-ole/go-ole v1.2.6 h1:/Fpf6oFPoeFik9ty7siob0G6Ke8QvQEuVcuChpwXzpY=
github.com/go-ole/go-ole v1.2.6/go.mod h1:pprOEPIfldk/42T2oK7lQ4v4JSDwmV0As9GaiUsvbm0=
github.com/go-pg/pg/v10 v10.11.0 h1:CMKJqLgTrfpE/aOVeLdybezR2om071Vh38OLZjsyMI0=
github.com/go-pg/pg/v10 v10.11.0/go.mod h1:4BpHRoxE61y4Onpof3x1a2SQvi9c+q1dJnrNdMjsroA=
github.com/go-pg/zerochecker v0.2.0 h1:pp7f72c3DobMWOb2ErtZsnrPaSvHd2W4o9//8HtF4mU=
github.com/go-pg/zerochecker v0.2.0/go.mod h1:NJZ4wKL0NmTtz0GKCoJ8kym6Xn/EQzXRl2OnAe7MmDo=
github.com/gogo/protobuf v1.3.2 h1:Ov1cvc58UF3b5XjBnZv7+opcTcQFZebYjWzi34vdm4Q=
github.com/gogo/protobuf v1.3.2/go.mod h1:P1XiOD3dCwIKUDQYPy72D8LYyHL2YPYrpS2s69NZV8Q=
github.com/google/go-cmp v0.5.6/go.mod h1:v8dTdLbMG2kIc/vJvl+f65V22dbkXbowE6jgT/gNBxE=
github.com/google/go-cmp v0.5.9/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/go-cmp v0.6.0 h1:ofyhxvXcZhMsU5ulbFiLKl/XBFqE1GSq7atu8tAmTRI=
github.com/google/go-cmp v0.6.0/go.mod h1:17dUlkBOakJ0+DkrSSNjCkIjxS6bF9zb3elmeNGIjoY=
github.com/google/uuid v1.1.1/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/google/uuid v1.6.0 h1:NIvaJDMOsjHA8n1jAhLSgzrAzy1Hgr+hNrb57e+94F0=
github.com/google/uuid v1.6.0/go.mod h1:TIyPZe4MgqvfeYDBFedMoGGpEw/LqOeaOT+nhxU+yHo=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0 h1:YBftPWNWd4WwGqtY2yeZL2ef8rHAxPBD8KFhJpmcqms=
github.com/grpc-ecosystem/grpc-gateway/v2 v2.16.0/go.mod h1:YN5jB8ie0yfIUg6VvR9Kz84aCaG7AsGZnLjhHbUqwPg=
github.com/huandu/xstrings v1.3.3/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
github.com/huandu/xstrings v1.4.0 h1:D17IlohoQq4UcpqD7fDk80P7l+lwAmlFaBHgOipl2FU=
github.com/huandu/xstrings v1.4.0/go.mod h1:y5/lhBue+AyNmUVz9RLU9xbLR0o4KIIExikq4ovT0aE=
github.com/imdario/mergo v0.3.11/go.mod h1:jmQim1M+e3UYxmgPu/WyfjB3N3VflVyUjjjwH0dnCYA=
github.com/imdario/mergo v0.3.16 h1:wwQJbIsHYGMUyLSPrEq1CT16AhnhNJQ51+4fdHUnCl4=
github.com/imdario/mergo v0.3.16/go.mod h1:WBLT9ZmE3lPoWsEzCh9LPo3TiwVN+ZKEjmz+hD27ysY=
github.com/inconshreveable/mousetrap v1.1.0 h1:wN+x4NVGpMsO7ErUn/mUI3vEoE6Jt13X2s0bqwp9tc8=
github.com/inconshreveable/mousetrap v1.1.0/go.mod h1:vpF70FUmC8bwa3OWnCshd2FqLfsEA9PFc4w1p2J65bw=
github.com/jackc/pgpassfile v1.0.0 h1:/6Hmqy13Ss2zCq62VdNG8tM1wchn8zjSGOBJ6icpsIM=
github.com/jackc/pgpassfile v1.0.0/go.mod h1:CEx0iS5ambNFdcRtxPj5JhEz+xB6uRky5eyVu/W2HEg=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761 h1:iCEnooe7UlwOQYpKFhBabPMi4aNAfoODPEFNiAnClxo=
github.com/jackc/pgservicefile v0.0.0-20240606120523-5a60cdf6a761/go.mod h1:5TJZWKEWniPve33vlWYSoGYefn3gLQRzjfDlhSJ9ZKM=
github.com/jackc/pgx/v5 v5.7.0 h1:FG6VLIdzvAPhnYqP14sQ2xhFLkiUQHCs6ySqO91kF4g=
github.com/jackc/pgx/v5 v5.7.0/go.mod h1:awP1KNnjylvpxHuHP63gzjhnGkI1iw+PMoIwvoleN/8=
github.com/jackc/puddle/v2 v2.2.1 h1:RhxXJtFG022u4ibrCSMSiu5aOq1i77R3OHKNJj77OAk=
github.com/jackc/puddle/v2 v2.2.1/go.mod h1:vriiEXHvEE654aYKXXjOvZM39qJ0q+azkZFrfEOc3H4=
github.com/jackc/tern/v2 v2.2.1 h1:kricKrvA6FNzBHHaQu15hmJDnpHvZA2DoJa97lJLt10=
github.com/jackc/tern/v2 v2.2.1/go.mod h1:thNyC7gVBGYWsAJJSvAX0ML/1lAmOw7+DVH8aSE5rto=
github.com/jinzhu/inflection v1.0.0 h1:K317FqzuhWc8YvSVlFMCCUb36O/S9MCKRDI7QkRKD/E=
github.com/jinzhu/inflection v1.0.0/go.mod h1:h+uFLlag+Qp1Va5pdKtLDYj+kHp5pxUVkryuEj+Srlc=
github.com/jinzhu/now v1.1.5 h1:/o9tlHleP7gOFmsnYNz3RGnqzefHA47wQpKrrdTIwXQ=
github.com/jinzhu/now v1.1.5/go.mod h1:d3SSVoowX0Lcu0IBviAWJpolVfI5UJVZZ7cO71lE/z8=
github.com/jmoiron/sqlx v1.3.5 h1:vFFPA71p1o5gAeqtEAwLU4dnX2napprKtHr7PYIcN3g=
github.com/jmoiron/sqlx v1.3.5/go.mod h1:nRVWtLre0KfCLJvgxzCsLVMogSvQ1zNJtpYr2Ccp0mQ=
github.com/kisielk/errcheck v1.5.0/go.mod h1:pFxgyoBC7bSaBwPgfKdkLd5X25qrDl4LWUI2bnpBCr8=
github.com/kisielk/gotool v1.0.0/go.mod h1:XhKaO+MFFWcvkIS/tQcRk01m1F5IRFswLeQ+oQHNcck=
github.com/klauspost/compress v1.17.7 h1:ehO88t2UGzQK66LMdE8tibEd1ErmzZjNEqWkjLAKQQg=
github.com/klauspost/compress v1.17.7/go.mod h1:Di0epgTjJY877eYKx5yC51cX2A2Vl2ibi7bDH9ttBbw=
github.com/kr/pretty v0.3.1 h1:flRD4NNwYAUpkphVc1HcthR4KEIFJ65n8Mw5qdRn3LE=
github.com/kr/pretty v0.3.1/go.mod h1:hoEshYVHaxMs3cyo3Yncou5ZscifuDolrwPKZanG3xk=
github.com/kr/text v0.2.0 h1:5Nx0Ya0ZqY2ygV366QzturHI13Jq95ApcVaJBhpS+AY=
github.com/kr/text v0.2.0/go.mod h1:eLer722TekiGuMkidMxC/pM04lWEeraHUUmBw8l2grE=
github.com/lib/pq v1.10.9 h1:YXG7RB+JIjhP29X+OtkiDnYaXQwpS4JEWq7dtCCRUEw=
github.com/lib/pq v1.10.9/go.mod h1:AlVN5x4E4T544tWzH6hKfbfQvm3HdbOxrmggDNAPY9o=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0 h1:6E+4a0GO5zZEnZ81pIr0yLvtUWk2if982qA3F3QD6H4=
github.com/lufia/plan9stats v0.0.0-20211012122336-39d0f177ccd0/go.mod h1:zJYVVT2jmtg6P3p1VtQj7WsuWi/y4VnjVBn7F8KPB3I=
github.com/magiconair/properties v1.8.7 h1:IeQXZAiQcpL9mgcAe1Nu6cX9LLw6ExEHKjN0VQdvPDY=
github.com/magiconair/properties v1.8.7/go.mod h1:Dhd985XPs7jluiymwWYZ0G4Z61jb3vdS329zhj2hYo0=
github.com/mitchellh/copystructure v1.0.0/go.mod h1:SNtv71yrdKgLRyLFxmLdkAbkKEFWgYaq1OVrnRcwhnw=
github.com/mitchellh/copystructure v1.2.0 h1:vpKXTN4ewci03Vljg/q9QvCGUDttBOGBIa15WveJJGw=
github.com/mitchellh/copystructure v1.2.0/go.mod h1:qLl+cE2AmVv+CoeAwDPye/v+N2HKCj9FbZEVFJRxO9s=
github.com/mitchellh/reflectwalk v1.0.0/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
github.com/mitchellh/reflectwalk v1.0.2 h1:G2LzWKi524PWgd3mLHV8Y5k7s6XUvT0Gef6zxSIeXaQ=
github.com/mitchellh/reflectwalk v1.0.2/go.mod h1:mSTlrgnPZtwu0c4WaC2kGObEpuNDbx0jmZXqmk4esnw=
github.com/moby/docker-image-spec v1.3.1 h1:jMKff3w6PgbfSa69GfNg+zN/XLhfXJGnEx3Nl2EsFP0=
github.com/moby/docker-image-spec v1.3.1/go.mod h1:eKmb5VW8vQEh/BAr2yvVNvuiJuY6UIocYsFu/DxxRpo=
github.com/moby/patternmatcher v0.6.0 h1:GmP9lR19aU5GqSSFko+5pRqHi+Ohk1O69aFiKkVGiPk=
github.com/moby/patternmatcher v0.6.0/go.mod h1:hDPoyOpDY7OrrMDLaYoY3hf52gNCR/YOUYxkhApJIxc=
github.com/moby/sys/sequential v0.5.0 h1:OPvI35Lzn9K04PBbCLW0g4LcFAJgHsvXsRyewg5lXtc=
github.com/moby/sys/sequential v0.5.0/go.mod h1:tH2cOOs5V9MlPiXcQzRC+eEyab644PWKGRYaaV5ZZlo=
github.com/moby/sys/user v0.1.0 h1:WmZ93f5Ux6het5iituh9x2zAG7NFY9Aqi49jjE1PaQg=
github.com/moby/sys/user v0.1.0/go.mod h1:fKJhFOnsCN6xZ5gSfbM6zaHGgDJMrqt9/reuj4T7MmU=
github.com/moby/term v0.5.0 h1:xt8Q1nalod/v7BqbG21f8mQPqH+xAaC9C3N3wfWbVP0=
github.com/moby/term v0.5.0/go.mod h1:8FzsFHVUBGZdbDsJw/ot+X+d5HLUbvklYLJ9uGfcI3Y=
github.com/morikuni/aec v1.0.0 h1:nP9CBfwrvYnBRgY6qfDQkygYDmYwOilePFkwzv4dU8A=
github.com/morikuni/aec v1.0.0/go.mod h1:BbKIizmSmc5MMPqRYbxO4ZU0S0+P200+tUnFx7PXmsc=
github.com/opencontainers/go-digest v1.0.0 h1:apOUWs51W5PlhuyGyz9FCeeBIOUDA/6nW8Oi/yOhh5U=
github.com/opencontainers/go-digest v1.0.0/go.mod h1:0JzlMkj0TRzQZfJkVvzbP0HBR3IKzErnv2BNG4W4MAM=
github.com/opencontainers/image-spec v1.1.0 h1:8SG7/vwALn54lVB/0yZ/MMwhFrPYtpEHQb2IpWsCzug=
github.com/opencontainers/image-spec v1.1.0/go.mod h1:W4s4sFTMaBeK1BQLXbG4AdM2szdn85PY75RI83NrTrM=
github.com/pgvector/pgvector-go v0.2.2 h1:Q/oArmzgbEcio88q0tWQksv/u9Gnb1c3F1K2TnalxR0=
github.com/pgvector/pgvector-go v0.2.2/go.mod h1:u5sg3z9bnqVEdpe1pkTij8/rFhTaMCMNyQagPDLK8gQ=
github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c h1:ncq/mPwQF4JjgDlrVEn3C11VoGHZN7m8qihwgMEtzYw=
github.com/power-devops/perfstat v0.0.0-20210106213030-5aafc221ea8c/go.mod h1:OmDBASR4679mdNQnz2pUhc2G8CO2JrUAVFDRBDP/hJE=
github.com/rogpeppe/go-internal v1.9.0 h1:73kH8U+JUqXU8lRuOHeVHaa/SZPifC7BkcraZVejAe8=
github.com/rogpeppe/go-internal v1.9.0/go.mod h1:WtVeX8xhTBvf0smdhujwtBcq4Qrzq/fJaraNFVN+nFs=
github.com/russross/blackfriday/v2 v2.1.0/go.mod h1:+Rmxgy9KzJVeS9/2gXHxylqXiyQDYRxCVz55jmeOWTM=
github.com/shirou/gopsutil/v3 v3.23.12 h1:z90NtUkp3bMtmICZKpC4+WaknU1eXtp5vtbQ11DgpE4=
github.com/shirou/gopsutil/v3 v3.23.12/go.mod h1:1FrWgea594Jp7qmjHUUPlJDTPgcsb9mGnXDxavtikzM=
github.com/shoenig/go-m1cpu v0.1.6 h1:nxdKQNcEB6vzgA2E2bvzKIYRuNj7XNJ4S/aRSwKzFtM=
github.com/shoenig/go-m1cpu v0.1.6/go.mod h1:1JJMcUBvfNwpq05QDQVAnx3gUHr9IYF7GNg9SUEw2VQ=
github.com/shoenig/test v0.6.4 h1:kVTaSd7WLz5WZ2IaoM0RSzRsUD+m8wRR+5qvntpn4LU=
github.com/shoenig/test v0.6.4/go.mod h1:byHiCGXqrVaflBLAMq/srcZIHynQPQgeyvkvXnjqq0k=
github.com/shopspring/decimal v1.2.0/go.mod h1:DKyhrW/HYNuLGql+MJL6WCR6knT2jwCFRcu2hWCYk4o=
github.com/shopspring/decimal v1.4.0 h1:bxl37RwXBklmTi0C79JfXCEBD1cqqHt0bbgBAGFp81k=
github.com/shopspring/decimal v1.4.0/go.mod h1:gawqmDU56v4yIKSwfBSFip1HdCCXN8/+DMd9qYNcwME=
github.com/sirupsen/logrus v1.9.3 h1:dueUQJ1C2q9oE3F7wvmSGAaVtTmUizReu6fjN8uqzbQ=
github.com/sirupsen/logrus v1.9.3/go.mod h1:naHLuLoDiP4jHNo9R0sCBMtWGeIprob74mVsIT4qYEQ=
github.com/spf13/cast v1.3.1/go.mod h1:Qx5cxh0v+4UWYiBimWS+eyWzqEqokIECu5etghLkUJE=
github.com/spf13/cast v1.6.0 h1:GEiTHELF+vaR5dhz3VqZfFSzZjYbgeKDpBxQVS4GYJ0=
github.com/spf13/cast v1.6.0/go.mod h1:ancEpBxwJDODSW/UG4rDrAqiKolqNNh2DX3mk86cAdo=
github.com/spf13/cobra v1.8.0 h1:7aJaZx1B85qltLMc546zn58BxxfZdR/W22ej9CFoEf0=
github.com/spf13/cobra v1.8.0/go.mod h1:WXLWApfZ71AjXPya3WOlMsY9yMs7YeiHhFVlvLyhcho=
github.com/spf13/pflag v1.0.5 h1:iy+VFUOCP1a+8yFto/drg2CJ5u0yRoB7fZw3DKv/JXA=
github.com/spf13/pflag v1.0.5/go.mod h1:McXfInJRrz4CZXVZOBLb0bTZqETkiAhM9Iw0y3An2Bg=
github.com/stretchr/objx v0.1.0/go.mod h1:HFkY916IF+rwdDfMAkV7OtwuqBVzrE8GR6GFx+wExME=
github.com/stretchr/objx v0.4.0/go.mod h1:YvHI0jy2hoMjB+UWwv71VJQ9isScKT/TqJzVSSt89Yw=
github.com/stretchr/objx v0.5.0/go.mod h1:Yh+to48EsGEfYuaHDzXPcE3xhTkx73EhmCGUpEOglKo=
github.com/stretchr/objx v0.5.2 h1:xuMeJ0Sdp5ZMRXx/aWO6RZxdr3beISkG5/G/aIRr3pY=
github.com/stretchr/objx v0.5.2/go.mod h1:FRsXN1f5AsAjCGJKqEizvkpNtU+EGNCLh3NxZ/8L+MA=
github.com/stretchr/testify v1.2.2/go.mod h1:a8OnRcib4nhh0OaRAV+Yts87kKdq0PP7pXfy6kDkUVs=
github.com/stretchr/testify v1.3.0/go.mod h1:M5WIy9Dh21IEIfnGCwXGc5bZfKNJtfHm1UVUgZn+9EI=
github.com/stretchr/testify v1.5.1/go.mod h1:5W2xD1RspED5o8YsWQXVCued0rvSQ+mT+I5cxcmMvtA=
github.com/stretchr/testify v1.7.0/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.7.1/go.mod h1:6Fq8oRcR53rry900zMqJjRRixrwX3KX962/h/Wwjteg=
github.com/stretchr/testify v1.8.0/go.mod h1:yNjHg4UonilssWZ8iaSj1OCr/vHnekPRkoO+kdMU+MU=
github.com/stretchr/testify v1.8.4/go.mod h1:sz/lmYIOXD/1dqDmKjjqLyZ2RngseejIcXlSw2iwfAo=
github.com/stretchr/testify v1.9.0 h1:HtqpIVDClZ4nwg75+f6Lvsy/wHu+3BoSGCbBAcpTsTg=
github.com/stretchr/testify v1.9.0/go.mod h1:r2ic/lqez/lEtzL7wO/rwa5dbSLXVDPFyf8C91i36aY=
github.com/testcontainers/testcontainers-go v0.34.0 h1:5fbgF0vIN5u+nD3IWabQwRybuB4GY8G2HHgCkbMzMHo=
github.com/testcontainers/testcontainers-go v0.34.0/go.mod h1:6P/kMkQe8yqPHfPWNulFGdFHTD8HB2vLq/231xY2iPQ=
github.com/testcontainers/testcontainers-go/modules/postgres v0.34.0 h1:c51aBXT3v2HEBVarmaBnsKzvgZjC5amn0qsj8Naqi50=
github.com/testcontainers/testcontainers-go/modules/postgres v0.34.0/go.mod h1:EWP75ogLQU4M4L8U+20mFipjV4WIR9WtlMXSB6/wiuc=
github.com/tklauser/go-sysconf v0.3.12 h1:0QaGUFOdQaIVdPgfITYzaTegZvdCjmYO52cSFAEVmqU=
github.com/tklauser/go-sysconf v0.3.12/go.mod h1:Ho14jnntGE1fpdOqQEEaiKRpvIavV0hSfmBq8nJbHYI=
github.com/tklauser/numcpus v0.6.1 h1:ng9scYS7az0Bk4OZLvrNXNSAO2Pxr1XXRAPyjhIx+Fk=
github.com/tklauser/numcpus v0.6.1/go.mod h1:1XfjsgE2zo8GVw7POkMbHENHzVg3GzmoZ9fESEdAacY=
github.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc h1:9lRDQMhESg+zvGYmW5DyG0UqvY96Bu5QYsTLvCHdrgo=
github.com/tmthrgd/go-hex v0.0.0-20190904060850-447a3041c3bc/go.mod h1:bciPuU6GHm1iF1pBvUfxfsH0Wmnc2VbpgvbI9ZWuIRs=
github.com/uptrace/bun v1.1.12 h1:sOjDVHxNTuM6dNGaba0wUuz7KvDE1BmNu9Gqs2gJSXQ=
github.com/uptrace/bun v1.1.12/go.mod h1:NPG6JGULBeQ9IU6yHp7YGELRa5Agmd7ATZdz4tGZ6z0=
github.com/uptrace/bun/dialect/pgdialect v1.1.12 h1:m/CM1UfOkoBTglGO5CUTKnIKKOApOYxkcP2qn0F9tJk=
github.com/uptrace/bun/dialect/pgdialect v1.1.12/go.mod h1:Ij6WIxQILxLlL2frUBxUBOZJtLElD2QQNDcu/PWDHTc=
github.com/uptrace/bun/driver/pgdriver v1.1.12 h1:3rRWB1GK0psTJrHwxzNfEij2MLibggiLdTqjTtfHc1w=
github.com/uptrace/bun/driver/pgdriver v1.1.12/go.mod h1:ssYUP+qwSEgeDDS1xm2XBip9el1y9Mi5mTAvLoiADLM=
github.com/vmihailenco/bufpool v0.1.11 h1:gOq2WmBrq0i2yW5QJ16ykccQ4wH9UyEsgLm6czKAd94=
github.com/vmihailenco/bufpool v0.1.11/go.mod h1:AFf/MOy3l2CFTKbxwt0mp2MwnqjNEs5H/UxrkA5jxTQ=
github.com/vmihailenco/msgpack/v5 v5.3.5 h1:5gO0H1iULLWGhs2H5tbAHIZTV8/cYafcFOr9znI5mJU=
github.com/vmihailenco/msgpack/v5 v5.3.5/go.mod h1:7xyJ9e+0+9SaZT0Wt1RGleJXzli6Q/V5KbhBonMG9jc=
github.com/vmihailenco/tagparser v0.1.2 h1:gnjoVuB/kljJ5wICEEOpx98oXMWPLj22G67Vbd1qPqc=
github.com/vmihailenco/tagparser v0.1.2/go.mod h1:OeAg3pn3UbLjkWt+rN9oFYB6u/cQgqMEUPoW2WPyhdI=
github.com/vmihailenco/tagparser/v2 v2.0.0 h1:y09buUbR+b5aycVFQs/g70pqKVZNBmxwAhO7/IwNM9g=
github.com/vmihailenco/tagparser/v2 v2.0.0/go.mod h1:Wri+At7QHww0WTrCBeu4J6bNtoV6mEfg5OIWRZA9qds=
github.com/x448/float16 v0.8.4 h1:qLwI1I70+NjRFUR3zs1JPUCgaCXSh3SW62uAKT1mSBM=
github.com/x448/float16 v0.8.4/go.mod h1:14CWIYCyZA/cWjXOioeEpHeN/83MdbZDRQHoFcYsOfg=
github.com/yuin/goldmark v1.1.27/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.2.1/go.mod h1:3hX8gzYuyVAZsxl0MRgGTJEmQBFcNTphYh9decYSb74=
github.com/yuin/goldmark v1.4.13/go.mod h1:6yULJ656Px+3vBD8DxQVa3kxgyrAnzto9xy5taEt/CY=
github.com/yusufpapurcu/wmi v1.2.3 h1:E1ctvB7uKFMOJw3fdOW32DwGE9I7t++CRUEMKvFoFiw=
github.com/yusufpapurcu/wmi v1.2.3/go.mod h1:SBZ9tNy3G9/m5Oi98Zks0QjeHVDvuK0qfxQmPyzfmi0=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0 h1:jq9TW8u3so/bN+JPT166wjOI6/vQPF6Xe7nMNIltagk=
go.opentelemetry.io/contrib/instrumentation/net/http/otelhttp v0.49.0/go.mod h1:p8pYQP+m5XfbZm9fxtSKAbM6oIllS7s2AfxrChvc7iw=
go.opentelemetry.io/otel v1.24.0 h1:0LAOdjNmQeSTzGBzduGe/rU4tZhMwL5rWgtp9Ku5Jfo=
go.opentelemetry.io/otel v1.24.0/go.mod h1:W7b9Ozg4nkF5tWI5zsXkaKKDjdVjpD4oAt9Qi/MArHo=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0 h1:Mne5On7VWdx7omSrSSZvM4Kw7cS7NQkOOmLcgscI51U=
go.opentelemetry.io/otel/exporters/otlp/otlptrace v1.19.0/go.mod h1:IPtUMKL4O3tH5y+iXVyAXqpAwMuzC1IrxVS81rummfE=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0 h1:IeMeyr1aBvBiPVYihXIaeIZba6b8E1bYp7lbdxK8CQg=
go.opentelemetry.io/otel/exporters/otlp/otlptrace/otlptracehttp v1.19.0/go.mod h1:oVdCUtjq9MK9BlS7TtucsQwUcXcymNiEDjgDD2jMtZU=
go.opentelemetry.io/otel/metric v1.24.0 h1:6EhoGWWK28x1fbpA4tYTOWBkPefTDQnb8WSGXlc88kI=
go.opentelemetry.io/otel/metric v1.24.0/go.mod h1:VYhLe1rFfxuTXLgj4CBiyz+9WYBA8pNGJgDcSFRKBco=
go.opentelemetry.io/otel/sdk v1.19.0 h1:6USY6zH+L8uMH8L3t1enZPR3WFEmSTADlqldyHtJi3o=
go.opentelemetry.io/otel/sdk v1.19.0/go.mod h1:NedEbbS4w3C6zElbLdPJKOpJQOrGUJ+GfzpjUvI0v1A=
go.opentelemetry.io/otel/trace v1.24.0 h1:CsKnnL4dUAr/0llH9FKuc698G04IrpWV0MQA/Y1YELI=
go.opentelemetry.io/otel/trace v1.24.0/go.mod h1:HPc3Xr/cOApsBI154IU0OI0HJexz+aw5uPdbs3UCjNU=
go.opentelemetry.io/proto/otlp v1.0.0 h1:T0TX0tmXU8a3CbNXzEKGeU5mIVOdf0oykP+u2lIVU/I=
go.opentelemetry.io/proto/otlp v1.0.0/go.mod h1:Sy6pihPLfYHkr3NkUbEhGHFhINUSI/v80hjKIs5JXpM=
golang.org/x/crypto v0.0.0-20190308221718-c2843e01d9a2/go.mod h1:djNgcEr1/C05ACkg1iLfiJU5Ep61QUkGW8qpdssI0+w=
golang.org/x/crypto v0.0.0-20191011191535-87dc89f01550/go.mod h1:yigFU9vqHzYiE8UmvKecakEJjdnWj3jj499lnFckfCI=
golang.org/x/crypto v0.0.0-20200622213623-75b288015ac9/go.mod h1:LzIPMQfyMNhhGPhUkYOs5KpL4U8rLKemX1yGLhDgUto=
golang.org/x/crypto v0.0.0-20210921155107-089bfa567519/go.mod h1:GvvjBRRGRdwPK5ydBHafDWAxML/pGHZbMvKqRZ5+Abc=
golang.org/x/crypto v0.3.0/go.mod h1:hebNnKkNXi2UzZN1eVRvBB7co0a+JxK6XbPiWVs/3J4=
golang.org/x/crypto v0.27.0 h1:GXm2NjJrPaiv/h1tb2UH8QfgC/hOf/+z0p6PT8o1w7A=
golang.org/x/crypto v0.27.0/go.mod h1:1Xngt8kV6Dvbssa53Ziq6Eqn0HqbZi5Z6R0ZpwQzt70=
golang.org/x/mod v0.2.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.3.0/go.mod h1:s0Qsj1ACt9ePp/hMypM3fl4fZqREWJwdYDEqhRiZZUA=
golang.org/x/mod v0.6.0-dev.0.20220419223038-86c51ed26bb4/go.mod h1:jJ57K6gSWd91VN4djpZkiMVwK6gcyfeH4XE8wZrZaV4=
golang.org/x/net v0.0.0-20190404232315-eb5bcb51f2a3/go.mod h1:t9HGtf8HONx5eT2rtn7q6eTqICYqUVnKs3thJo3Qplg=
golang.org/x/net v0.0.0-20190620200207-3b0461eec859/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20200226121028-0de0cce0169b/go.mod h1:z5CRVTTTmAJ677TzLLGU+0bjPO0LkuOLi4/5GtJWs/s=
golang.org/x/net v0.0.0-20201021035429-f5854403a974/go.mod h1:sp8m0HH+o8qH0wwXwYZr8TS3Oi6o0r6Gce1SSxlDquU=
golang.org/x/net v0.0.0-20210226172049-e18ecbb05110/go.mod h1:m0MpNAwzfU5UDzcl9v0D8zg8gWTRqZa9RBIspLL5mdg=
golang.org/x/net v0.0.0-20220722155237-a158d28d115b/go.mod h1:XRhObCWvk6IyKnWLug+ECip1KBveYUHfp+8e9klMJ9c=
golang.org/x/net v0.2.0/go.mod h1:KqCZLdyyvdV855qA2rE3GC2aiw5xGR5TEjj8smXukLY=
golang.org/x/net v0.26.0 h1:soB7SVo0PWrY4vPW/+ay0jKDNScG2X9wFeYlXIvJsOQ=
golang.org/x/net v0.26.0/go.mod h1:5YKkiSynbBIh3p6iOc/vibscux0x38BZDkn8sCUPxHE=
golang.org/x/sync v0.0.0-20190423024810-112230192c58/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20190911185100-cd5d95a43a6e/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20201020160332-67f06af15bc9/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.0.0-20220722155255-886fb9371eb4/go.mod h1:RxMgew5VJxzue5/jJTE5uejpjVlOe/izrB70Jof72aM=
golang.org/x/sync v0.8.0 h1:3NFvSEYkUoMifnESzZl15y791HH1qU2xm6eCJU5ZPXQ=
golang.org/x/sync v0.8.0/go.mod h1:Czt+wKu1gCyEFDUtn0jG5QVvpJ6rzVqr5aXyt9drQfk=
golang.org/x/sys v0.0.0-20190215142949-d0b11bdaac8a/go.mod h1:STP8DvDyc/dI5b8T5hshtkjS+E42TnysNCUPdjciGhY=
golang.org/x/sys v0.0.0-20190412213103-97732733099d/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20190916202348-b4ddaad3f8a3/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20200930185726-fdedc70b468f/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201119102817-f84b799fce68/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20201204225414-ed752295db88/go.mod h1:h1NjWce9XRLGQEsW7wpKNCjG9DtNlClVuFLEZdDNbEs=
golang.org/x/sys v0.0.0-20210615035016-665e8c7367d1/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20210616094352-59db8d763f22/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220520151302-bc2c85ada10a/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220715151400-c0bba94af5f8/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.0.0-20220722155257-8c9f86f7a55f/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.2.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.8.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.11.0/go.mod h1:oPkhp1MJrh7nUepCBck5+mAzfO9JrbApNNgaTdGDITg=
golang.org/x/sys v0.15.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/sys v0.25.0 h1:r+8e+loiHxRqhXVl6ML1nO3l1+oFoWbnlu2Ehimmi34=
golang.org/x/sys v0.25.0/go.mod h1:/VUhepiaJMQUp4+oa/7Zr1D23ma6VTLIYjOOTFZPUcA=
golang.org/x/term v0.0.0-20201126162022-7de9c90e9dd1/go.mod h1:bj7SfCRtBDWHUb9snDiAeCFNEtKQo2Wmx5Cou7ajbmo=
golang.org/x/term v0.0.0-20210927222741-03fcf44c2211/go.mod h1:jbD1KX2456YbFQfuXm/mYQcufACuNUgVhRMnK/tPxf8=
golang.org/x/term v0.2.0/go.mod h1:TVmDHMZPmdnySmBfhjOoOdhjzdE1h4u1VwSiw2l1Nuc=
golang.org/x/term v0.24.0 h1:Mh5cbb+Zk2hqqXNO7S1iTjEphVL+jb8ZWaqh/g+JWkM=
golang.org/x/term v0.24.0/go.mod h1:lOBK/LVxemqiMij05LGJ0tzNr8xlmwBRJ81PX6wVLH8=
golang.org/x/text v0.3.0/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=
golang.org/x/text v0.3.3/go.mod h1:5Zoc/QRtKVWzQhOtBMvqHzDpF6irO9z98xDceosuGiQ=
golang.org/x/text v0.3.7/go.mod h1:u+2+/6zg+i71rQMx5EYifcz6MCKuco9NR6JIITiCfzQ=
golang.org/x/text v0.4.0/go.mod h1:mrYo+phRRbMaCq/xk9113O4dZlRixOauAjOtrjsXDZ8=
golang.org/x/text v0.18.0 h1:XvMDiNzPAl0jr17s6W9lcaIhGUfUORdGCNsuLmPG224=
golang.org/x/text v0.18.0/go.mod h1:BuEKDfySbSR4drPmRPG/7iBdf8hvFMuRexcpahXilzY=
golang.org/x/time v0.0.0-20220210224613-90d013bbcef8 h1:vVKdlvoWBphwdxWKrFZEuM0kGgGLxUOYcY4U/2Vjg44=
golang.org/x/time v0.0.0-20220210224613-90d013bbcef8/go.mod h1:tRJNPiyCQ0inRvYxbN9jk5I+vvW/OXSQhTDSoE431IQ=
golang.org/x/tools v0.0.0-20180917221912-90fa682c2a6e/go.mod h1:n7NCudcB/nEzxVGmLbDWY5pfWTLqBcC2KZ6jyYvM4mQ=
golang.org/x/tools v0.0.0-20191119224855-298f0cb1881e/go.mod h1:b+2E5dAYhXwXZwtnZ6UAqBI28+e2cm9otk0dWdXHAEo=
golang.org/x/tools v0.0.0-20200619180055-7c47624df98f/go.mod h1:EkVYQZoAsY45+roYkvgYkIh4xh/qjgUK9TdY2XT94GE=
golang.org/x/tools v0.0.0-20210106214847-113979e3529a/go.mod h1:emZCQorbCU4vsT4fOWvOPXz4eW1wZW4PmDk9uLelYpA=
golang.org/x/tools v0.1.12/go.mod h1:hNGJHUnrk76NpqgfD5Aqm5Crs+Hm0VOH/i9J2+nxYbc=
golang.org/x/xerrors v0.0.0-20190717185122-a985d3407aa7/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191011141410-1b5146add898/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20191204190536-9bdfabe68543/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
golang.org/x/xerrors v0.0.0-20200804184101-5ec99f83aff1/go.mod h1:I/5z698sn9Ka8TeJc9MKroUUfqBBauWjQqLJ2OPfmY0=
google.golang.org/genproto v0.0.0-20230920204549-e6e6cdab5c13 h1:vlzZttNJGVqTsRFU9AmdnrcO1Znh8Ew9kCD//yjigk0=
google.golang.org/genproto/googleapis/api v0.0.0-20240318140521-94a12d6c2237 h1:RFiFrvy37/mpSpdySBDrUdipW/dHwsRwh3J3+A9VgT4=
google.golang.org/genproto/googleapis/api v0.0.0-20240318140521-94a12d6c2237/go.mod h1:Z5Iiy3jtmioajWHDGFk7CeugTyHtPvMHA4UTmUkyalE=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237 h1:NnYq6UN9ReLM9/Y01KWNOWyI5xQ9kbIms5GGJVwS/Yc=
google.golang.org/genproto/googleapis/rpc v0.0.0-20240318140521-94a12d6c2237/go.mod h1:WtryC6hu0hhx87FDGxWCDptyssuo68sk10vYjF+T9fY=
google.golang.org/grpc v1.64.1 h1:LKtvyfbX3UGVPFcGqJ9ItpVWW6oN/2XqTxfAnwRRXiA=
google.golang.org/grpc v1.64.1/go.mod h1:hiQF4LFZelK2WKaP6W0L92zGHtiQdZxk8CrSdvyjeP0=
google.golang.org/protobuf v1.33.0 h1:uNO2rsAINq/JlFpSdYEKIZ0uKD/R9cpdv0T+yoGwGmI=
google.golang.org/protobuf v1.33.0/go.mod h1:c6P6GXX6sHbq/GpV6MGZEdwhWPcYBgnhAHhKbcUYpos=
gopkg.in/check.v1 v0.0.0-20161208181325-20d25e280405/go.mod h1:Co6ibVJAznAaIkqp8huTwlJQCZ016jof/cbN4VW5Yz0=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c h1:Hei/4ADfdWqJk1ZMxUNpqntNwaWcugrBjAiHlqqRiVk=
gopkg.in/check.v1 v1.0.0-20201130134442-10cb98267c6c/go.mod h1:JHkPIbrfpd72SG/EVd6muEfDQjcINNoR0C8j2r3qZ4Q=
gopkg.in/yaml.v2 v2.2.2/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v2 v2.3.0/go.mod h1:hI93XBmqTisBFMUTm0b8Fm+jr3Dg1NNxqwp+5A1VGuI=
gopkg.in/yaml.v3 v3.0.0-20200313102051-9f266ea9e77c/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gopkg.in/yaml.v3 v3.0.1 h1:fxVm/GzAzEWqLHuvctI91KS9hhNmmWOoWu0XTYJS7CA=
gopkg.in/yaml.v3 v3.0.1/go.mod h1:K4uyk7z7BCEPqu6E+C64Yfv1cQ7kz7rIZviUmN+EgEM=
gorm.io/driver/postgres v1.5.4 h1:Iyrp9Meh3GmbSuyIAGyjkN+n9K+GHX9b9MqsTL4EJCo=
gorm.io/driver/postgres v1.5.4/go.mod h1:Bgo89+h0CRcdA33Y6frlaHHVuTdOf87pmyzwW9C/BH0=
gorm.io/gorm v1.25.5 h1:zR9lOiiYf09VNh5Q1gphfyia1JpiClIWG9hQaxB/mls=
gorm.io/gorm v1.25.5/go.mod h1:hbnx/Oo0ChWMn1BIhpy1oYozzpM15i4YPuHDmfYtwg8=
gotest.tools/v3 v3.5.1 h1:EENdUnS3pdur5nybKYIh2Vfgc8IUNBjxDPSjtiJcOzU=
gotest.tools/v3 v3.5.1/go.mod h1:isy3WKz7GK6uNw/sbHzfKBLvlvXwUyV06n6brMxxopU=
mellium.im/sasl v0.3.1 h1:wE0LW6g7U83vhvxjC1IY8DnXM+EU095yeo8XClvCdfo=
mellium.im/sasl v0.3.1/go.mod h1:xm59PUYpZHhgQ9ZqoJ5QaCqzWMi8IeS49dhp6plPCzw=
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 Max Planck Institute for Legal History and Legal Theory

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="main.go">
package main

import (
	"context"
	"fmt"
	"net/http"
	"os"
	"time"

	"github.com/mpilhlt/dhamps-vdb/internal/auth"
	"github.com/mpilhlt/dhamps-vdb/internal/database"
	"github.com/mpilhlt/dhamps-vdb/internal/handlers"
	"github.com/mpilhlt/dhamps-vdb/internal/models"

	"github.com/danielgtaylor/huma/v2/adapters/humago"
	"github.com/danielgtaylor/huma/v2/humacli"

	huma "github.com/danielgtaylor/huma/v2"
)

// TODO: Set up limits (e.g. in server definition):
//       <https://huma.rocks/features/request-limits/>

func main() {
	// Create a CLI app
	cli := humacli.New(func(hooks humacli.Hooks, options *models.Options) {

		println()
		println("=== Starting DH@MPS Vector Database ...")
		fmt.Printf("    Options are debug:%v host:%v port: %v dbhost:%s dbname:%s\n",
			options.Debug, options.Host, options.Port, options.DBHost, options.DBName)

		// Initialize the database
		pool, err := database.InitDB(options)
		if err != nil {
			fmt.Printf("    Unable to connect to database: %v\n", err)
			os.Exit(1)
		}

		// Define standard key generator (for API keys)
		keyGen := handlers.StandardKeyGen{}

		// Create a new router & API
		config := huma.DefaultConfig("DHaMPS Vector Database API", "0.0.1")
		config.Components.SecuritySchemes = auth.Config
		router := http.NewServeMux()
		api := humago.New(router, config)
		api.UseMiddleware(auth.AuthMiddleware(api, options))

		// Add routes to the API
		err = handlers.AddRoutes(pool, keyGen, api)
		if err != nil {
			fmt.Printf("    Unable to add routes: %v\n", err)
			os.Exit(1)
		}

		// Create the HTTP server
		// TODO: Add limits to the server (e.g. timeouts, max header size, etc.)
		server := &http.Server{
			Addr:    fmt.Sprintf("%s:%d", options.Host, options.Port),
			Handler: router,
		}

		// Start server
		hooks.OnStart(func() {
			fmt.Printf("Starting API server on port %d...\n", options.Port)
			if err := server.ListenAndServe(); err != nil && err != http.ErrServerClosed {
				fmt.Printf("listen: %s\n", err)
			}
		})

		// Gracefully shutdown server
		hooks.OnStop(func() {
			fmt.Printf("Shutting down API server on port %d...\n", options.Port)
			ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
			defer cancel()
			_ = server.Shutdown(ctx)
		})

	})

	// Run the CLI. When passed no commands, it starts the server.
	cli.Run()
}
</file>

<file path="README.md">
# dhamps-vdb
Vector Database for the DH at Max Planck Society initiative

[![Go Report Card](https://goreportcard.com/badge/github.com/mpilhlt/dhamps-vdb?style=flat-square)](https://goreportcard.com/report/github.com/mpilhlt/dhamps-vdb)

[![Go Reference](https://pkg.go.dev/badge/github.com/mpilhlt/dhamps-vdb.svg)](https://pkg.go.dev/github.com/mpilhlt/dhamps-vdb)

[![Release](https://img.shields.io/github/release/golang-standards/project-layout.svg?style=flat-square)](https://github.com/golang-standards/project-layout/releases/latest)

## Code creation and structure

This API is programmed in go and uses the [huma](https://huma.rocks/) framework with go's stock `http.ServeMux()` routing.

The Code has been developed in dialogue with [ChatGPT](./docs/ChatGPT.md). After manual inspection and correction, this is the project structure:

```default
dhamps-vdb/
├── LICENSE
├── README.md
├── go.mod
├── go.sum
├── main.go
├── main_test.go
├── api/
│   └── openapi.yml         // OpenAPI spec file
├── docs/
│   └── ChatGPT.md          // Code as suggested by ChatGPT (GPT4 turbo and GPT4o) on 2024-06-09
├── internal/
│   ├── auth/
│   ├── database/
│   ├── handlers/
│   │   ├── admin.go
│   │   ├── projects.go
│   │   ├── embeddings.go
│   │   ├── similars.go
│   │   └── llm_process.go
│   └── models/
│       ├── user.go
│       ├── project.go
│       ├── embeddings.go
│       ├── similar.go
│       └── llm_process.go
└── web/                      // web resources for the html response
```

The application checks and migrates the database schema to the appropriate version if possible. It presupposes however, that a suitable database and user (with appropriate privileges) have been created.

A local container with a pg_vector-enabled postgresql can be run like this:

```bash
$ podman run -p 8888:5432 -e POSTGRES_PASSWORD=password pgvector/pgvector:0.7.4-pg16
```

But be aware that the filesystem is not persisted if you run it like this. That means that when you stop and restart the container, you will have to re-setup the database as described below.

You can connect to it from a second terminal like so:

```bash
$ psql -p 8888 -h localhost -U postgres -d postgres
```

And then set up the database like this:

```sql
postgres=# CREATE DATABASE my_vectors;
postgres=# CREATE USER my_user WITH PASSWORD 'my-password';
postgres=# GRANT ALL PRIVILEGES ON DATABASE "my_vectors" to my_user;
postgres=# \c my_vectors
postgres=# GRANT ALL ON SCHEMA public TO my_user;
postgres=# CREATE EXTENSION IF NOT EXISTS vector;
```

For testing (i.e. without compiling and deploying), you can go to the main directory of the git repository and launch the vdb app like this:

```bash
go run main.go --port=8880 --db-port=8888 --db-user=my_user --db-password=my-password --db-name=my_vectors
```

Actual (mostly integration) tests are run like this:

```bash
systemctl --user start podman.socket
export DOCKER_HOST=unix://$XDG_RUNTIME_DIR/podman/podman.sock
go test -v ./...
```

## TODO

- [√] Tests
- [√] Catch post to existing resources
- [ ] User **authentication** & **restrictions** on some API calls
- [ ] LLM handling
  - [ ] calls to LLM services
- [ ] Use **transactions** (most importantly, when an action requires several queries, e.g. projects being added and then linked to several read-authorized users)
- [ ] Limits
- [ ] environment/options handling (<https://huma.rocks/features/cli/>)
- [ ] handle more metadata
- [ ] Validation with metadata schema
- [ ] **Link or Unlink** users/LLMs as standalone operations
</file>

<file path="repopack.config.json">
{
  "output": {
    "filePath": "repopack-output.xml",
    "style": "xml",
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  }
}
</file>

<file path="sqlc.yaml">
version: "2"
servers:
- engine: "postgresql"
  uri: "postgresql://${SERVICE_DB_USER}:${SERVICE_DB_PASSWORD}@${SERVICE_DB_HOST}:${SERVICE_DB_PORT}/${SERVICE_DB_NAME}"
sql:
  - engine: "postgresql"
    queries: "internal/database/queries/queries.sql"
    schema: "internal/database/migrations"
    gen:
      go:
        package: "database"
        out: "internal/database"
        sql_package: "pgx/v5"
        emit_json_tags: true
        emit_db_tags: true # this helps pgx scan struct using types generated by sqlc
        overrides:
          - db_type: "halfvec"
            go_type:
              import: "github.com/pgvector/pgvector-go"
              type: "HalfVector"
          - db_type: "jsonb"
            go_type:
              type: "map[string]interface{}"
</file>

<file path="template.env">
#!/usr/bin/env bash

SERVICE_DEBUG=true
SERVICE_HOST=localhost
SERVICE_PORT=8888
SERVICE_DBHOST=localhost
SERVICE_DBPORT=5432
SERVICE_DBUSER=postgres
SERVICE_DBPASSWORD=postgres
SERVICE_DBNAME=postgres
SERVICE_ADMINKEY=Ch4ngeM3!
</file>

</repository_files>
